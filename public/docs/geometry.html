<!DOCTYPE html>

<html>
<head>
  <title>geometry.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="animtest.html">
                animtest.coffee
              </a>
            
              
              <a class="source" href="collision.html">
                collision.coffee
              </a>
            
              
              <a class="source" href="geometry.html">
                geometry.coffee
              </a>
            
              
              <a class="source" href="geometry.html">
                geometry.js
              </a>
            
              
              <a class="source" href="helpers.html">
                helpers.coffee
              </a>
            
              
              <a class="source" href="keyboarddisplay.html">
                keyboarddisplay.coffee
              </a>
            
              
              <a class="source" href="keycodes.html">
                keycodes.js
              </a>
            
              
              <a class="source" href="pixelprocessing.html">
                pixelprocessing.coffee
              </a>
            
              
              <a class="source" href="platform.html">
                platform.coffee
              </a>
            
              
              <a class="source" href="platformindev.html">
                platformindev.coffee
              </a>
            
              
              <a class="source" href="quadtree.html">
                quadtree.coffee
              </a>
            
              
              <a class="source" href="~~~platformindev.html">
                ~~~platformindev.coffee
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>geometry.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>Generated by CoffeeScript 1.6.3</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> Graph, HitboxRayIntersect, Line, LineSegment, Point, Polygon, Rect, Square, Tracer, V, angletonorm, body, cornerstorect, degstorads, edgestopolys, entDir, entDist, entfirebullet, firetracer, firstwallhitloc, geometry, normtoangle, pointInsidePoly, pointlisttoedges, randangle, ricochet, root, rotate2d, vectorindex, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(child, parent)</span> </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> parent) { <span class="hljs-keyword">if</span> (__hasProp.call(parent, key)) child[key] = parent[key]; } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">this</span>.constructor = child; } ctor.prototype = parent.prototype; child.prototype = <span class="hljs-keyword">new</span> ctor(); child.__super__ = parent.prototype; <span class="hljs-keyword">return</span> child; };

  body = $(<span class="hljs-string">"body"</span>);

  V = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x, y)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> V2d(x, y);
  };

  degstorads = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(deg)</span> </span>{
    <span class="hljs-keyword">return</span> deg * <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">180</span>;
  };

  rotate2d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(vec, deg)</span> </span>{
    <span class="hljs-keyword">var</span> matrix, newv, theta;
    theta = degstorads(deg);
    matrix = [[<span class="hljs-built_in">Math</span>.cos(theta), -<span class="hljs-built_in">Math</span>.sin(theta)], [<span class="hljs-built_in">Math</span>.sin(theta), <span class="hljs-built_in">Math</span>.cos(theta)]];
    newv = matrixtransform(matrix, [vec.x, vec.y]);
    <span class="hljs-keyword">return</span> V(newv[<span class="hljs-number">0</span>], newv[<span class="hljs-number">1</span>]);
  };

  cornerstorect = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
    <span class="hljs-keyword">var</span> l, r, t;
    l = <span class="hljs-built_in">Math</span>.min(a.x, b.x);
    r = <span class="hljs-built_in">Math</span>.max(a.x, b.x);
    t = <span class="hljs-built_in">Math</span>.min(a.y, b.y);
    b = <span class="hljs-built_in">Math</span>.max(a.y, b.y);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Rect(V(l, t), V(r, b));
  };

  Rect = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rect</span><span class="hljs-params">(left, top, bottom, right)</span> </span>{
      <span class="hljs-keyword">this</span>.left = left;
      <span class="hljs-keyword">this</span>.top = top;
      <span class="hljs-keyword">this</span>.bottom = bottom;
      <span class="hljs-keyword">this</span>.right = right;
    }

    <span class="hljs-built_in">Object</span>.defineProperties(Rect.prototype, {
      width: {
        get: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.right - <span class="hljs-keyword">this</span>.left;
        }
      },
      height: {
        get: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.bottom - <span class="hljs-keyword">this</span>.top;
        }
      },
      area: {
        get: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.width * <span class="hljs-keyword">this</span>.height;
        }
      },
      perimeter: {
        get: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
          <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.width + <span class="hljs-keyword">this</span>.height) * <span class="hljs-number">2</span>;
        }
      }
    });

    <span class="hljs-keyword">return</span> Rect;

  })();

  Rect.prototype.overlap = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(other)</span> </span>{
    <span class="hljs-keyword">var</span> b, l, r, t;
    l = <span class="hljs-built_in">Math</span>.max(<span class="hljs-keyword">this</span>.left, other.left);
    r = <span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>.right, other.right);
    t = <span class="hljs-built_in">Math</span>.max(<span class="hljs-keyword">this</span>.top, other.top);
    b = <span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>.bottom, other.bottom);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Rect(l, t, b, r);
  };

  Line = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Line</span><span class="hljs-params">(from, to)</span> </span>{
      <span class="hljs-keyword">this</span>.from = from != <span class="hljs-literal">null</span> ? from : V();
      <span class="hljs-keyword">this</span>.to = to != <span class="hljs-literal">null</span> ? to : V();
    }

    <span class="hljs-keyword">return</span> Line;

  })();

  Tracer = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(_super)</span> </span>{
    __extends(Tracer, _super);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Tracer</span><span class="hljs-params">()</span> </span>{
      _ref = Tracer.__super__.constructor.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
      <span class="hljs-keyword">return</span> _ref;
    }

    <span class="hljs-keyword">return</span> Tracer;

  })(Line);

  Line.prototype.intersection = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(lineb)</span> </span>{
    <span class="hljs-keyword">var</span> p, q, r, s, t, u;
    p = <span class="hljs-keyword">this</span>.loc;
    r = <span class="hljs-keyword">this</span>.to.sub(p);
    q = lineb.loc;
    s = lineb.to.sub(q);
    t = q.sub(p).cross2d(s) / r.cross2d(s);
    u = q.sub(p).cross2d(r) / r.cross2d(s);
    <span class="hljs-keyword">if</span> (t &lt;= <span class="hljs-number">1</span> &amp;&amp; t &gt;= <span class="hljs-number">0</span> &amp;&amp; u &lt;= <span class="hljs-number">1</span> &amp;&amp; u &gt;= <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> p.add(r.nmul(t));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  };

  HitboxRayIntersect = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(rect, line)</span> </span>{
    <span class="hljs-keyword">var</span> a, b, dx, maxx, maxy, minx, miny, tmp;
    minx = line.loc.x;
    maxx = line.to.x;
    <span class="hljs-keyword">if</span> (line.loc.x &gt; line.to.x) {
      minx = line.to.x;
      maxx = line.loc.x;
    }
    maxx = <span class="hljs-built_in">Math</span>.min(maxx, rect.bottomright.x);
    minx = <span class="hljs-built_in">Math</span>.max(minx, rect.topleft.x);
    <span class="hljs-keyword">if</span> (minx &gt; maxx) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    miny = line.loc.y;
    maxy = line.to.y;
    dx = line.to.x - line.loc.x;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(dx) &gt; <span class="hljs-number">0.0000001</span>) {
      a = (line.to.y - line.loc.y) / dx;
      b = line.loc.y - a * line.loc.x;
      miny = a * minx + b;
      maxy = a * maxx + b;
    }
    <span class="hljs-keyword">if</span> (miny &gt; maxy) {
      tmp = maxy;
      maxy = miny;
      miny = tmp;
    }
    maxy = <span class="hljs-built_in">Math</span>.min(maxy, rect.bottomright.y);
    miny = <span class="hljs-built_in">Math</span>.max(miny, rect.topleft.y);
    <span class="hljs-keyword">if</span> (miny &gt; maxy) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  };

  randangle = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">360</span>;
  };

  ricochet = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(v, n)</span> </span>{
    <span class="hljs-keyword">var</span> u, vprime, w;
    u = n.nmul(v.dot2d(n) / n.dot2d(n));
    w = v.sub(u);
    vprime = w.sub(u);
    <span class="hljs-keyword">return</span> vprime;
  };

  Tracer.prototype.intersectlocs = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> allLineDefs, intersections, linedef, results;
    allLineDefs = gameworld.getLineDefs();
    results = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> _i, _len, _results;
      _results = [];
      <span class="hljs-keyword">for</span> (_i = <span class="hljs-number">0</span>, _len = allLineDefs.length; _i &lt; _len; _i++) {
        linedef = allLineDefs[_i];
        _results.push(getLineIntersection(<span class="hljs-keyword">this</span>, linedef));
      }
      <span class="hljs-keyword">return</span> _results;
    }).call(<span class="hljs-keyword">this</span>);
    intersections = results.filter(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n)</span> </span>{
      <span class="hljs-keyword">return</span> n !== <span class="hljs-literal">null</span>;
    });
    <span class="hljs-keyword">return</span> intersections;
  };

  Tracer.prototype.intersectwalls = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> allLineDefs, intersections,
      _this = <span class="hljs-keyword">this</span>;
    allLineDefs = gameworld.getLineDefs();
    intersections = allLineDefs.filter(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ld)</span> </span>{
      <span class="hljs-keyword">return</span> getLineIntersection(_this, ld) !== <span class="hljs-literal">null</span>;
    });
    <span class="hljs-keyword">return</span> intersections;
  };

  firstwallhitloc = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(trace, intersections)</span> </span>{
    <span class="hljs-keyword">var</span> firsthit, fromloc;
    fromloc = trace.loc;
    firsthit = intersections.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(prev, curr)</span> </span>{
      <span class="hljs-keyword">if</span> (fromloc.dist(prev) &gt; fromloc.dist(curr)) {
        <span class="hljs-keyword">return</span> curr;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> prev;
      }
    });
    <span class="hljs-keyword">return</span> firsthit;
  };

  firetracer = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fromloc, dir)</span> </span>{
    <span class="hljs-keyword">var</span> firsthit, intersections, toloc, trace, tracerange;
    tracerange = <span class="hljs-number">500</span>;
    toloc = fromloc.add(dir.norm().nmul(tracerange));
    trace = <span class="hljs-keyword">new</span> Tracer(fromloc, toloc);
    intersections = trace.intersectlocs();
    <span class="hljs-keyword">if</span> (intersections.length &gt; <span class="hljs-number">0</span>) {
      firsthit = firstwallhitloc(trace, intersections);
      trace = <span class="hljs-keyword">new</span> Tracer(trace.loc, firsthit);
    }
    <span class="hljs-keyword">return</span> trace;
  };

  entfirebullet = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ent, dir)</span> </span>{
    <span class="hljs-keyword">var</span> allactors, bulletrange, fromloc, hits, targets, trace;
    bulletrange = <span class="hljs-number">200</span>;
    fromloc = ent.loc.nadd(<span class="hljs-number">0</span>);
    dir = dir.add(randompoint().nsub(<span class="hljs-number">1</span> / <span class="hljs-number">2</span>).ndiv(<span class="hljs-number">4</span>)).norm();
    trace = firetracer(fromloc, dir);
    allactors = gameworld.entitylist.filter(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ent)</span> </span>{
      <span class="hljs-keyword">return</span> ent <span class="hljs-keyword">instanceof</span> Actor;
    });
    targets = allactors.filter(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(actor)</span> </span>{
      <span class="hljs-keyword">return</span> actor !== ent;
    });
    hits = trace.checkEnts(targets);
    hits.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(hitent)</span> </span>{
      <span class="hljs-keyword">return</span> bullethit(hitent, trace);
    });
    <span class="hljs-keyword">return</span> gameworld.addent(trace);
  };

  LineDef.prototype.normal = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> wallnormal;
    wallnormal = <span class="hljs-keyword">this</span>.to.sub(<span class="hljs-keyword">this</span>.loc).norm();
    wallnormal = V(-wallnormal.y, wallnormal.x);
    <span class="hljs-keyword">return</span> wallnormal;
  };

  Polygon = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(_super)</span> </span>{
    __extends(Polygon, _super);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Polygon</span><span class="hljs-params">(points)</span> </span>{
      <span class="hljs-keyword">this</span>.points = points;
      <span class="hljs-keyword">this</span>.loc = <span class="hljs-keyword">this</span>.points[<span class="hljs-number">0</span>];
    }

    <span class="hljs-keyword">return</span> Polygon;

  })(Entity);

  pointlisttoedges = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(parr)</span> </span>{
    <span class="hljs-keyword">var</span> curr, edges, i, prev, _i, _len;
    edges = [];
    prev = parr[parr.length - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">for</span> (i = _i = <span class="hljs-number">0</span>, _len = parr.length; _i &lt; _len; i = ++_i) {
      curr = parr[i];
      edges.push(<span class="hljs-keyword">new</span> Tracer(prev, curr));
      prev = curr;
    }
    <span class="hljs-keyword">return</span> edges;
  };

  pointInsidePoly = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(p, poly)</span> </span>{
    <span class="hljs-keyword">var</span> e, edges, intersections, results, trace;
    trace = <span class="hljs-keyword">new</span> Tracer(p, p.add(V(<span class="hljs-number">10000</span>, <span class="hljs-number">0</span>)));
    edges = pointlisttoedges(poly);
    results = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> _i, _len, _results;
      _results = [];
      <span class="hljs-keyword">for</span> (_i = <span class="hljs-number">0</span>, _len = edges.length; _i &lt; _len; _i++) {
        e = edges[_i];
        _results.push(getLineIntersection(trace, e));
      }
      <span class="hljs-keyword">return</span> _results;
    })();
    intersections = results.filter(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n)</span> </span>{
      <span class="hljs-keyword">return</span> n !== <span class="hljs-literal">null</span>;
    });
    <span class="hljs-keyword">if</span> (intersections.length % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  };

  Graph = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Graph</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">this</span>.nodes = [];
      <span class="hljs-keyword">this</span>.edges = [];
    }

    <span class="hljs-keyword">return</span> Graph;

  })();

  normtoangle = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(vec)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.atan2(vec.x, vec.y) * <span class="hljs-number">180</span> / <span class="hljs-built_in">Math</span>.PI;
  };

  angletonorm = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(degs)</span> </span>{
    <span class="hljs-keyword">var</span> augh;
    augh = degstorads(degs);
    <span class="hljs-keyword">return</span> V(<span class="hljs-built_in">Math</span>.sin(augh), <span class="hljs-built_in">Math</span>.cos(augh));
  };

  Point = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Point</span><span class="hljs-params">(pos)</span> </span>{
      <span class="hljs-keyword">this</span>.pos = pos;
    }

    <span class="hljs-keyword">return</span> Point;

  })();

  LineSegment = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LineSegment</span><span class="hljs-params">(startpoint, endpoint)</span> </span>{
      <span class="hljs-keyword">this</span>.startpoint = startpoint;
      <span class="hljs-keyword">this</span>.endpoint = endpoint;
    }

    <span class="hljs-keyword">return</span> LineSegment;

  })();

  Rect = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(_super)</span> </span>{
    __extends(Rect, _super);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rect</span><span class="hljs-params">(topleft, bottomright)</span> </span>{
      <span class="hljs-keyword">this</span>.topleft = topleft;
      <span class="hljs-keyword">this</span>.bottomright = bottomright;
      <span class="hljs-keyword">this</span>.loc = <span class="hljs-keyword">this</span>.topleft;
    }

    Rect.prototype.draw = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> size;
      size = <span class="hljs-keyword">this</span>.bottomright.sub(<span class="hljs-keyword">this</span>.topleft);
      <span class="hljs-keyword">return</span> <span class="hljs-string">"&lt;rect x="</span> + <span class="hljs-keyword">this</span>.topleft.x + <span class="hljs-string">" y="</span> + <span class="hljs-keyword">this</span>.topleft.y + <span class="hljs-string">" width="</span> + size.x + <span class="hljs-string">" height="</span> + size.y + <span class="hljs-string">" stroke=magenta fill=none/&gt;"</span>;
    };

    <span class="hljs-keyword">return</span> Rect;

  })(Entity);

  Rect.prototype.containspoint = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(pt)</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.topleft.x &gt; pt.x) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.bottomright.x &lt; pt.x) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.topleft.y &gt; pt.y) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.bottomright.y &lt; pt.y) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  };

  Square = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(_super)</span> </span>{
    __extends(Square, _super);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Square</span><span class="hljs-params">(topleft, bottomright)</span> </span>{
      <span class="hljs-keyword">this</span>.topleft = topleft;
      <span class="hljs-keyword">this</span>.bottomright = bottomright;
      <span class="hljs-keyword">this</span>.loc = <span class="hljs-keyword">this</span>.topleft;
      <span class="hljs-keyword">this</span>.age = <span class="hljs-number">0</span>;
    }

    Square.prototype.tick = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">this</span>.age++;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.age &gt; <span class="hljs-number">4</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.kill();
      }
    };

    Square.prototype.draw = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> size;
      size = <span class="hljs-keyword">this</span>.bottomright.sub(<span class="hljs-keyword">this</span>.topleft);
      <span class="hljs-keyword">return</span> <span class="hljs-string">"&lt;rect x="</span> + <span class="hljs-keyword">this</span>.topleft.x + <span class="hljs-string">" y="</span> + <span class="hljs-keyword">this</span>.topleft.y + <span class="hljs-string">" width="</span> + size.x + <span class="hljs-string">" height="</span> + size.y + <span class="hljs-string">" stroke=magenta fill=none/&gt;"</span>;
    };

    <span class="hljs-keyword">return</span> Square;

  })(Entity);

  entDist = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(enta, entb)</span> </span>{
    <span class="hljs-keyword">return</span> enta.loc.dist(entb.loc);
  };

  entDir = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(enta, entb)</span> </span>{
    <span class="hljs-keyword">return</span> enta.loc.dir(entb.loc);
  };

  vectorindex = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(array, vector)</span> </span>{
    <span class="hljs-keyword">var</span> i, res, v, _i, _len;
    res = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (i = _i = <span class="hljs-number">0</span>, _len = array.length; _i &lt; _len; i = ++_i) {
      v = array[i];
      <span class="hljs-keyword">if</span> (vector.dist(v) === <span class="hljs-number">0</span>) {
        res = i;
      }
    }
    <span class="hljs-keyword">return</span> res;
  };

  edgestopolys = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(edges)</span> </span>{
    <span class="hljs-keyword">var</span> a, b, edge, i, ia, ib, len, pol, polys, restedges, sploiced, _i, _j, _len, _len1;
    polys = [];
    restedges = edges.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span> </span>{
      <span class="hljs-keyword">var</span> a, b;
      a = V(e[<span class="hljs-number">0</span>].x, e[<span class="hljs-number">0</span>].y);
      b = V(e[<span class="hljs-number">1</span>].x, e[<span class="hljs-number">1</span>].y);
      <span class="hljs-keyword">return</span> [a, b];
    });
    <span class="hljs-keyword">for</span> (i = _i = <span class="hljs-number">0</span>, _len = restedges.length; _i &lt; _len; i = ++_i) {
      edge = restedges[i];
      a = edge[<span class="hljs-number">0</span>];
      b = edge[<span class="hljs-number">1</span>];
      sploiced = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">for</span> (i = _j = <span class="hljs-number">0</span>, _len1 = polys.length; _j &lt; _len1; i = ++_j) {
        pol = polys[i];
        ia = vectorindex(pol, a);
        ib = vectorindex(pol, b);
        len = pol.length;
        <span class="hljs-keyword">if</span> (ib === <span class="hljs-number">0</span> || ia === <span class="hljs-number">0</span> || ib === len - <span class="hljs-number">1</span> || ia === len - <span class="hljs-number">1</span>) {
          sploiced = <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">if</span> (ia === <span class="hljs-number">0</span>) {
          pol.splice(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, b);
          <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">if</span> (ib === <span class="hljs-number">0</span>) {
          pol.splice(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, a);
          <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">if</span> (ia === len - <span class="hljs-number">1</span>) {
          pol.splice(len, <span class="hljs-number">0</span>, b);
          <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">if</span> (ib === len - <span class="hljs-number">1</span>) {
          pol.splice(len, <span class="hljs-number">0</span>, a);
          <span class="hljs-keyword">break</span>;
        }
      }
      <span class="hljs-keyword">if</span> (sploiced === <span class="hljs-literal">false</span>) {
        polys.push(edge);
      }
    }
    <span class="hljs-keyword">return</span> polys;
  };

  geometry = {};

  geometry.pointInsidePoly = pointInsidePoly;

  root = <span class="hljs-keyword">typeof</span> exports !== <span class="hljs-string">"undefined"</span> &amp;&amp; exports !== <span class="hljs-literal">null</span> ? exports : <span class="hljs-keyword">this</span>;

  root.geometry = geometry;

}).call(<span class="hljs-keyword">this</span>);</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
