// Generated by CoffeeScript 1.10.0
(function() {
  var AKA, BASETOOL, BLOCKCREATIONTOOL, BLOCKPAINT, B_MASKING, Bee, Block, BoggleParticle, BugLady, BugMeter, Bullet, Burd, CARVER, COLLGRIDSIZE, COLLTEST_INIT, CURRENT_LEVEL, CURSOR, Claire, Cloud, ControlObj, DEPRECATE, Damagebox, DoubleJumper, Energy, EnergyMeter, Fence, GenericSprite, Goal, Gold, Grid, HUDLAYER, Hat, Hero, HitboxRayIntersect, HurtWire, INIT, Jelly, Lila, Line2d, MAXBUGSPEED, MLEFT, MOVEBLOCKTOOL, MOVETOOL, MRIGHT, MoneyMeter, MoveBlockTool, MoveTool, NOOPTOOL, Noisemaker, ORIGCLICKPOS, OnewayBlock, PP, PchooParticle, Pickup, PlaceholderSprite, Platform, Poly, PowerSuit, Rect, Renderable, Robo, SCREENCURS, SCREENS, SPAWNERTOOL, SPAWNTOOL, Shieldbubble, Shrub, Smoochie, Spawner, Subscreen, TELEPORTTOOL, TEXBYNAME, THISFILE, TICKLOG, TILESELECT, TRIANGLETOOL, Target, Thug, Tool, Turret, UNIONTOOL, V, VTOPP, WARN, WATERTOOL, WORLD, WORLDINIT, Water, Wisp, World, XXXX, _CHARbindingnames, _DEFAULTHITBOXSIZE, _Rectmethods, __snap, _bind, _ccc, _cycle, _dash, _demotick, _doc, _facing, _lastmodified, _loadcurrlevel, _maketiles, _ml, _move, _particle, _repdupes, _sidestep, _toggleFullScreen, _versionfoot, _wheelin, achieve, actioncategories, adjustedscreensize, adjustmouseevent, allactions, alltools, animate, arr, ascii, assert, audiobaseurl, audiocache, audiocachelength, availableactions, b2n, bglayer_remove_block, bindaction, bindingsDOM, bindingsDOMcontainer, blockcarve, blocksatpoint, blocktextures, blocktools, body, bogglescreen, bogimg, bogsprite, bottomcenter, bottomof, boxesbounding, boxtouchingwall, browserprefix, bts, bugspeed, bugtextures, bugthrust, but, call, camera, cameraoffset, cancelFullScreen, carveoutblock, changelayer, char, cheatcodecheck, checkcolls, chievs, ck, classname, closestpoint, control, css, curraudiotrack, cv, dotfilt, down, drawhitboxes, drawsprite, edithistory, entcenter, entitycount, eventelement, firebullet, fixbox, fontmap, fontsrc, fonttexs, fpscounter, getCursorBlocks, get_sprites_of_class, getentsunderpoint, getotherhero, gettileoffs, ghostbusters, glyph, highlightoverlaps, hitboxfilter, hitboxfilter_OLD, hitboxlayer, hslToRgb, hue2rgb, hypesprites, hz, i, infobox, initsprite, is_firefox, isfullscreen, isholdingbound, isholdingkey, j, jame, jump, k, key, keypushcache, kick, konamicode, ladybug, launchFullScreen, left, leftof, len, len1, level_files, load, loadblocks, loadent, loadents, loadlevel, loadlevelfile, loadspawners, mainloop, makealert, makebox, makechievbox, maketablerow, maketiles, mktool, mousemiddledownhandler, mousemiddleuphandler, mouserightdownhandler, n, nextlevel, noop, normalizekey, o, objnames, offs, parentstage, pausefunc, pausescreen, pausestring, pausetext, placeshrub, playsound, pointlisttoedges, preload, prevtool, punch, randpos, randposrel, randtri, readablebindings, record_l, record_s, recordinputs, ref, ref1, ref2, ref3, relativetobox, removesprite, render, renderer, reserveKeyNamed, reservedkeys, reset_tick_stats, resetstage, restartlevel, results, rgbToHex, right, rightof, roboblockdata, root, save, scale, scatterents, scatterents_old, screensize, screensize_default, selectall, selectframe, setcursor, settings, settingsDOM, settingsDOMcontainer, skipframes, smame, snapmouseadjust, snapmouseadjust_always, snapmouseadjust_down, sourcebaseurl, spawnables, spawnselection, spr, stage, stageremovesprite, stats, tb, tex, text, textcontainer, tickno, ticktimes, tickwaitms, timecall, titlescreen, tmpcanvas, tmpcanvasjq, tmpinnerstage, tmpstage, toggleFullScreen, tool, tool_clickdelete, toolbar, topof, tt, u, unfuck, unzip, up, updateinfobox, updatesettingstable, v, voidcaller, wheel, wspacing, xmlwrap, z,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  THISFILE = "js/platformindev.js";

  settings = {
    gridsize: 16,
    fps: 30,
    drawsprites: true,
    slowmo: false,
    altcostume: true,
    beanmode: false,
    muted: true,
    paused: false,
    volume: 0.2,
    hat: false,
    variablejump: false,
    moonjump: false,
    threedee: false,
    whoaoa: false,
    NOSUBSCREENS: true,
    NOCOLLS: false,
    HD: false,
    scale: 1,
    recordingdemo: false,
    forcemove: false,
    aircontrol: true,
    devmode: false,
    hudscale: 2
  };

  settings.devmode = window.location.hash === "#dev";

  TILESELECT = 0;

  tickno = 0;

  MLEFT = 0;

  MRIGHT = 2;

  mafs.roundn = function(num, base) {
    return Math.round(num / base) * base;
  };

  TEXBYNAME = function(imgsrc) {
    return PIXI.Texture.fromImage(sourcebaseurl + imgsrc);
  };

  assert = function(expr, msg) {
    if (!expr) {
      console.log(Error);
      throw msg || "assert failed!";
    }
  };

  WARN = function(msg) {
    return;
    console.log(msg);
    return console.log(Error);
  };

  DEPRECATE = function() {
    throw "deprecated";
  };

  voidcaller = function(func) {
    func();
  };

  noop = function() {};

  b2n = function(bool) {
    if (bool) {
      return 1;
    } else {
      return 0;
    }
  };

  arr = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return args;
  };

  call = function(func) {
    return func();
  };

  browserprefix = '-webkit-';

  is_firefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

  if (is_firefox) {
    browserprefix = '-moz-';
  }

  stats = {
    collisionchecks: 0
  };

  V = function(x, y) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    return new V2d(x, y);
  };

  screensize_default = V(960, 540);

  screensize = screensize_default.nadd(0);

  hue2rgb = function(p, q, t) {
    if (t < 0) {
      t++;
    }
    if (t > 1) {
      t--;
    }
    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  };

  hslToRgb = function(h, s, l) {
    var b, g, p, q, r;
    if (s === 0) {
      r = g = b = l;
    } else {
      q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
  };

  rgbToHex = function(rgb) {
    var b, g, r;
    r = rgb[0], g = rgb[1], b = rgb[2];
    return r * 256 * 256 + g * 256 + b;
  };

  sourcebaseurl = "./sprites/";

  audiobaseurl = "./audio/";

  preload = function(str) {
    return PIXI.loader.add(sourcebaseurl + str).load();
  };

  XXXX = function(tilesrc, tileW, tileH, cols, rows) {
    var _tileset, numtiles, pxSheetH, pxSheetW, rowcount, tilesize, tsw;
    preload(tilesrc);
    pxSheetW = tileW * cols;
    pxSheetH = tileH * rows;
    _tileset = TEXBYNAME(tilesrc);
    _tileset.baseTexture.width = pxSheetW;
    _tileset.baseTexture.height = pxSheetH;
    tsw = 20;
    tilesize = 16;
    rowcount = 8;
    numtiles = rows * cols;
    return _maketiles(_tileset, tileW, tileH, cols, rows);
  };

  gettileoffs = function(n, tsw, tilesize) {
    return V(n % tsw, Math.floor(n / tsw));
  };

  maketiles = function(tileset, tsize, cols, numtiles) {
    var rows;
    rows = numtiles / cols;
    return _maketiles(tileset, tsize, tsize, cols, rows);
  };

  _maketiles = function(tileset, tileW, tileH, cols, rows) {
    var i, j, numtiles, range, rec, results, tex, texs, x, y;
    numtiles = cols * rows;
    range = (function() {
      results = [];
      for (var j = 0; 0 <= numtiles ? j < numtiles : j > numtiles; 0 <= numtiles ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this);
    return texs = (function() {
      var len, o, ref, results1;
      results1 = [];
      for (o = 0, len = range.length; o < len; o++) {
        i = range[o];
        tex = new PIXI.Texture(tileset);
        ref = gettileoffs(i, cols), x = ref.x, y = ref.y;
        rec = new PIXI.Rectangle(x * tileW, y * tileH, tileW, tileH);
        tex.frame = rec;
        results1.push(tex);
      }
      return results1;
    })();
  };

  fontsrc = "font-hand-white-12x16.png";

  fonttexs = XXXX(fontsrc, 12, 16, 16, 6);

  blocktextures = (function() {
    var numtiles, rowcount, tileset, tilesize, tilesrc, tsw;
    tilesrc = "metroid like.png";
    preload(tilesrc);
    tileset = TEXBYNAME(tilesrc);
    tileset.baseTexture.width = 320;
    tileset.baseTexture.height = 256;
    console.log(tileset);
    tsw = 20;
    tilesize = 16;
    rowcount = 8;
    numtiles = rowcount * tsw;
    return maketiles(tileset, tilesize, tsw, numtiles);
  })();

  bts = TEXBYNAME("bugrunhd.png");

  bts.baseTexture.width = 310;

  bts.baseTexture.height = 47;

  bugtextures = maketiles(bts, 21, 4, 4);

  Line2d = mafs.Line2d;

  HitboxRayIntersect = mafs.HitboxRayIntersect;

  pointlisttoedges = mafs.pointlisttoedges;

  body = $("body");

  PP = function(x, y) {
    return new PIXI.Point(x, y);
  };

  VTOPP = function(v) {
    return PP(v.x, v.y);
  };

  CURSOR = V(0, 0);

  SCREENCURS = V(0, 0);

  audiocache = [];

  audiocachelength = 10;

  for (n = j = 0, ref = audiocachelength; 0 <= ref ? j < ref : j > ref; n = 0 <= ref ? ++j : --j) {
    audiocache[n] = new Audio();
  }

  curraudiotrack = 0;

  playsound = function(src, volume) {
    var snd;
    curraudiotrack++;
    curraudiotrack = curraudiotrack % audiocachelength;
    if (settings.muted) {
      return;
    }
    snd = audiocache[curraudiotrack];
    snd.src = audiobaseurl + src;
    snd.volume = volume || settings.volume;
    return snd.play();
  };

  parentstage = new PIXI.Stage(0x66FF99);

  dotfilt = new PIXI.filters.DotScreenFilter();

  dotfilt.scale = 6;

  stage = new PIXI.Container;

  parentstage.addChild(stage);

  hitboxlayer = new PIXI.Container;

  stage.addChild(hitboxlayer);

  resetstage = function() {
    parentstage.removeChild(stage);
    stage = new PIXI.Container;
    parentstage.addChild(stage);
    hitboxlayer = new PIXI.Container;
    return stage.addChild(hitboxlayer);
  };

  HUDLAYER = new PIXI.Container;

  parentstage.addChild(HUDLAYER);

  renderer = new PIXI.CanvasRenderer(screensize.x, screensize.y);

  pausescreen = new PIXI.Graphics();

  pausescreen.beginFill(0x000000);

  pausescreen.drawRect(0, 0, screensize.x, screensize.y);

  pausescreen.alpha = 0.5;

  pausetext = new PIXI.Text("PAUSED", {
    font: "32px Arial",
    fill: "white",
    strokeThickness: 8,
    stroke: 'red'
  });

  pausetext.position = VTOPP(screensize.ndiv(2));

  pausetext.anchor = PP(1 / 2, 1);

  pausescreen.addChild(pausetext);

  pausetext = new PIXI.Text("GO GET SOME SNACKS\nPERHAPS A CARBONATED SODA", {
    font: "16px Arial",
    fill: "white"
  });

  pausetext.position = VTOPP(screensize.ndiv(2).vadd(V(0, 64)));

  pausetext.anchor = PP(1 / 2, 0);

  pausescreen.addChild(pausetext);

  ascii = String.fromCharCode.apply(this, (function() {
    results = [];
    for (o = 32; o <= 126; o++){ results.push(o); }
    return results;
  }).apply(this));

  fontmap = ascii;

  pausestring = "calm down";

  textcontainer = new PIXI.Graphics();

  parentstage.addChild(textcontainer);

  hypesprites = [];

  for (i = u = 0, len = pausestring.length; u < len; i = ++u) {
    char = pausestring[i];
    offs = V(32, 64);
    wspacing = 16;
    glyph = fonttexs[fontmap.indexOf(char)];
    spr = new PIXI.Sprite(glyph);
    spr.tint = 0xFF0000;
    spr.anchor = PP(1 / 2, 1 / 2);
    spr.position = VTOPP(offs.vadd(V(i * wspacing, 0)));
    spr.scale = PP(2, 2);
    if (char.charCodeAt(0) <= 90) {
      hypesprites.push(spr);
    }
    textcontainer.addChild(spr);
  }

  bogglescreen = new PIXI.Graphics();

  bogglescreen.beginFill(0xFF00FF);

  bogglescreen.drawRect(0, 0, screensize.x, screensize.y);

  bogglescreen.alpha = 0.5;

  tex = TEXBYNAME('smooch.png');

  bogsprite = new PIXI.Sprite(tex);

  bogsprite.anchor = PP(1 / 2, 1 / 2);

  bogsprite.position = VTOPP(screensize.ndiv(2));

  bogsprite.scale = PP(2, 2);

  text = new PIXI.Text("wow a secret\nwarning, the following sprite is EXTREMELY CANON and EXTREMELY SEXY,\nchildrens avert your eyes", {
    font: "16px Arial",
    fill: "white"
  });

  text.position = VTOPP(screensize.ndiv(2).vadd(V(0, -128)));

  text.anchor = PP(1 / 2, 0);

  bogglescreen.addChild(text);

  bogglescreen.addChild(bogsprite);

  tex = TEXBYNAME('titleplaceholder.png');

  titlescreen = new PIXI.Sprite(tex);

  body.append(renderer.view);

  $(renderer.view).attr({
    tabindex: 0
  });

  B_MASKING = false;

  Subscreen = (function() {
    function Subscreen() {
      this.size = screensize.ndiv(4);
      this.screenpos = V(640 * Math.random(), 640 * Math.random());
      this.subscreen = new PIXI.RenderTexture(renderer, this.size.x, this.size.y);
      this.subsprite = new PIXI.Sprite(this.subscreen);
      parentstage.addChild(this.subsprite);
      if (B_MASKING) {
        this.mask = new PIXI.Graphics();
        parentstage.addChild(this.mask);
      }
    }

    return Subscreen;

  })();

  Subscreen.prototype.subscreenadjust = function() {
    var hero, maxpos, newpos, oldpos, p1, p2, subscreencentercam, tmpdirection, tmpv;
    if (settings.NOSUBSCREENS) {
      return false;
    }
    maxpos = screensize.vsub(this.size);
    hero = getotherhero();
    p1 = ladybug.pos;
    p2 = hero.pos;
    tmpdirection = p2.vsub(p1).norm();
    tmpv = tmpdirection.nadd(1);
    tmpv = tmpv.ndiv(2);
    newpos = maxpos.vmul(tmpv);
    this.screenpos = newpos;
    this.subsprite.position = VTOPP(this.screenpos);
    subscreencentercam = hero.pos.nmul(-scale);
    subscreencentercam = subscreencentercam.vadd(this.size.ndiv(2));
    parentstage.removeChild(this.subsprite);
    oldpos = stage.position;
    stage.position = VTOPP(subscreencentercam);
    this.subscreen.render(parentstage);
    stage.position = oldpos;
    parentstage.addChild(this.subsprite);
    if (B_MASKING) {
      this.maskupdate();
      return this.subsprite.mask = this.mask;
    }
  };

  Subscreen.prototype.maskupdate = function() {
    this.mask.clear();
    this.mask.beginFill(0x000000, 0.9);
    this.mask.moveTo(this.screenpos.x, this.screenpos.y + 32);
    this.mask.lineTo(this.screenpos.x + this.size.x, this.screenpos.y);
    this.mask.lineTo(this.screenpos.x + this.size.x, this.screenpos.y + this.size.y - 32);
    this.mask.lineTo(this.screenpos.x, this.screenpos.y + this.size.y);
    return this.mask.endFill();
  };

  SCREENS = {
    list: []
  };

  SCREENS.add = function() {
    return SCREENS.list.push(new Subscreen());
  };

  SCREENS.adjust = function() {
    return this.list.forEach(function(screen) {
      return screen.subscreenadjust();
    });
  };

  SCREENS.add();

  scale = 1;

  tmpstage = new PIXI.Container();

  tmpinnerstage = new PIXI.Container();

  tmpstage.addChild(tmpinnerstage);

  animate = function() {
    var cam;
    cam = cameraoffset().nmul(-scale);
    stage.position = VTOPP(cam);
    stage.scale = PP(scale, scale);
    renderer.render(parentstage);
    return SCREENS.adjust();
  };

  chievs = {};

  achieve = function(title) {
    if (chievs[title].gotten != null) {
      return;
    }
    chievs[title].gotten = true;
    return makechievbox(chievs[title].pic, mafs.randelem(chievs[title].text));
  };

  bogimg = xmltag('img', {
    src: sourcebaseurl + 'boggle.png'
  });

  chievs.win = {
    pic: 'crown.png',
    text: ["wow"]
  };

  chievs.fall = {
    pic: "lovelyfall.png",
    text: ["Fractured spine", "Faceplant", "Dats gotta hoit", "OW FUCK", "pomf =3", "Broken legs", "Have a nice trip", "Ow my organs", "Shattered pelvis", "Bugsplat"]
  };

  chievs.kick = {
    pic: "jelly.png",
    text: ["3 points field goal", "Into the dunklesphere", "Blasting off again", "pow zoom straight to the moon"]
  };

  chievs.boggle = {
    pic: "boggle.png",
    text: ["Buggy the boggle champ", "Bushboggler 2013", "Boggle that bush", "Collosal waste of time", "Boggle 2: Electric boggleoo", "Buggy bushboggle", "excuse me wtf are you doing", "Bush it, bush it real good", "Fondly regard flora", "&lt;chievo title unavailable due to trademark infringement&gt;", "Returning a bug to its natural habitat", "Bush it to the limit", "Live Free or Boggle Hard", "Identifying bushes, accurate results with simple tools", "Bugtester", "A proper lady (bug)", "Stupid achievement title", "The daily boggle", bogimg + bogimg + bogimg]
  };

  chievs.murder = {
    pic: "lovelyshorter.png",
    text: ["This isn't brave, it's murder", "Jellycide"]
  };

  chievs.target = {
    pic: "target.png",
    text: ["there's no achievement for this", "\"Pow, motherfucker, pow\" -socrates", "Expect more. Pay less.", "You're supposed to use arrows you dingus"]
  };

  chievs.start = {
    pic: "crown.png",
    text: ["wow u started playin the game, congrats", "walking to the right", "chievo modern gaming edition", "baby's first achievement"]
  };

  chievs.suit = {
    pic: "suit.png",
    text: ["get equipped", "still fits you like a glove<br/><br/>...at least the glove parts do", "suit up", "henshin a go-go baby"]
  };

  makealert = function(text) {
    var chievbox, style;
    style = "style='display: inline-block; margin-left: 16px'";
    body.append(chievbox = $(xmltag("div", {
      "class": "chievbox"
    }, "<span " + style + ">" + text + "</span>")));
    chievbox.animate({
      top: '32px'
    }).delay(4000);
    chievbox.animate({
      top: '-100px'
    }, {
      queue: true
    }).delay(2000);
    return chievbox;
  };

  makechievbox = function(src, text) {
    var chievbox, pic;
    chievbox = makealert("<b>ACHIEVEMENT UNLOCKED</b><br/>" + text);
    return chievbox.prepend(pic = $(xmltag('img', {
      src: sourcebaseurl + src
    })));
  };

  Renderable = (function() {
    function Renderable() {
      this.pos = V();
    }

    return Renderable;

  })();

  Renderable.prototype.hassprite = function() {
    return typeof this._pixisprite !== "undefined";
  };

  Renderable.prototype.removesprite = function() {
    return removesprite(this);
  };

  GenericSprite = (function(superClass) {
    extend(GenericSprite, superClass);

    function GenericSprite(pos1, src1) {
      this.pos = pos1 != null ? pos1 : V();
      this.src = src1;
      this.vel = V();
    }

    GenericSprite.prototype.render = function() {
      var anchor, box, flip, pos;
      anchor = this.anchor || V(0, 0);
      flip = !this.facingleft;
      box = this.gethitbox();
      pos = relativetobox(box, anchor);
      return drawsprite(this, this.src, pos, flip, anchor);
    };

    return GenericSprite;

  })(Renderable);

  GenericSprite.prototype.cleanup = function() {
    return removesprite(this);
  };

  Noisemaker = (function(superClass) {
    extend(Noisemaker, superClass);

    function Noisemaker() {
      Noisemaker.__super__.constructor.call(this);
      this.age = 0;
    }

    Noisemaker.prototype.tick = function() {
      this.age++;
      if (this.age > 4 && Math.random() > 2 / 3) {
        return;
      }
      if (this.age > 4) {
        playsound(mafs.randelem(['horse.wav', 'pone.wav', 'but.wav']));
        return this.age = 0;
      }
    };

    return Noisemaker;

  })(GenericSprite);

  GenericSprite.prototype.load = function(obj) {
    if (obj.pos != null) {
      return _.extend(this.pos, obj.pos);
    }
  };

  PlaceholderSprite = (function(superClass) {
    extend(PlaceholderSprite, superClass);

    function PlaceholderSprite(pos1) {
      this.pos = pos1;
      PlaceholderSprite.__super__.constructor.call(this, this.pos);
      this.label = 'a thing';
      this.anchor = V(0, 0);
    }

    return PlaceholderSprite;

  })(GenericSprite);

  PlaceholderSprite.prototype.render = function() {
    var box, sprit, txt;
    if (this._pixisprite != null) {
      sprit = this._pixisprite;
      sprit.position = VTOPP(this.pos);
      return;
    }
    txt = new PIXI.Text(this.label, {
      font: "12px Arial",
      fill: "black"
    });
    txt.anchor = VTOPP(this.anchor);
    sprit = new PIXI.Graphics();
    sprit.beginFill(0xFF00FF);
    sprit.pivot = VTOPP(V(0, 32));
    box = this.gethitbox();
    sprit.position = VTOPP(this.pos);
    sprit.drawRect(0, 0, box.w, box.h);
    sprit.alpha = 0.9;
    sprit.addChild(txt);
    stage.addChild(sprit);
    return this._pixisprite = sprit;
  };

  Hat = (function(superClass) {
    extend(Hat, superClass);

    function Hat() {
      Hat.__super__.constructor.call(this);
      this.src = "hat.png";
      this.anchor = V(1 / 2, 1);
      this.parent = ladybug;
    }

    return Hat;

  })(GenericSprite);

  Hat.prototype.tick = function() {
    this.vel = this.parent.vel;
    return this.pos = relativetobox(this.parent.gethitbox(), V(1 / 2, 0));
  };

  _DEFAULTHITBOXSIZE = V(32, 32);

  GenericSprite.prototype.gethitbox = function() {
    var anchor, size;
    size = this.size || _DEFAULTHITBOXSIZE;
    anchor = this.anchor || V(1 / 2, 1 / 2);
    this.hitboxcache = makebox(this.pos, size, anchor);
    return this.hitboxcache;
  };

  GenericSprite.prototype.updatehitbox = function() {
    var anchor, h, ref1, size, w, x, y;
    size = this.size || _DEFAULTHITBOXSIZE;
    anchor = this.anchor || V(1 / 2, 1 / 2);
    if (this.hitboxcache != null) {
      ref1 = fixbox(this.pos, size, anchor), x = ref1[0], y = ref1[1], w = ref1[2], h = ref1[3];
      this.hitboxcache.x = x;
      this.hitboxcache.y = y;
      this.hitboxcache.w = w;
      this.hitboxcache.h = h;
    }
    return this.hitboxcache;
  };

  fixbox = function(position, dimensions, anchor) {
    var truepos;
    truepos = position.vsub(dimensions.vmul(anchor));
    return [truepos.x, truepos.y, dimensions.x, dimensions.y];
  };

  Target = (function(superClass) {
    extend(Target, superClass);

    function Target(pos1) {
      this.pos = pos1;
      Target.__super__.constructor.call(this, this.pos, 'target.png');
      this.lifetime = -1;
      this.anchor = V(1 / 2, 1 / 2);
    }

    Target.prototype.collide = function(otherent) {
      var ref1, ref2;
      if (otherent instanceof BoggleParticle) {
        this.vel = this.vel.vadd(otherent.vel.nmul(1 / 8));
      }
      if ((((ref1 = otherent.timers) != null ? ref1.attack : void 0) != null) && ((ref2 = otherent.timers) != null ? ref2.attack : void 0) > 0) {
        return this.gethitby(otherent);
      }
    };

    Target.prototype.gethitby = function(otherent) {
      if (!this.broken) {
        this.broken = true;
        this.src = 'shatteredtarget.png';
        this.vel = otherent.vel.nmul(1 / 2);
        return this.lifetime = 10;
      }
    };

    return Target;

  })(GenericSprite);

  Jelly = (function(superClass) {
    extend(Jelly, superClass);

    function Jelly(pos1) {
      this.pos = pos1;
      Jelly.__super__.constructor.call(this, this.pos, 'jelly.png');
    }

    Jelly.prototype.collide = function(otherent) {
      var ref1, timeout;
      if (otherent instanceof Jelly) {
        this.vel.x = (this.vel.x + otherent.vel.x) / 2;
        this.pos.x += mafs.randfloat() * 2;
      }
      if (otherent instanceof BoggleParticle) {
        this.vel = this.vel.vadd(otherent.vel.nmul(1 / 8));
      }
      if (otherent instanceof BugLady && otherent.vel.y > 0) {
        otherent.vel.y = mafs.clamp(-10, 10, otherent.vel.y * -2);
      }
      timeout = (ref1 = otherent.timers) != null ? ref1.attack : void 0;
      if ((timeout != null) && timeout > 0) {
        return this.gethitby(otherent);
      }
    };

    Jelly.prototype.gethitby = function(otherent) {
      var dir;
      this.vel.y += otherent.vel.y;
      dir = _facing(otherent);
      return this.vel.x += dir * 4;
    };

    Jelly.prototype.render = function() {
      var anchor, flip, pos;
      flip = tickno % 10 < 5;
      anchor = V(1 / 2, 1);
      pos = relativetobox(this.gethitbox(), anchor);
      return drawsprite(this, this.src, pos, flip, anchor);
    };

    return Jelly;

  })(GenericSprite);

  Jelly.prototype.size = V(32, 16);

  Jelly.prototype.anchor = V(1 / 2, 1);

  Bee = (function(superClass) {
    extend(Bee, superClass);

    function Bee(pos1) {
      this.pos = pos1;
      Bee.__super__.constructor.call(this, this.pos, 'bee.png');
      this.anchor = V(1 / 2, 1 / 2);
    }

    Bee.prototype.collide = function(otherent) {
      var ref1, timeout;
      if (otherent instanceof BugLady) {
        otherent.vel.y *= -2;
      }
      timeout = (ref1 = otherent.timers) != null ? ref1.attack : void 0;
      if ((timeout != null) && timeout > 0) {
        return this.gethitby(otherent);
      }
    };

    Bee.prototype.gethitby = function(otherent) {
      var dir;
      this.vel.y += otherent.vel.y;
      dir = _facing(otherent);
      return this.vel.x += dir * 4;
    };

    Bee.prototype.tick = function() {
      this.avoidwalls();
      this.physmove();
      return this.wiggle();
    };

    Bee.prototype.wiggle = function() {
      this.vel = this.vel.nmul(9 / 10);
      if (Math.random() * 100 < 50) {
        this.vel.y += mafs.randfloat() * 4;
        return this.vel.x += mafs.randfloat() * 4;
      }
    };

    return Bee;

  })(GenericSprite);

  entitycount = function(classtype) {
    var ents;
    ents = WORLD.spritelayer.filter(function(sprite) {
      return sprite instanceof classtype;
    });
    return ents.length;
  };

  GenericSprite.prototype.gravitate = function() {
    if (!this.touchingground()) {
      return this.vel.y++;
    }
  };

  Jelly.prototype.tick = function() {
    this.physmove();
    if (this.touchingground()) {
      this.jiggle();
      return this.pos.y--;
    }
  };

  Jelly.prototype.jiggle = function() {
    this.vel.x *= 9 / 10;
    if (Math.random() * 100 < 50) {
      this.vel.y = -Math.random() * 4;
      return this.vel.x += mafs.randfloat() * 1;
    }
  };

  Fence = (function(superClass) {
    extend(Fence, superClass);

    function Fence() {
      Fence.__super__.constructor.call(this);
      this.anchor = V(1 / 2, 1);
    }

    return Fence;

  })(GenericSprite);

  Fence.prototype.render = function() {};

  Pickup = (function(superClass) {
    extend(Pickup, superClass);

    function Pickup(pos1) {
      this.pos = pos1 != null ? pos1 : V();
      this.vel = V();
      this.src = "energy1.png";
    }

    return Pickup;

  })(Jelly);

  Pickup.prototype.jiggle = function() {};

  Pickup.prototype.collide = function(otherent) {
    if (otherent instanceof BugLady) {
      return this.pickedup(otherent);
    }
  };

  Pickup.prototype.pickedup = function(otherent) {
    playsound('boip.wav');
    return this.KILLME = true;
  };

  Energy = (function(superClass) {
    extend(Energy, superClass);

    function Energy(pos1) {
      this.pos = pos1 != null ? pos1 : V();
      this.vel = V();
      this.src = "energy1.png";
    }

    return Energy;

  })(Pickup);

  Energy.prototype.getsprite = function() {
    var framelist;
    framelist = [1, 2, 3, 4, 5, 6].map(function(n) {
      return "energy" + n + ".png";
    });
    return this.src = selectframe(framelist, 4);
  };

  Energy.prototype.tick = function() {
    Energy.__super__.tick.call(this);
    return this.getsprite();
  };

  Energy.prototype.pickedup = function(otherent) {
    Energy.__super__.pickedup.call(this);
    return otherent.energy += 1;
  };

  Gold = (function(superClass) {
    extend(Gold, superClass);

    function Gold(pos1) {
      this.pos = pos1 != null ? pos1 : V();
      this.vel = V();
      this.src = "crown.png";
    }

    return Gold;

  })(Pickup);

  Gold.prototype.getsprite = function() {};

  Gold.prototype.pickedup = function(otherent) {
    Gold.__super__.pickedup.call(this);
    return otherent.score += 1;
  };

  relativetobox = function(box, anchor) {
    var pos, size;
    pos = V(box.x, box.y);
    size = V(box.w, box.h);
    pos = pos.vadd(size.vmul(anchor));
    return pos;
  };

  Thug = (function(superClass) {
    extend(Thug, superClass);

    function Thug(pos1) {
      this.pos = pos1 != null ? pos1 : V();
      this.lifetime = -1;
      this.vel = V();
      this.src = 'bugthug.png';
      this.facingleft = true;
      this.health = 3;
    }

    return Thug;

  })(GenericSprite);

  bottomcenter = V(1 / 2, 1);

  Thug.prototype.size = V(24, 64 + 16);

  Thug.prototype.anchor = bottomcenter;

  Thug.prototype.tick = function() {
    this.physmove();
    return this.getsprite();
  };

  Thug.prototype.getsprite = function() {
    if (this.lifetime <= 0) {
      this.src = 'bugthug.png';
    }
    if (this.health <= 0) {
      this.src = 'thugded.png';
    }
    if (this.lifetime > 0) {
      this.lifetime--;
      return this.src = "bugthugoof.png";
    }
  };

  Thug.prototype.collide = function(otherent) {
    var ref1, ref2, ref3;
    if (otherent instanceof BoggleParticle) {
      this.vel = this.vel.vadd(otherent.vel.nmul(1 / 8));
    }
    if ((((ref1 = otherent.timers) != null ? ref1.attack : void 0) != null) && ((ref2 = otherent.timers) != null ? ref2.attack : void 0) > 0 && this.lifetime <= 0) {
      this.vel = this.vel.vadd(otherent.vel.nmul(1 / 2));
      this.gethitby(otherent);
    }
    if (this.health <= 0) {
      return;
    }
    if (otherent instanceof Hero && ((ref3 = otherent.timers) != null ? ref3.invincible : void 0) === 0) {
      playsound('excardon.wav');
      return otherent.flinch();
    }
  };

  Thug.prototype.gethitby = function(otherent) {
    var dir;
    this.vel.y += otherent.vel.y;
    dir = _facing(otherent);
    this.vel.x += dir * 1;
    this.lifetime = 10;
    return this.health -= 1;
  };

  Lila = (function(superClass) {
    extend(Lila, superClass);

    function Lila() {
      return Lila.__super__.constructor.apply(this, arguments);
    }

    return Lila;

  })(Thug);

  Robo = (function(superClass) {
    extend(Robo, superClass);

    function Robo() {
      return Robo.__super__.constructor.apply(this, arguments);
    }

    return Robo;

  })(Thug);

  Lila.prototype.scampersubroutine = Robo.prototype.scampersubroutine = function() {
    if (!this.scampering && Math.random() < 1 / 10) {
      this.scampering = true;
    }
    if (this.scampering && Math.random() < 1 / 10) {
      this.scampering = false;
    }
    if (this.scampering && Math.abs(this.vel.x) < 3) {
      this.vel.x += this.facingleft ? -this.scamperspeed : this.scamperspeed;
    }
    if (!this.scampering && Math.random() < 1 / 20) {
      return this.facingleft = !this.facingleft;
    }
  };

  Lila.prototype.tick = function() {
    if (this.kisstimeout > 0) {
      this.kisstimeout--;
    }
    Lila.__super__.tick.call(this);
    if (this.kisstimeout > 50) {
      return;
    }
    this.scamperspeed = 2;
    return this.scampersubroutine();
  };

  Robo.prototype.visioncheck = function() {
    var CENTER, dim, visionarea;
    CENTER = V(1 / 2, 1 / 2);
    dim = 64 * 4;
    visionarea = makebox(this.pos, V(dim, dim), CENTER);
    if (this.angerlevel == null) {
      this.angerlevel = 0;
    }
    if (visionarea.containspoint(ladybug.pos)) {
      this.angerlevel++;
    } else if (this.angerlevel > 0) {
      this.angerlevel--;
    }
    return this.angry = this.angerlevel > 40;
  };

  Robo.prototype.tick = function() {
    var isdead;
    Robo.__super__.tick.call(this);
    isdead = this.health <= 0;
    this.state = this.scampering && this.angry ? "attacking" : "idle";
    if (isdead) {
      this.scampering = false;
      return;
    }
    this.visioncheck();
    this.scamperspeed = 1;
    if (this.angry) {
      this.scamperspeed = 6;
    }
    if (this.angry) {
      this.facingleft = ladybug.pos.x < this.pos.x;
    }
    return this.scampersubroutine();
  };

  Turret = (function(superClass) {
    extend(Turret, superClass);

    function Turret() {
      return Turret.__super__.constructor.apply(this, arguments);
    }

    return Turret;

  })(Thug);

  Turret.prototype.visioncheck = function() {
    var CENTER, dim, visionarea;
    CENTER = V(1 / 2, 1 / 2);
    dim = 64 * 4;
    visionarea = makebox(this.pos, V(dim, dim), CENTER);
    return this.angry = visionarea.containspoint(ladybug.pos);
  };

  Turret.prototype.tick = function() {
    this.visioncheck();
    if (this.angry && tickno % 10 === 0) {
      return firebullet(this);
    }
  };

  selectframe = function(framelist, framewait) {
    var framechoice, totalframes;
    totalframes = framelist.length;
    framechoice = Math.floor(tickno / framewait) % totalframes;
    return framelist[framechoice];
  };

  Lila.prototype.getsprite = function() {
    var framelist, framewait, idlecycle, scampercycle;
    idlecycle = ['lilaidle1.png', 'lilaidle2.png'];
    scampercycle = (function() {
      var results1, z;
      results1 = [];
      for (n = z = 1; z <= 4; n = ++z) {
        results1.push("lilascamper" + n + ".png");
      }
      return results1;
    })();
    framewait = 4;
    framelist = idlecycle;
    if (!this.scampering) {
      framewait = 20;
    }
    if (this.scampering) {
      framelist = scampercycle;
    }
    if (this.kisstimeout > 90) {
      framelist = ["lilakiss.png"];
    }
    return this.src = selectframe(framelist, framewait);
  };

  _cycle = function(name, range) {
    return range.map(function(n) {
      return "" + name + n + ".png";
    });
  };

  Robo.prototype.getsprite = function() {
    var framelist, framewait, idlecycle, scampercycle;
    idlecycle = ['robocalm1.png'];
    scampercycle = _cycle("robocalm", [1, 2]);
    if (this.angerlevel > 10) {
      idlecycle = _cycle("roboroll", [1, 2]);
      scampercycle = _cycle("roboroll", [1, 2]);
    }
    if (this.angry) {
      idlecycle = _cycle("roborage", [1, 2]);
      scampercycle = _cycle("roborage", [2, 3, 4]);
    }
    framelist = idlecycle;
    if (this.scampering) {
      framelist = scampercycle;
    }
    if (this.lifetime > 0) {
      this.lifetime--;
      framelist = ["robohurt.png"];
    }
    if (this.health <= 0) {
      framelist = ["robobody.png"];
    }
    if (this.health <= 0 && this.lifetime === 0 && this.touchingground()) {
      framelist = ["roboded.png"];
    }
    framewait = 4;
    return this.src = selectframe(framelist, framewait);
  };

  Robo.prototype.collide = function(otherent) {
    if (otherent instanceof Hero && this.state === "attacking") {
      return otherent.takedamage();
    }
  };

  Lila.prototype.collide = function(otherent) {
    if (otherent instanceof BoggleParticle) {
      if (!(this.kisstimeout > 0)) {
        ladybug.heal();
        WORLD.entAdd(new Smoochie(this.pos));
      }
      this.kisstimeout = 1;
    }
    if (otherent instanceof Fence) {
      this.vel.x = 0;
      offs = otherent.pos.x < this.pos.x ? 1 : -1;
      return this.pos.x += offs;
    }
  };

  Burd = (function(superClass) {
    extend(Burd, superClass);

    function Burd(pos1) {
      this.pos = pos1 != null ? pos1 : V();
      this.vel = V(0, 0);
      this.anchor = V(1 / 2, 1 / 2);
      this.src = 'burd.png';
    }

    return Burd;

  })(GenericSprite);

  Burd.prototype.tick = function() {
    var dir, lpos;
    this.getsprite();
    this.pos = this.pos.vadd(this.vel);
    lpos = ladybug.pos || V();
    dir = lpos.vsub(this.pos).norm();
    this.vel = this.vel.vadd(dir);
    if (this.vel.mag() > 10) {
      return this.vel = this.vel.norm().nmul(10);
    }
  };

  Burd.prototype.render = function() {
    var anchor, flip, pos;
    anchor = this.anchor || V(0, 0);
    flip = false;
    pos = relativetobox(this.gethitbox(), anchor);
    drawsprite(this, this.src, pos, flip, anchor);
    this._pixisprite.scale.x = 1 / 3;
    return this._pixisprite.scale.y = 1 / 3;
  };

  Burd.prototype.getsprite = function() {
    var framelist;
    framelist = ['burd.png', 'burdflap.png'];
    return this.src = mafs.randelem(framelist);
  };

  Burd.prototype.collide = function(otherent) {
    var ref1, timeout;
    if (otherent instanceof BoggleParticle) {
      this.vel = this.vel.vadd(otherent.vel.nmul(1 / 8));
    }
    timeout = (ref1 = otherent.timers) != null ? ref1.attack : void 0;
    if ((timeout != null) && timeout > 0) {
      return this.gethitby(otherent);
    }
  };

  Burd.prototype.gethitby = function(otherent) {
    var dir;
    this.vel.y += otherent.vel.y;
    dir = _facing(otherent);
    this.vel.x += dir * 4;
    return this.lifetime = 10;
  };

  BoggleParticle = (function(superClass) {
    extend(BoggleParticle, superClass);

    function BoggleParticle(pos1) {
      this.pos = pos1 != null ? pos1 : V();
      this.vel = mafs.randvec().norm();
      this.src = 'huh.png';
      this.life = 50;
      this.anchor = V(0, 0);
    }

    BoggleParticle.prototype.tick = function() {
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      this.pos = this.pos.vadd(this.vel);
      this.vel = this.vel.vadd(mafs.randvec().norm().ndiv(8));
      if (this.life <= 10) {
        return this._pixisprite.alpha = this.life / 10;
      }
    };

    return BoggleParticle;

  })(GenericSprite);

  BoggleParticle.prototype.render = function() {
    return drawsprite(this, 'emily.png', this.pos, false);
  };

  Smoochie = (function(superClass) {
    extend(Smoochie, superClass);

    function Smoochie(pos1) {
      this.pos = pos1;
      this.anchor = V(1 / 2, 1);
      this.vel = mafs.randvec().norm();
      this.src = 'kissparticle1.png';
      this.life = 50;
    }

    Smoochie.prototype.tick = function() {
      var dif, guipos;
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      guipos = cameraoffset().nadd(32);
      dif = guipos.vsub(this.pos);
      if (this.life < 10) {
        this.vel = this.vel.vadd(dif.ndiv(64));
      }
      this.pos = this.pos.vadd(this.vel);
      this.vel = this.vel.vadd(mafs.randvec().norm().ndiv(8));
      return this.vel = this.vel.vadd(V(0, -1 / 8));
    };

    Smoochie.prototype.render = function() {
      Smoochie.__super__.render.call(this);
      this.src = this.getsprite();
      return this._pixisprite.rotation = mafs.degstorads(Math.cos(this.life / 100) * 10);
    };

    return Smoochie;

  })(GenericSprite);

  Smoochie.prototype.getsprite = function() {
    var framechoice, framelist, framewait;
    framewait = 16;
    framelist = [3, 2, 1].map(function(n) {
      return "kissparticle" + n + ".png";
    });
    framechoice = Math.floor(this.life / framewait);
    return framelist[framechoice];
  };

  PchooParticle = (function(superClass) {
    extend(PchooParticle, superClass);

    function PchooParticle(pos1) {
      this.pos = pos1 != null ? pos1 : V();
      this.vel = ladybug.vel.nmul(-1).norm();
      this.life = 20;
      this.src = 'energy4.png';
      this.anchor = V(1 / 2, 1 / 2);
    }

    PchooParticle.prototype.tick = function() {
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      this.pos = this.pos.vadd(this.vel);
      return this.vel = this.vel.vadd(mafs.randvec().norm().ndiv(64));
    };

    PchooParticle.prototype.render = function() {
      drawsprite(this, this.src, this.pos, false, this.anchor);
      this._pixisprite.alpha = 0.25 + this.life / 40;
      return this._pixisprite.rotation = -Math.atan2(this.vel.x, this.vel.y);
    };

    return PchooParticle;

  })(GenericSprite);

  Bullet = (function(superClass) {
    extend(Bullet, superClass);

    function Bullet(pos1) {
      this.pos = pos1 != null ? pos1 : V();
      this.owner = void 0;
      this.vel = V(8, 0);
      this.life = 10;
      this.src = 'particlepunch.png';
      this.anchor = V(1 / 2, 1 / 2);
    }

    Bullet.prototype.tick = function() {
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      this.pos = this.pos.vadd(this.vel);
      return this.vel = this.vel.vadd(mafs.randvec().norm().ndiv(64));
    };

    Bullet.prototype.render = function() {
      var flip;
      flip = this.vel.x < 0;
      drawsprite(this, this.src, this.pos, flip, this.anchor);
      return this._pixisprite.alpha = 0.8;
    };

    return Bullet;

  })(GenericSprite);

  Shieldbubble = (function(superClass) {
    extend(Shieldbubble, superClass);

    function Shieldbubble(pos1) {
      this.pos = pos1 != null ? pos1 : V();
      this.owner = ladybug;
      this.src = 'bubble.png';
      this.anchor = V(1 / 2, 1);
      this.vel = V();
    }

    Shieldbubble.prototype.tick = function() {
      this.pos = this.owner.pos;
      if (this._pixisprite) {
        return this._pixisprite.alpha = 1 / 2;
      }
    };

    return Shieldbubble;

  })(GenericSprite);

  Bullet.prototype.collide = function(otherent) {
    if ((otherent.health != null) && otherent !== this.owner) {
      if (typeof otherent.gethitby === "function") {
        otherent.gethitby(this.owner);
      }
      return this.KILLME = true;
    }
  };

  Target.prototype.tick = function() {
    this.vel = this.vel.nmul(7 / 10);
    this.pos = this.pos.vadd(this.vel);
    if (this.lifetime === 0) {
      this.KILLME = true;
    }
    if (this.lifetime > 0) {
      this.lifetime--;
    }
    if (this.lifetime === 0 && entitycount(Target) === 1) {
      return achieve("target");
    }
  };

  isholdingkey = function(key) {
    key = key.toUpperCase().charCodeAt(0);
    return indexOf.call(control.heldkeys, key) >= 0;
  };

  isholdingbound = function(name) {
    var keys;
    keys = control.heldkeys.map(function(key) {
      return control.bindingnames[key];
    });
    return indexOf.call(keys, name) >= 0;
  };

  Hero = (function(superClass) {
    extend(Hero, superClass);

    function Hero() {
      Hero.__super__.constructor.call(this);
      this.jumping = false;
      this.attacking = false;
      this.timers = {
        attack: 0,
        stun: 0,
        mildstun: 0,
        invincible: 0
      };
      this.health = 3;
      this.energy = 0;
      this.score = 0;
      this.facingleft = false;
      this.anchor = V(1 / 2, 1);
    }

    return Hero;

  })(GenericSprite);

  BugLady = (function(superClass) {
    extend(BugLady, superClass);

    function BugLady() {
      BugLady.__super__.constructor.call(this);
      this.controls = {};
      this.controls.tapstatus = {};
    }

    return BugLady;

  })(Hero);

  BugLady.prototype.heal = function() {
    return this.health = 3;
  };

  BugLady.prototype.respawn = function() {
    this.pos = V();
    this.vel = V();
    return this.heal();
  };

  BugLady.prototype.flinch = function() {
    var knockbackDir;
    knockbackDir = this.facingleft || -1;
    this.vel.x *= 1 / 2;
    this.vel.x += knockbackDir * 8;
    this.timers.invincible = 20;
    return this.timers.flinching = 20;
  };

  Hero.prototype.gethitby = function(otherent) {
    return this.takedamage();
  };

  BugLady.prototype.takedamage = function() {
    if (this.timers.invincible > 0) {
      return;
    }
    if (this.timers.stun <= 0) {
      this.flinch();
    }
    this.health -= 1;
    if (this.health <= 0) {
      return this.kill();
    }
  };

  entcenter = function(ent) {
    var hb;
    hb = ent.gethitbox();
    return V(hb.x + hb.w / 2, hb.y + hb.h / 2);
  };

  BugLady.prototype.dmgvelocity = 20;

  BugLady.prototype.falldamage = function() {
    if (this.vel.y > this.dmgvelocity) {
      this.timers.stun = 20;
      return this.takedamage();
    }
  };

  GenericSprite.prototype.blockcollisions = function() {
    var box, candidates;
    box = this.gethitbox();
    candidates = hitboxfilter(box, WORLD.bglayer);
    candidates.forEach((function(_this) {
      return function(candidate) {
        if (_this.gethitbox().bottom() >= candidate.top()) {
          if (typeof _this.falldamage === "function") {
            _this.falldamage();
          }
          _this.pos.y = candidate.y;
          return _this.vel.y = 0;
        }
      };
    })(this));
    if (candidates.length > 0 && this.vel.y < 0) {
      return this.vel.y = 0;
    }
  };

  BugLady.prototype.blockcollisions = function() {
    var box, candidates, platforms;
    box = this.fallbox();
    platforms = hitboxfilter(box, WORLD.BOXCACHE);
    if (platforms.length > 0) {
      WARN("stuck in wall");
      this.pos.y -= 2;
    }
    candidates = hitboxfilter(box, WORLD.bglayer);
    return candidates.forEach((function(_this) {
      return function(candidate) {
        var jumpthroughable;
        if (_this.gethitbox().bottom() <= candidate.top()) {
          _this.pos.y = candidate.y;
          _this.vel.y = 0;
          if ((!_this.timers.fightstance) && !_this.timers.mildstun) {
            _this.timers.mildstun = 4;
          }
        }
        jumpthroughable = candidate instanceof OnewayBlock;
        if (_this.vel.y < 0 && !jumpthroughable && box.top() > candidate.top()) {
          _this.vel.y = 0;
          _.invoke(candidates, 'bonk');
          return console.log("bonk");
        }
      };
    })(this));
  };

  closestpoint = function(p, pointarr) {
    var closest, len1, point, z;
    closest = pointarr[0];
    for (z = 0, len1 = pointarr.length; z < len1; z++) {
      point = pointarr[z];
      if (closest.dist(p) > point.dist(p)) {
        closest = point;
      }
    }
    return closest;
  };

  BugLady.prototype.polygoncollisions = function() {
    var allpolygons;
    stats.collisionchecks++;
    allpolygons = WORLD.spritelayer.filter(function(sprit) {
      return sprit instanceof Poly;
    });
    return allpolygons.forEach((function(_this) {
      return function(candidate) {
        var closest, edges, hits, p, trajectory;
        p = new V2d(_this.pos.x, _this.pos.y);
        trajectory = new Line2d(_this.pos, _this.pos.vadd(_this.vel));
        edges = pointlisttoedges(candidate.points);
        hits = edges.map(function(edg) {
          return trajectory.lineintersect(edg);
        });
        hits = _.compact(hits);
        if (hits.length > 0) {
          closest = closestpoint(p, hits);
          _this.pos = closest.vsub(_this.vel.norm());
          _this.vel.y = 0;
        }
        if (geometry.pointInsidePoly(p, candidate.points)) {
          return _this.vel.y--;
        }
      };
    })(this));
  };

  Hero.prototype.checkcontrols = function() {};

  BugLady.prototype.checkcontrols = function() {
    if (this !== ladybug) {
      return;
    }
    this.holdingboggle = isholdingbound('boggle');
    this.holdingjump = isholdingbound('jump');
    if (!this.holdingjump) {
      this.controls.tapstatus.jump = true;
    }
    return this.controls.crouch = isholdingbound('down');
  };

  BugLady.prototype.cancelattack = function() {
    this.timers.attack = 0;
    return this.attacking = false;
  };

  Hero.prototype.outofbounds = function() {
    return this.pos.y > 6400;
  };

  BugLady.prototype.kill = function() {
    return this.respawn();
  };

  BugLady.prototype.timeoutcheck = function() {
    var k, ref1, v;
    ref1 = this.timers;
    for (k in ref1) {
      v = ref1[k];
      if (v > 0) {
        this.timers[k]--;
      }
    }
    if (this.timers.powerup > 0) {
      this.vel = V2d.zero();
    }
    if (this.timers.stun > 0) {
      achieve("fall");
      this.vel = V2d.zero();
    }
    if (this.timers.invincible === 0 && this.shield) {
      this.shield.KILLME = true;
      return this.shield = null;
    }
  };

  BugLady.prototype.attackchecks = function() {
    var dashing, down, forward, heading, nent, up;
    this.attacking = this.timers.attack > 0;
    heading = _facing(this);
    dashing = Math.abs(this.vel.x) > 11;
    if (this.attacking && dashing) {
      this.vel.x *= 1 / 2;
      this.timers.uppercut = 10;
    }
    forward = isholdingbound('left') || isholdingbound('right');
    up = isholdingbound('up');
    down = isholdingbound('down');
    if (this.attacking && up) {
      this.vel.x *= 1 / 2;
      this.timers.uppercut = 10;
    }
    if (this.attacking && this.kicking && down) {
      this.timers.slide = 10;
      this.vel = V(heading * 10, 0);
    }
    if (this.attacking && this.kicking && forward) {
      this.vel = V(heading * 10, 0);
    }
    if (this.attacking && this.kicking && up && !this.timers.roundhouse) {
      this.timers.roundhouse = 20;
    }
    if (this.attacking && this.punching) {
      if (entitycount(Bullet) < 3 && this.energy > 0) {
        this.energy -= 0.1;
        firebullet(this);
      }
    }
    if (this.attacking && !this.timers.hitboxery) {
      this.timers.hitboxery = 10;
      nent = new Damagebox(this);
      return WORLD.entAdd(nent);
    }
  };

  Damagebox = (function(superClass) {
    extend(Damagebox, superClass);

    function Damagebox(owner) {
      this.owner = owner;
      this.pos = this.owner.pos;
      this.life = 15;
      this.anchor = V(0.5, 2);
      this.size = V(64, 16);
    }

    Damagebox.prototype.tick = function() {
      if (this.life-- <= 0) {
        return this.KILLME = true;
      }
    };

    Damagebox.prototype.gethitbox = GenericSprite.prototype.gethitbox;

    return Damagebox;

  })(Renderable);

  firebullet = function(ent) {
    var CENTER, bullet, heading;
    heading = _facing(ent);
    bullet = new Bullet();
    bullet.owner = ent;
    bullet.vel = V(heading * 32, 0);
    bullet.life = 2;
    CENTER = V(1 / 2, 1 / 2);
    bullet.pos = relativetobox(ent.gethitbox(), CENTER);
    WORLD.entAdd(bullet);
    return bullet;
  };

  get_sprites_of_class = function(classtype) {
    var ents;
    return ents = WORLD.spritelayer.filter(function(sprite) {
      return sprite instanceof classtype;
    });
  };

  BugLady.prototype.submerged = function() {
    var blockcandidates, collidebox, waterblocks;
    waterblocks = get_sprites_of_class(Water);
    collidebox = this.gethitbox();
    blockcandidates = hitboxfilter(collidebox, waterblocks);
    if (blockcandidates.length > 0) {
      return true;
    }
    return false;
  };

  BugLady.prototype.waterdrag = function() {
    this.vel.y = this.vel.y * 0.8;
    return this.vel.x = this.vel.x * 0.95;
  };

  BugLady.prototype.tick = function() {
    var boggling, unpowered, vel, walking;
    this.energy += 0.001;
    if (this.getsprite() === "bugdash.png") {
      WORLD.entAdd(new PchooParticle(entcenter(this)));
    }
    if (this.submerged()) {
      this.waterdrag();
    }
    unpowered = settings.altcostume;
    if (unpowered) {
      this.cancelattack();
    }
    this.checkcontrols();
    if (this.outofbounds()) {
      this.kill();
    }
    vel = Math.abs(this.vel.x);
    walking = vel > 0.2;
    boggling = !walking && this.touchingground() && this.holdingboggle;
    if (boggling && Math.random() < 0.3) {
      this.boggle();
    }
    this.timeoutcheck();
    return this.movetick();
  };

  BugLady.prototype.limitvelocity = function() {
    var vellimit;
    vellimit = 800;
    return this.vel.x = mafs.clamp(this.vel.x, -vellimit, vellimit);
  };

  BugLady.prototype.gravitate = function() {
    if (!this.touchingground() && !this.touchingwall()) {
      this.vel.y += 1;
      if (this.timers.fightstance) {
        this.vel.y += 1;
      }
      if (settings.variablejump) {
        if (!this.holdingjump && this.vel.y < 0) {
          return this.vel.y /= 2;
        }
      }
    }
  };

  BugLady.prototype.canhurdle = function() {
    var b_cansqueezein, b_hitsomething, box, candidates;
    if (!isholdingbound('cling')) {
      return;
    }
    box = this.fallbox();
    box.x += this.facingleft ? -2 : 2;
    candidates = hitboxfilter(box, WORLD.bglayer);
    b_hitsomething = candidates.length > 0;
    box.y -= 4;
    candidates = hitboxfilter(box, WORLD.bglayer);
    b_cansqueezein = candidates.length > 0;
    return b_hitsomething && b_cansqueezein;
  };

  BugLady.prototype.hurdlecheck = function() {
    if (this.canhurdle()) {
      return this.vel.y -= 2;
    }
  };

  GenericSprite.prototype.physmove = function() {
    this.blockcollisions();
    this.avoidwalls();
    if (this.vel.y > 0 && this.touchingground()) {
      this.vel.y = 0;
    }
    this.pos = this.pos.vadd(this.vel);
    this.gravitate();
    if (this.touchingground() && !this.touchingice()) {
      return this.friction();
    }
  };

  BugLady.prototype.physmove = function() {
    var pressingwalk;
    this.hurdlecheck();
    this.limitvelocity();
    this.blockcollisions();
    this.polygoncollisions();
    this.avoidwalls();
    if (this.vel.y > 0 && this.touchingground()) {
      this.vel.y = 0;
    }
    if (this.timers.mildstun <= 2) {
      this.pos = this.pos.vadd(this.vel);
    }
    if (!this.timers.hover) {
      this.gravitate();
    }
    pressingwalk = isholdingbound('left') || isholdingbound('right');
    if (this.touchingground() && !this.touchingice()) {
      this.friction();
      if (!pressingwalk) {
        this.friction();
      }
    }
    if (this.touchingspritename("redtile.png")) {
      return this.vel.y -= 8;
    }
  };

  BugLady.prototype.smashblock = function() {
    var block, blockcandidates, collidebox, len1, results1, z;
    collidebox = this.gethitbox();
    blockcandidates = hitboxfilter(collidebox, WORLD.bglayer);
    results1 = [];
    for (z = 0, len1 = blockcandidates.length; z < len1; z++) {
      block = blockcandidates[z];
      if (block.src !== "genblackrocks.png") {
        continue;
      }
      WORLD.bglayer = _.without(WORLD.bglayer, block);
      results1.push(block.removesprite());
    }
    return results1;
  };

  BugLady.prototype.movetick = function() {
    var jumpvel, unpowered;
    unpowered = settings.altcostume;
    this.physmove();
    this.attackchecks();
    jumpvel = unpowered ? 11 : 13;
    this.jumpimpulse(jumpvel);
    if (this.vel.y > 1 && this.controls.crouch && this.timers.charge) {
      ladybug.timers.charge = 0;
      this.state = 'headfirst';
      this.vel.y += 0.1;
    }
    if (this.touchingground() && this.state === 'headfirst') {
      this.smashblock();
      this.state = '';
      this.timers.stun = 20;
    }
    if (this.state === 'headfirst') {
      this.vel.y += 2;
      this.vel.x *= 0.9;
    }
    this.jumping = false;
    return this.climbing = this.canhurdle();
  };

  BugLady.prototype.jumpimpulse = function(jumpvel) {
    var doublejumplegal, jumplegal, unpowered;
    unpowered = settings.altcostume;
    if (this.touchingground()) {
      this.spentdoublejump = false;
      this.timers.jumpgraceperiod = 4;
      if (settings.moonjump) {
        this.timers.jumpgraceperiod = 100;
      }
    }
    jumplegal = this.touchingground() || this.submerged() || this.timers.jumpgraceperiod > 0;
    jumplegal = jumplegal && this.controls.tapstatus.jump;
    doublejumplegal = !unpowered && settings.airjump && this.energy > 0;
    doublejumplegal = doublejumplegal && this.controls.tapstatus.jump;
    if (this.spentdoublejump) {
      doublejumplegal = false;
    }
    if (this.jumping && doublejumplegal && !jumplegal) {
      this.spentdoublejump = true;
      this.energy--;
    }
    if (this.jumping && (jumplegal || doublejumplegal)) {
      this.controls.tapstatus.jump = false;
      this.vel.y = -jumpvel;
    }
    if (this.spentdoublejump && this.vel.y < 0) {
      return WORLD.entAdd(new PchooParticle(entcenter(this)));
    }
  };

  GenericSprite.prototype.OLD_friction = function() {
    return this.vel.x = this.vel.x * 0.9;
  };

  GenericSprite.prototype.friction = function() {
    var sign, x;
    x = this.vel.x;
    sign = Math.sign(x);
    x -= sign / 2;
    if (Math.abs(x) < 1 / 2) {
      x = 0;
    }
    return this.vel.x = x;
  };

  BugLady.prototype.boggle = function() {
    var boxes, bushes, cand, hit;
    WORLD.entAdd(new BoggleParticle(entcenter(this)));
    hit = ladybug.gethitbox();
    bushes = get_sprites_of_class(Shrub);
    boxes = bushes.map(function(obj) {
      return obj.gethitbox();
    });
    cand = hitboxfilter(hit, boxes);
    if (cand.length > 0) {
      achieve("boggle");
    }
    return this.energy++;
  };

  BugLady.prototype.getsprite = function() {
    var running, src, vel, walking;
    if (settings.beanmode) {
      return "bugbean.png";
    }
    src = "lovelyshorter";
    vel = Math.abs(this.vel.x);
    walking = vel > 0.2;
    running = vel > 5;
    if (walking) {
      src = selectframe(['lovelyrun1', 'lovelyrun2'], 6);
    }
    if (running) {
      src = selectframe(['lovelyrun1', 'lovelyrun2'], 2);
    }
    if (!this.touchingground()) {
      src = this.vel.y < 0 ? 'lovelyjump' : 'lovelycrouch';
    }
    if (this.timers.fightstance > 0) {
      src = "bugstance";
    }
    if (!walking) {
      if (this.controls.crouch) {
        src = 'lovelycrouch';
      }
      if (isholdingbound('up')) {
        src = 'bugstance';
      }
      if (this.touchingground() && this.holdingboggle) {
        src = 'boggle';
      }
    }
    if (this.attacking) {
      src = 'viewtiful';
      if (this.punching) {
        src = 'bugpunch';
        if (this.timers.uppercut) {
          src = 'buguppercut';
        }
      }
      if (this.timers.attack < 2 && this.punching) {
        src = 'lovelyrun2';
      }
      if (this.kicking) {
        src = 'bugkick';
        if (this.timers.slide) {
          src = 'lovelyfall';
        }
        if (this.timers.roundhouse) {
          src = 'lb_roundhouse';
        }
        if (this.timers.roundhouse >= 15) {
          src = 'bugkick';
        }
      }
    }
    if (this.timers.stun > 0) {
      src = 'lovelycrouch';
    }
    if (this.timers.mildstun > 2) {
      src = 'lovelycrouch';
    }
    if (this.timers.stun > 4) {
      src = 'bugbonk';
    }
    if (this.timers.powerup > 0) {
      src = 'viewtiful';
    }
    if (this.timers.powerup > 16) {
      src = 'boggle';
      this.facingleft = this.timers.powerup % 10 < 5;
    }
    if (vel > 11) {
      src = "bugdash";
    }
    if (this.timers.powerup > 32) {
      src = 'marl/boggle';
    }
    if (this.lastfacing !== this.facingleft) {
      this.timers.turn = 4;
      this.lastfacing = this.facingleft;
    }
    if (this.timers.turn > 0) {
      src = 'lovelycrouch';
    }
    if (settings.altcostume) {
      src = "marl/" + src;
    }
    if (this.climbing) {
      src = 'bugledge';
      if (settings.altcostume) {
        src = 'marl/boggle';
      }
    }
    if (this.state === 'headfirst') {
      src = 'bugdrop';
    }
    if (this.timers.flinching > 10 && this.touchingground()) {
      src = "bugflinch";
    }
    if (this.timers.flinching > 15) {
      src = "bugdmg";
    }
    if (this.timers.flinching > 0 && !this.touchingground()) {
      src = "bugdmg2";
    }
    return src + ".png";
  };

  Claire = (function(superClass) {
    extend(Claire, superClass);

    function Claire() {
      return Claire.__super__.constructor.apply(this, arguments);
    }

    return Claire;

  })(BugLady);

  Claire.prototype.getsprite = function() {
    if (settings.skathi) {
      return "skathi.png";
    }
    return "orcbabb.png";
  };

  Wisp = (function(superClass) {
    extend(Wisp, superClass);

    function Wisp() {
      return Wisp.__super__.constructor.apply(this, arguments);
    }

    return Wisp;

  })(BugLady);

  Wisp.prototype.getsprite = function() {
    return "wisp.png";
  };

  Wisp.prototype.gravitate = function() {};

  Wisp.prototype.tick = function() {
    var damping;
    if (isholdingbound('up')) {
      this.vel.y--;
    }
    if (isholdingbound('down')) {
      this.vel.y++;
    }
    if (isholdingbound('left')) {
      this.vel.x--;
    }
    if (isholdingbound('right')) {
      this.vel.x++;
    }
    this.pos = this.pos.vadd(this.vel);
    damping = 0.95;
    return this.vel = this.vel.nmul(damping);
  };

  BugLady.prototype.flickershield = function() {
    if (this.timers.invincible < 32 && this.shield) {
      this.shield._pixisprite.alpha = 0.5 * b2n(tickno % 8 !== 0);
    }
    if (this.timers.invincible < 10 && this.shield) {
      return this.shield._pixisprite.alpha = 0.5 * (tickno % 2);
    }
  };

  BugLady.prototype.render = function() {
    var flip, pos, sprit, src, vel, walking;
    vel = Math.abs(this.vel.x);
    walking = vel > 1;
    src = this.getsprite();
    flip = this.facingleft;
    if (settings.beanmode && walking) {
      flip = tickno % 8 < 4;
    }
    pos = relativetobox(this.gethitbox(), this.anchor);
    sprit = drawsprite(this, src, pos, flip, this.anchor);
    if (src === 'boggle.png') {
      sprit.rotation = mafs.degstorads(mafs.randfloat() * 4);
    } else {
      sprit.rotation = 0;
    }
    if (this.timers.stun) {
      sprit.alpha = tickno % 2;
    } else {
      sprit.alpha = 1;
    }
    return this.flickershield();
  };

  stageremovesprite = function(stage, ent) {
    if (ent._pixisprite == null) {
      return;
    }
    stage.removeChild(ent._pixisprite);
    return ent._pixisprite = void 0;
  };

  removesprite = function(ent) {
    WARN("deprecated");
    return stageremovesprite(stage, ent);
  };

  initsprite = function(ent, tex) {
    var sprit;
    sprit = new PIXI.Sprite(tex);
    ent._pixisprite = sprit;
    stage.addChild(sprit);
    return sprit;
  };

  drawsprite = function(ent, src, pos, flip, anchor) {
    var sprit;
    if (anchor == null) {
      anchor = V();
    }
    tex = TEXBYNAME(src);
    if (!ent._pixisprite) {
      initsprite(ent, tex);
    }
    sprit = ent._pixisprite;
    sprit.position = VTOPP(pos);
    sprit.anchor = VTOPP(anchor);
    sprit.texture = tex;
    sprit.scale.x = flip ? -1 : 1;
    return sprit;
  };

  Poly = (function(superClass) {
    extend(Poly, superClass);

    function Poly(points) {
      this.points = points != null ? points : [];
      this.pos = V();
    }

    return Poly;

  })(Renderable);

  Poly.prototype.initsprite = function() {
    var firstpoint, sprit;
    sprit = new PIXI.Graphics();
    sprit.beginFill(0xcc0000);
    sprit.lineStyle(1, 0x000000);
    firstpoint = this.points[0];
    this.points.forEach(function(point) {
      return sprit.lineTo(point.x, point.y);
    });
    sprit.lineTo(firstpoint.x, firstpoint.y);
    sprit.endFill();
    this._pixisprite = sprit;
    return stage.addChild(sprit);
  };

  Poly.prototype.render = function() {
    if (!this.hassprite()) {
      return this.initsprite();
    }
  };

  Poly.prototype.boundingbox = function() {
    var b, l, max, min, r, t, xs, ys;
    xs = this.points.map(function(pt) {
      return pt.x;
    });
    ys = this.points.map(function(pt) {
      return pt.y;
    });
    min = function(a, b) {
      return Math.min(a, b);
    };
    max = function(a, b) {
      return Math.max(a, b);
    };
    l = Math.round(xs.reduce(min));
    r = Math.round(xs.reduce(max));
    t = Math.round(ys.reduce(min));
    b = Math.round(ys.reduce(max));
    return makebox(V(l, t), V(r - l, b - t), V(0, 0));
  };

  Poly.prototype.gethitbox = function() {
    return this.boundingbox();
  };

  Rect = (function() {
    function Rect(x5, y5, w1, h1) {
      this.x = x5;
      this.y = y5;
      this.w = w1;
      this.h = h1;
    }

    return Rect;

  })();

  _Rectmethods = {
    containspoint: function(p) {
      return this.x <= p.x && this.y <= p.y && this.x + this.w >= p.x && this.y + this.h >= p.y;
    }
  };

  Block = (function(superClass) {
    extend(Block, superClass);

    function Block(x5, y5, w1, h1) {
      this.x = x5;
      this.y = y5;
      this.w = w1;
      this.h = h1;
      this.pos = V(this.x, this.y);
      this.timers = {};
      this.tile = 0;
    }

    return Block;

  })(Renderable);

  _.extend(Rect.prototype, _Rectmethods);

  _.extend(Block.prototype, _Rectmethods);

  Block.prototype.intersection = function(rectb) {
    var b, h, l, r, recta, t, w;
    recta = this;
    l = Math.max(recta.left(), rectb.left());
    t = Math.max(recta.top(), rectb.top());
    r = Math.min(recta.right(), rectb.right());
    b = Math.min(recta.bottom(), rectb.bottom());
    w = r - l;
    h = b - t;
    return new Block(l, t, w, h);
  };

  Block.prototype.strictoverlaps = function(rectb) {
    var recta;
    recta = this;
    if (recta.left() >= rectb.right() || recta.top() >= rectb.bottom() || recta.right() <= rectb.left() || recta.bottom() <= rectb.top()) {
      return false;
    } else {
      return true;
    }
  };

  Block.prototype.overlaps = function(rectb) {
    var recta;
    recta = this;
    if (recta.left() > rectb.right() || recta.top() > rectb.bottom() || recta.right() < rectb.left() || recta.bottom() < rectb.top()) {
      return false;
    } else {
      return true;
    }
  };

  Block.prototype.bonk = function() {
    return this.timers.bonk = 6;
  };

  Block.prototype.tostone = function() {
    return DEPRECATE();
  };

  Block.prototype.fixnegative = function() {
    if (this.w < 0) {
      this.x += this.w;
      this.w *= -1;
    }
    if (this.h < 0) {
      this.y += this.h;
      this.h *= -1;
    }
    this.pos = V(this.x, this.y);
    return this.removesprite();
  };

  hitboxfilter_OLD = function(hitbox, rectarray) {
    return rectarray.filter(function(box) {
      return hitbox.overlaps(box);
    });
  };

  hitboxfilter = function(hitbox, rectarray) {
    var res;
    stats.collisionchecks += rectarray.length;
    res = hitboxfilter_OLD(hitbox, rectarray);
    return res;
  };

  makebox = function(position, dimensions, anchor) {
    var truepos;
    truepos = position.vsub(dimensions.vmul(anchor));
    return new Block(truepos.x, truepos.y, dimensions.x, dimensions.y);
  };

  bottomcenter = V(1 / 2, 1);

  BugLady.prototype.anchor = bottomcenter;

  BugLady.prototype.size = V(16, 32 + 16);

  GenericSprite.prototype.fallbox = function() {
    var box;
    box = this.gethitbox();
    box.w += Math.abs(this.vel.x);
    box.h += Math.abs(this.vel.y);
    if (this.vel.x < 0) {
      box.x += this.vel.x;
    }
    if (this.vel.y < 0) {
      box.y += this.vel.y;
    }
    box.h -= 2;
    return box;
  };

  leftof = function(box) {
    return box.x;
  };

  rightof = function(box) {
    return box.x + box.w;
  };

  bottomof = function(box) {
    return box.y + box.h;
  };

  topof = function(box) {
    return box.y;
  };

  Block.prototype.left = function() {
    return leftof(this);
  };

  Block.prototype.right = function() {
    return rightof(this);
  };

  Block.prototype.bottom = function() {
    return bottomof(this);
  };

  Block.prototype.top = function() {
    return topof(this);
  };

  Block.prototype.issamebox = function(b) {
    return this.x === b.x && this.y === b.y && this.w === b.w && this.h === b.h;
  };

  blocksatpoint = function(blocks, p) {
    return blocks.filter(function(box) {
      return box.containspoint(p);
    });
  };

  boxtouchingwall = function(collidebox) {
    var block, blockcandidates, len1, notontop, z;
    blockcandidates = hitboxfilter(collidebox, WORLD.bglayer);
    for (z = 0, len1 = blockcandidates.length; z < len1; z++) {
      block = blockcandidates[z];
      notontop = collidebox.bottom() > block.top();
      if (notontop && collidebox.left() < block.left()) {
        return true;
      }
      if (notontop && collidebox.right() > block.right()) {
        return true;
      }
    }
    return false;
  };

  GenericSprite.prototype.touchingwall = function() {
    var collidebox;
    collidebox = this.gethitbox();
    return boxtouchingwall(collidebox);
  };

  GenericSprite.prototype.avoidwalls = function() {
    var actualbox, block, blockcandidates, collidebox, jumpthroughable, len1, notontop, results1, z;
    actualbox = this.gethitbox();
    collidebox = this.fallbox();
    blockcandidates = hitboxfilter(collidebox, WORLD.bglayer);
    results1 = [];
    for (z = 0, len1 = blockcandidates.length; z < len1; z++) {
      block = blockcandidates[z];
      jumpthroughable = block instanceof OnewayBlock;
      if (jumpthroughable) {
        continue;
      }
      notontop = actualbox.bottom() > block.top();
      if (boxtouchingwall(collidebox)) {
        if (typeof this.hitwall === "function") {
          this.hitwall();
        }
        results1.push(this.vel.x = 0);
      } else {
        results1.push(void 0);
      }

      /*
      ofs=1
      if notontop and collidebox.left() <= block.left()
        @pos.x-=ofs
      if notontop and rightof(collidebox) >= rightof(block)
        @pos.x+=ofs
       */
    }
    return results1;
  };

  BugLady.prototype.hitwall = function() {
    if (Math.abs(this.vel.x) > 11) {
      return this.timers.invincible = 10;
    }
  };

  GenericSprite.prototype.touchingground = function() {
    var allpolygons, block, blockcandidates, box, collidebox, fromgrid, len1, otherboxes, touch, z;
    touch = false;
    collidebox = this.gethitbox();
    fromgrid = WORLD.collgrid.get(collidebox, this);
    otherboxes = [].concat(fromgrid, WORLD.bglayer);
    otherboxes = otherboxes.filter(function(b) {
      return !b.issamebox(collidebox);
    });
    blockcandidates = hitboxfilter(collidebox, otherboxes);
    for (z = 0, len1 = blockcandidates.length; z < len1; z++) {
      block = blockcandidates[z];
      if (collidebox.bottom() <= block.bottom()) {
        touch = true;
      }
    }
    allpolygons = WORLD.spritelayer.filter(function(sprit) {
      return sprit instanceof Poly;
    });
    box = this.gethitbox();
    box.y += 1;
    allpolygons.forEach((function(_this) {
      return function(candidate) {
        var p;
        p = new V2d(_this.pos.x, _this.pos.y + 1);
        if (geometry.pointInsidePoly(p, candidate.points)) {
          return touch = true;
        }
      };
    })(this));
    return touch;
  };

  GenericSprite.prototype.touchingspritename = function(spritename) {
    var allpolygons, block, blockcandidates, box, cands, collidebox, len1, touch, z;
    touch = false;
    collidebox = this.gethitbox();
    cands = WORLD.bglayer.filter(function(cand) {
      return cand.src === spritename;
    });
    blockcandidates = hitboxfilter(collidebox, cands);
    for (z = 0, len1 = blockcandidates.length; z < len1; z++) {
      block = blockcandidates[z];
      if (collidebox.bottom() <= block.bottom()) {
        touch = true;
      }
    }
    allpolygons = WORLD.spritelayer.filter(function(sprit) {
      return sprit instanceof Poly;
    });
    box = this.gethitbox();
    box.y += 1;
    allpolygons.forEach((function(_this) {
      return function(candidate) {
        var p;
        p = new V2d(_this.pos.x, _this.pos.y + 1);
        if (geometry.pointInsidePoly(p, candidate.points)) {
          return touch = true;
        }
      };
    })(this));
    return touch;
  };

  GenericSprite.prototype.touchingice = function() {
    return this.touchingspritename("genice.png");
  };

  PowerSuit = (function(superClass) {
    extend(PowerSuit, superClass);

    function PowerSuit(pos1) {
      this.pos = pos1;
      PowerSuit.__super__.constructor.call(this, this.pos, 'suit.png');
    }

    return PowerSuit;

  })(GenericSprite);

  PowerSuit.prototype.anchor = V(1 / 2, 1);

  PowerSuit.prototype.collide = function(otherent) {
    if (otherent instanceof BugLady) {
      this.KILLME = true;
      otherent.timers.powerup = 45;
      settings.altcostume = false;
      return achieve("suit");
    }
  };

  ControlObj = (function() {
    function ControlObj() {
      this.bindings = {};
      this.holdbindings = {};
      this.heldkeys = [];
      this.bindingnames = {};
    }

    return ControlObj;

  })();

  control = new ControlObj;

  this.control = control;

  normalizekey = function(key) {
    return key.toUpperCase().charCodeAt(0);
  };

  ControlObj.prototype.keytapbindraw = function(key, func) {
    return this.bindings[key] = func;
  };

  ControlObj.prototype.keytapbind = function(key, func) {
    return this.bindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keytapbind = function(key, func) {
    return this.bindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keytapbindname = function(key, name, func) {
    this.bindingnames[normalizekey(key)] = name;
    return this.keytapbind(key, func);
  };

  ControlObj.prototype.keyBindRawNamed = function(key, name, func) {
    this.bindingnames[key] = name;
    return this.keytapbindraw(key, func);
  };

  ControlObj.prototype.keyBindCharNamed = function(key, name, fnc) {
    return this.keyBindRawNamed(keyCharToCode[key], name, fnc);
  };

  ControlObj.prototype.keyholdbind = function(key, func) {
    return this.holdbindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keyholdbindname = function(key, name, func) {
    this.bindingnames[normalizekey(key)] = name;
    return this.holdbindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keyHoldBindRawNamed = function(key, name, func) {
    this.bindingnames[key] = name;
    return this.holdbindings[key] = func;
  };

  if (settings.devmode) {
    control.keytapbindname('9', 'zoom out', function() {
      return camera.zoomout();
    });
    control.keytapbindname('0', 'zoom in', function() {
      return camera.zoomin();
    });
  }

  _doc = document;

  launchFullScreen = function(elm) {
    if (typeof elm.requestFullScreen === "function") {
      elm.requestFullScreen();
    }
    if (typeof elm.mozRequestFullScreen === "function") {
      elm.mozRequestFullScreen();
    }
    return typeof elm.webkitRequestFullScreen === "function" ? elm.webkitRequestFullScreen() : void 0;
  };

  cancelFullScreen = function(elm) {
    if (typeof _doc.cancelFullScreen === "function") {
      _doc.cancelFullScreen();
    }
    if (typeof _doc.mozCancelFullScreen === "function") {
      _doc.mozCancelFullScreen();
    }
    return typeof _doc.webkitCancelFullScreen === "function" ? _doc.webkitCancelFullScreen() : void 0;
  };

  isfullscreen = function() {
    return _doc.fullscreenElement || _doc.mozFullscreenElement || _doc.webkitFullscreenElement;
  };

  _toggleFullScreen = function(elm) {
    if (isfullscreen()) {
      return cancelFullScreen(elm);
    } else {
      return launchFullScreen(elm);
    }
  };

  toggleFullScreen = function(elm) {
    var ref1, ref2, ref3, x, y;
    _toggleFullScreen(elm);
    ref1 = [0, 0], x = ref1[0], y = ref1[1];
    if (isfullscreen()) {
      ref2 = [screen.width, screen.height], x = ref2[0], y = ref2[1];
    } else {
      ref3 = [screensize_default.x, screensize_default.y], x = ref3[0], y = ref3[1];
    }
    renderer.resize(x, y);
    return screensize = V(x, y);
  };

  control.keytapbindname('y', 'toggle fullscreen', function() {
    return toggleFullScreen(renderer.view);
  });

  pausefunc = function() {
    playsound("pause.wav");
    settings.paused = !settings.paused;
    if (settings.paused) {
      playsound("gimmebreak.ogg", 1);
    } else {
      playsound("gameon.ogg", 1);
    }
    if (settings.paused) {
      parentstage.addChild(pausescreen);
    }
    if (!settings.paused) {
      return parentstage.removeChild(pausescreen);
    }
  };

  control.keytapbindname('p', 'pause', pausefunc);

  control.keyBindCharNamed('Pause/Break', 'pause', pausefunc);

  control.keyBindCharNamed('Enter', 'pause', function() {
    var key;
    key = keyCharToCode["Alt"];
    if (indexOf.call(control.heldkeys, key) >= 0) {
      return toggleFullScreen(renderer.view);
    } else {
      return pausefunc();
    }
  });

  control.keyBindCharNamed('Esc', 'pause', pausefunc);

  if (settings.devmode) {
    control.keytapbindname('t', 'underclock/slowmo', function() {
      return settings.slowmo = !settings.slowmo;
    });
    control.keytapbindname('g', 'toggle grid', function() {
      return settings.grid = !settings.grid;
    });
  }

  ghostbusters = function() {
    var spooky_ghosts;
    spooky_ghosts = get_sprites_of_class(Wisp);
    spooky_ghosts.forEach(function(spoop) {
      return spoop.KILLME = true;
    });
    return camera.trackingent = ladybug;
  };

  if (settings.devmode) {
    control.keytapbindname('h', 'ghost mode', function() {
      var ghost, somethingstrange;
      somethingstrange = entitycount(Wisp) > 0;
      if (somethingstrange) {
        return call(ghostbusters);
      } else {
        ghost = new Wisp();
        ghost.pos = ladybug.pos;
        camera.trackingent = ghost;
        return WORLD.entAdd(ghost);
      }
    });
  }

  control.keytapbindname('l', 'WHAM!', function() {
    ladybug.kicking = false;
    return ladybug.punching = false;
  });

  control.keyholdbind('l', function() {
    return ladybug.timers.attack = 10;
  });

  BugLady.prototype.dirfaced = function() {
    if (this.facingleft) {
      return -1;
    } else {
      return 1;
    }
  };

  _facing = function(ent) {
    if (ent.facingleft) {
      return -1;
    } else {
      return 1;
    }
  };

  BugLady.prototype.impPunch = function() {
    this.punching = true;
    this.kicking = false;
    this.timers.attack = 10;
    playsound("hit.wav");
    return this.vel.x += this.dirfaced() * 2;
  };

  BugLady.prototype.impKick = function() {
    this.kicking = true;
    this.vel.y -= 4;
    this.punching = false;
    this.timers.attack = 10;
    playsound("hit.wav");
    return this.vel.x += this.dirfaced() * 2;
  };

  punch = function() {
    return ladybug.impPunch();
  };

  kick = function() {
    return ladybug.impKick();
  };

  control.keytapbindname('e', 'charge suit', function() {
    if (settings.altcostume) {
      return;
    }
    if (ladybug.energy < 1) {
      return;
    }
    ladybug.energy--;
    return ladybug.timers.charge = 10;
  });

  control.keyholdbindname('i', 'guard', function() {
    var sb;
    if (ladybug.timers.charge) {
      ladybug.timers.charge = 0;
      ladybug.timers.invincible = 60;
      sb = new Shieldbubble();
      sb.pos = ladybug.pos;
      WORLD.entAdd(sb);
      ladybug.shield = sb;
    }
    return ladybug.timers.fightstance = 4;
  });

  control.keytapbindname('j', 'POW!', punch);

  control.keytapbindname('k', 'BAM!', kick);

  control.keytapbindname('m', 'mute', function() {
    return settings.muted = !settings.muted;
  });

  up = function() {
    if (ladybug.timers.charge) {
      ladybug.timers.charge = 0;
      ladybug.jumping = true;
      return ladybug.vel.y -= 20;
    }
  };

  jump = function() {
    if (ladybug.touchingground()) {
      playsound("jump.wav");
    }
    return ladybug.jumping = true;
  };

  down = function() {};

  bugspeed = function() {
    return 1;
  };

  MAXBUGSPEED = 10;

  _particle = function() {
    var pcho;
    pcho = new PchooParticle(entcenter(ladybug));
    pcho.vel = mafs.randvec().nmul(2);
    return WORLD.entAdd(pcho);
  };

  bugthrust = function(vel) {
    ladybug.vel.x = vel;
    ladybug.vel.y = 0;
    ladybug.timers.hover = 8;
    return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].forEach(_particle);
  };

  _sidestep = function(dir) {
    if (ladybug.touchingground()) {
      ladybug.vel.x = dir * 8;
      return ladybug.vel.y -= 4;
    }
  };

  _dash = function(dir) {
    if (!ladybug.timers.charge) {
      return;
    }
    ladybug.timers.charge = 0;
    return bugthrust(dir * 20);
  };

  _move = function(dir) {
    var vx;
    if (isholdingbound('cling')) {
      MAXBUGSPEED = 12;
    } else {
      MAXBUGSPEED = 8;
    }
    if (ladybug.timers.fightstance > 0) {
      _sidestep(dir);
      return;
    }
    _dash(dir);
    if (!settings.aircontrol && !ladybug.touchingground()) {
      return;
    }
    if (ladybug.touchingground() || ladybug.vel.x * dir > 8) {
      ladybug.facingleft = dir === -1;
    }
    vx = ladybug.vel.x + bugspeed() * dir;
    if (!settings.forcemove && Math.abs(vx) < MAXBUGSPEED) {
      ladybug.vel.x = vx;
    }
    if (settings.forcemove && Math.abs(ladybug.vel.x) < MAXBUGSPEED) {
      return ladybug.vel.x += bugspeed() * dir;
    }
  };

  left = function() {
    return _move(-1);
  };

  right = function() {
    return _move(1);
  };

  availableactions = [up, down, left, right];

  AKA = (function(_this) {
    return function(func) {
      return function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return func.apply(null, args);
      };
    };
  })(this);

  _bind = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return control.keyholdbindname.apply(control, args);
  };

  _bind('w', 'up', up);

  _bind('s', 'down', down);

  _bind('a', 'left', left);

  _bind('d', 'right', right);

  _bind('x', 'boggle', function() {});

  ControlObj.prototype.keyHoldBindCharNamed = function(key, name, func) {
    return this.keyHoldBindRawNamed(keyCharToCode[key], name, func);
  };

  control.keyHoldBindCharNamed('Up', 'up', up);

  control.keyHoldBindCharNamed('Down', 'down', down);

  control.keyHoldBindCharNamed('Left', 'left', left);

  control.keyHoldBindCharNamed('Right', 'right', right);

  control.keyHoldBindCharNamed('Space', 'jump', jump);

  control.keyHoldBindCharNamed('Shift', 'cling', function() {});

  save = function() {
    var tmpladybug;
    console.log(ladybug);
    tmpladybug = $.extend({}, ladybug);
    tmpladybug._pixisprite = void 0;
    console.log("saving");
    localStorage["bug"] = JSON.stringify(tmpladybug);
    console.log(localStorage["bug"]);
    return localStorage["settings"] = JSON.stringify(settings);
  };

  load = function() {
    console.log("loading");
    $.extend(ladybug, JSON.parse(localStorage["bug"]));
    ladybug.pos = $.extend(V(), ladybug.pos);
    ladybug.vel = V(ladybug.vel.x, ladybug.vel.y);
    return $.extend(settings, JSON.parse(localStorage["settings"]));
  };

  record_s = function() {
    jame.demofile = [];
    settings.recordingdemo = true;
    settings.playingdemo = false;
    makealert("recording demo");
    return restartlevel();
  };

  record_l = function() {
    settings.recordingdemo = false;
    settings.playingdemo = true;
    makealert("replaying demo");
    console.log(jame.demofile);
    return restartlevel();
  };

  control.keytapbindname('6', 'record', record_s);

  control.keytapbindname('7', 'replay', record_l);

  settings.layer = 1;

  changelayer = function(num) {
    return settings.layer = num;
  };

  if (settings.devmode) {
    control.keytapbindname('1', 'layer1', function() {
      return changelayer(1);
    });
    control.keytapbindname('2', 'layer2', function() {
      return changelayer(2);
    });
  }

  level_files = ["1.json", "2.json"];

  CURRENT_LEVEL = 0;

  _loadcurrlevel = function() {
    return loadlevelfile("levels/" + level_files[CURRENT_LEVEL]);
  };

  nextlevel = function() {
    if (settings.grid || ladybug.timers.fightstance) {
      return;
    }
    CURRENT_LEVEL++;
    if (CURRENT_LEVEL >= level_files.length) {
      CURRENT_LEVEL = 0;
      alert('u win');
      achieve("win");
    }
    return restartlevel();
  };

  restartlevel = function() {
    WORLD.clear();
    _loadcurrlevel();
    WORLDINIT();
    return ladybug.respawn();
  };

  if (settings.devmode) {
    control.keytapbindname('r', 'restart level', restartlevel);
    control.keytapbindname('n', 'change level', nextlevel);
  }

  this.CONTROL = control;

  eventelement = $(renderer.view);

  eventelement.attr({
    onclick: "this.focus()"
  });

  body.attr({
    onload: function() {
      return eventelement.focus();
    }
  });

  keypushcache = [];

  _ccc = function(cheat, func) {
    var input;
    input = _.last(keypushcache, cheat.length);
    if (_.isEqual(input, cheat)) {
      keypushcache = [];
      return func();
    }
  };

  konamicode = "Up Up Down Down Left Right Left Right B A Enter".split();

  cheatcodecheck = function() {
    _ccc(konamicode, function() {
      return alert("conglaturation");
    });
    return _ccc(["Right", "Up", "Right", "A", "Down", "Down", "Enter"], function() {
      alert("you'r a radical kid!!you have prooved the justice of our culture.god bless a merica. bean mode unlock!");
      return settings.beanmode = !settings.beanmode;
    });
  };

  reservedkeys = [];

  reserveKeyNamed = function(key) {
    return reservedkeys.push(keyCharToCode[key]);
  };

  ref1 = ["Space", "Up", "Down", "Backspace"];
  for (z = 0, len1 = ref1.length; z < len1; z++) {
    key = ref1[z];
    reserveKeyNamed(key);
  }

  eventelement.bind('keydown', function(e) {
    var base1;
    key = e.which;
    if (typeof (base1 = control.bindings)[key] === "function") {
      base1[key]();
    }
    if (!(indexOf.call(control.heldkeys, key) >= 0)) {
      control.heldkeys.push(key);
      keypushcache.push(keyCodeToChar[key]);
      cheatcodecheck();
    }
    if (indexOf.call(reservedkeys, key) >= 0) {
      return false;
    }
  });

  eventelement.bind('keyup', function(e) {
    key = e.which;
    control.heldkeys = _.without(control.heldkeys, key);
    if (indexOf.call(reservedkeys, key) >= 0) {
      return false;
    }
  });

  tmpcanvasjq = $("<canvas>");

  tmpcanvas = tmpcanvasjq[0];

  Block.prototype.gethitbox = function() {
    return this;
  };

  Block.prototype.initsprite = function() {
    var sprit;
    tex = blocktextures[this.tile];
    sprit = new PIXI.extras.TilingSprite(tex, this.w, this.h);
    this._pixisprite = sprit;
    return stage.addChild(sprit);
  };

  Block.prototype.render = function() {
    var difx, dx, leftwise, refpoint, rot, sprit, threshold, x;
    if (!this.hassprite()) {
      this.initsprite();
    }
    sprit = this._pixisprite;
    sprit.tilePosition = PP(-this.x, -this.y);
    sprit.position = PP(this.x, this.y);
    if (settings.whoaoa) {
      sprit.tilePosition.y = -this.y + tickno;
      sprit.height = this.h * Math.cos(tickno / 100);
    }
    if (settings.threedee) {
      threshold = 64 * 16;
      refpoint = ladybug.pos;
      difx = this.x - refpoint.x;
      leftwise = difx < 0;
      sprit.position.x = refpoint.x + difx * Math.cos(difx / threshold);
      if (Math.abs(difx) > threshold) {
        sprit.position.x = -9000;
      }
    }
    if (this.timers.bonk >= 0) {
      sprit.position.y = this.y - 8 * Math.sin(Math.PI * this.timers.bonk / 10);
      x = this.x + this.w / 2;
      dx = (x - ladybug.pos.x) / Math.pow(this.w, 1.5);
      rot = Math.sin(this.timers.bonk / 8 * dx);
      sprit.rotation = mafs.clamp(rot, -0.2, 0.2);
      return this.timers.bonk--;
    }
  };

  Water = (function(superClass) {
    extend(Water, superClass);

    function Water(x5, y5, w1, h1) {
      this.x = x5;
      this.y = y5;
      this.w = w1;
      this.h = h1;
      Water.__super__.constructor.call(this, this.x, this.y, this.w, this.h);
      this.src = "snow.png";
    }

    return Water;

  })(Block);

  Water.prototype.render = function() {
    Water.__super__.render.call(this);
    this._pixisprite.tilePosition.y = -tickno / 2;
    this._pixisprite.tilePosition.x = 16 * Math.cos(tickno / 100);
    return this._pixisprite.alpha = 0.5;
  };

  OnewayBlock = (function(superClass) {
    extend(OnewayBlock, superClass);

    function OnewayBlock(x5, y5, w1, h1) {
      this.x = x5;
      this.y = y5;
      this.w = w1;
      this.h = h1;
      OnewayBlock.__super__.constructor.call(this, this.x, this.y, this.w, this.h);
      this.src = "groundstone.png";
    }

    return OnewayBlock;

  })(Block);

  ladybug = new BugLady;

  Cloud = (function(superClass) {
    extend(Cloud, superClass);

    function Cloud() {
      Cloud.__super__.constructor.call(this);
      this.src = 'bigcloud.png';
    }

    return Cloud;

  })(Renderable);

  Cloud.prototype.spriteinit = function() {
    var sprit;
    tex = TEXBYNAME(this.src);
    sprit = new PIXI.extras.TilingSprite(tex, screensize.x, screensize.y);
    this._pixisprite = sprit;
    parentstage.addChildAt(sprit, 0);
    return sprit;
  };

  Grid = (function(superClass) {
    extend(Grid, superClass);

    function Grid() {
      Grid.__super__.constructor.call(this);
      this.src = 'square.png';
    }

    return Grid;

  })(Renderable);

  adjustedscreensize = function() {
    return {
      x: screensize.x * 10,
      y: screensize.y * 10
    };
  };

  Grid.prototype.PIXINIT = Cloud.prototype.PIXINIT = function() {
    var ref2, sprit, x, y;
    if (!this._pixisprite) {
      tex = TEXBYNAME(this.src);
      ref2 = adjustedscreensize(), x = ref2.x, y = ref2.y;
      sprit = new PIXI.extras.TilingSprite(tex, x, y);
      this._pixisprite = sprit;
      return parentstage.addChildAt(sprit, 0);
    }
  };

  Cloud.prototype.cleanup = function() {
    if (this._pixisprite) {
      parentstage.removeChild(this._pixisprite);
      return this._pixisprite = void 0;
    }
  };

  Grid.prototype.PIXREMOVE = function() {
    if (!settings.grid && this._pixisprite) {
      parentstage.removeChild(this._pixisprite);
      return this._pixisprite = void 0;
    }
  };

  Cloud.prototype.render = function() {
    var flip, offset, pos, sprit;
    pos = cameraoffset();
    flip = false;
    this.PIXINIT();
    sprit = this._pixisprite;
    offset = V(tickno * -0.2, 0);
    sprit.tilePosition = VTOPP(offset);
    if (settings.grid) {
      return this.cleanup();
    }
  };

  Grid.prototype.render = function() {
    var flip, offset, pos, sprit;
    pos = cameraoffset();
    flip = false;
    this.PIXINIT();
    sprit = this._pixisprite;
    offset = pos.nmul(-1);
    sprit.tilePosition = new PIXI.Point(offset.x, offset.y);
    return this.PIXREMOVE();
  };

  World = (function() {
    function World() {
      this.entities = [];
      this.bglayer = [];
      this.fglayer = [];
      this.spritelayer = [];
    }

    return World;

  })();

  World.prototype.entAdd = function(ent) {
    return this.spritelayer.push(ent);
  };

  World.prototype.spritesRemove = function(doomed) {
    return this.spritelayer = _.difference(this.spritelayer, doomed);
  };

  WORLD = new World;

  randpos = function() {
    return V(640 * 1.5, 64 * 2).vadd(mafs.randvec().vmul(V(640, 480)));
  };

  Shrub = (function(superClass) {
    extend(Shrub, superClass);

    function Shrub(pos1) {
      this.pos = pos1;
      Shrub.__super__.constructor.call(this, this.pos, 'shrub.png');
      this.anchor = V(1 / 2, 1);
    }

    return Shrub;

  })(GenericSprite);

  placeshrub = function(pos) {
    return WORLD.fglayer.push(new Shrub(pos));
  };

  DoubleJumper = (function(superClass) {
    extend(DoubleJumper, superClass);

    function DoubleJumper(pos1) {
      this.pos = pos1;
      DoubleJumper.__super__.constructor.call(this, this.pos);
      this.label = "airjump";
    }

    DoubleJumper.prototype.anchor = V(1 / 2, 1);

    DoubleJumper.prototype.collide = function(otherent) {
      if (otherent instanceof BugLady) {
        this.KILLME = true;
        otherent.timers.powerup = 45;
        return settings.airjump = true;
      }
    };

    return DoubleJumper;

  })(PlaceholderSprite);

  BugMeter = (function(superClass) {
    extend(BugMeter, superClass);

    function BugMeter() {
      BugMeter.__super__.constructor.call(this);
      this.src = 'bughealth.png';
      this.value = 3;
      this.abspos = V(0, 0);
      this.spritesize = V(32, 32);
      this.layer = HUDLAYER;
    }

    return BugMeter;

  })(GenericSprite);

  BugMeter.prototype.spriteinit = function() {
    var sprit;
    tex = TEXBYNAME(this.src);
    sprit = new PIXI.extras.TilingSprite(tex, this.spritesize.x * this.value, this.spritesize.y);
    this._pixisprite = sprit;
    this.layer.addChild(sprit);
    return sprit;
  };

  BugMeter.prototype.cleanup = function() {
    return stageremovesprite(this.layer, this);
  };

  BugMeter.prototype.render = function() {
    var flip, pos, sprit;
    pos = this.abspos;
    flip = false;
    if (!this._pixisprite) {
      this.spriteinit();
    }
    sprit = this._pixisprite;
    sprit.zIndex = 100;
    sprit.width = this.spritesize.x * this.value;
    sprit.scale = PP(settings.hudscale, settings.hudscale);
    return sprit.position = VTOPP(pos);
  };

  BugMeter.prototype.tick = function() {
    return this.update(ladybug.health);
  };

  BugMeter.prototype.update = function(value) {
    stageremovesprite(HUDLAYER, this);
    return this.value = value;
  };

  EnergyMeter = (function(superClass) {
    extend(EnergyMeter, superClass);

    function EnergyMeter() {
      EnergyMeter.__super__.constructor.call(this);
      this.src = 'energy1.png';
      this.abspos = V(0, 16);
    }

    return EnergyMeter;

  })(BugMeter);

  EnergyMeter.prototype.tick = function() {
    return this.update(ladybug.energy);
  };

  MoneyMeter = (function(superClass) {
    extend(MoneyMeter, superClass);

    function MoneyMeter() {
      MoneyMeter.__super__.constructor.call(this);
      this.src = 'crown.png';
      this.spritesize = V(16, 16);
      this.abspos = V(8, 64 - 16);
    }

    MoneyMeter.prototype.tick = function() {
      var ab, hhh, len2, results1;
      this.update(ladybug.score);
      results1 = [];
      for (ab = 0, len2 = hypesprites.length; ab < len2; ab++) {
        spr = hypesprites[ab];
        hhh = spr.x / 200 - tickno / 20;
        spr.tint = rgbToHex(hslToRgb(hhh % 1, 1, 0.5));
        results1.push(spr.anchor.y = 0.5 - Math.sin(tickno + spr.x / 16) / 8);
      }
      return results1;
    };

    return MoneyMeter;

  })(BugMeter);

  Block.prototype.toJSON = function() {
    return [this.x, this.y, this.w, this.h, this.tile];
  };

  loadblocks = function(blockdata) {
    return blockdata.forEach(function(blockdatum) {
      var bl, h, src, w, x, y;
      x = blockdatum[0], y = blockdatum[1], w = blockdatum[2], h = blockdatum[3], src = blockdatum[4];
      WORLD.addblock(bl = new Block(x, y, w, h));
      if (typeof src === "number") {
        bl.tile = src;
      }
      return bl.src = src;
    });
  };

  loadspawners = function(entdata) {
    return entdata.forEach(function(entdatum) {
      var spawner;
      WORLD.entAdd(spawner = new Spawner(entdatum.pos));
      return spawner.entdata = entdatum;
    });
  };

  scatterents_old = function(classproto, num) {
    var ab, results1;
    return WORLD.spritelayer = WORLD.spritelayer.concat((function() {
      results1 = [];
      for (var ab = 0; 0 <= num ? ab < num : ab > num; 0 <= num ? ab++ : ab--){ results1.push(ab); }
      return results1;
    }).apply(this).map(function() {
      return new classproto(randpos());
    }));
  };

  scatterents = function(classproto, num) {
    var ab, classname, results1;
    classname = classproto.name;
    return (function() {
      results1 = [];
      for (var ab = 0; 0 <= num ? ab < num : ab > num; 0 <= num ? ab++ : ab--){ results1.push(ab); }
      return results1;
    }).apply(this).forEach(function() {
      var entdatum;
      entdatum = {
        "class": classname,
        pos: randpos()
      };
      return loadent(entdatum);
    });
  };

  Goal = (function(superClass) {
    extend(Goal, superClass);

    function Goal(pos1) {
      this.pos = pos1;
      Goal.__super__.constructor.call(this, this.pos);
      this.label = "GOAL";
    }

    return Goal;

  })(PlaceholderSprite);

  Goal.prototype.collide = function(otherent) {
    if (otherent instanceof Hero) {
      return nextlevel();
    }
  };

  Platform = (function(superClass) {
    extend(Platform, superClass);

    function Platform(pos1) {
      this.pos = pos1;
      Platform.__super__.constructor.call(this, this.pos);
      this.size = V(64, 32);
      this.label = "platform";
      this.anchor = V(0, 1);
      this.t = 0;
    }

    Platform.prototype.tick = function() {
      if (!this.origpos) {
        this.origpos = this.pos.nadd(0);
      }
      this.t++;
      return this.pos.y = this.origpos.y + Math.sin(this.t / 100) * 64;
    };

    return Platform;

  })(PlaceholderSprite);

  HurtWire = (function(superClass) {
    extend(HurtWire, superClass);

    function HurtWire() {
      return HurtWire.__super__.constructor.apply(this, arguments);
    }

    return HurtWire;

  })(GenericSprite);

  HurtWire.prototype.size = V(8, 32);

  HurtWire.prototype.anchor = V(1 / 2, 0);

  HurtWire.prototype.getsprite = function() {
    var framelist, framewait;
    framewait = 1;
    framelist = ["wire.png"];
    if (this.state === "sparking") {
      framelist = [1, 2, 3, 4].map(function(n) {
        return "wirespark" + n + ".png";
      });
    }
    return selectframe(framelist, framewait);
  };

  HurtWire.prototype.tick = function() {
    this.age = this.age || 0;
    this.age = (this.age + 1) % 100;
    if (this.age < 30) {
      return this.state = "sparking";
    } else {
      return this.state = "inert";
    }
  };

  HurtWire.prototype.collide = function(otherent) {
    if (this.state === "sparking" && otherent instanceof Hero) {
      return otherent.takedamage();
    }
  };

  HurtWire.prototype.render = function() {
    this.src = this.getsprite();
    return HurtWire.__super__.render.call(this);
  };

  spawnables = {
    burd: Burd,
    target: Target,
    jelly: Jelly,
    powersuit: PowerSuit,
    doublejumper: DoubleJumper,
    gold: Gold,
    energy: Energy,
    lila: Lila,
    claire: Claire,
    platform: Platform,
    robot: Robo,
    robo: Robo,
    bee: Bee,
    turret: Turret,
    "HurtWire": HurtWire,
    "Target": Target,
    "Jelly": Jelly,
    "Energy": Energy,
    "Gold": Gold,
    "Thug": Thug,
    "Shrub": Shrub,
    goal: Goal,
    noisemaker: Noisemaker
  };

  Spawner = (function(superClass) {
    extend(Spawner, superClass);

    function Spawner(pos1) {
      this.pos = pos1;
      Spawner.__super__.constructor.call(this, this.pos);
      this.label = "Entity spawner";
      this.entdata = {
        "class": Jelly,
        pos: this.pos
      };
    }

    return Spawner;

  })(PlaceholderSprite);

  Spawner.prototype.render = function() {
    if (!settings.grid) {
      return removesprite(this);
    } else {
      return Spawner.__super__.render.call(this);
    }
  };

  Spawner.prototype.tick = function() {
    this.entdata.pos = this.pos;
    return this.label = this.entdata["class"];
  };

  Spawner.prototype.spawn = function() {
    return loadents([this.entdata]);
  };

  Spawner.prototype.toJSON = function() {
    return this.entdata;
  };

  jame = {};

  jame.spawn = function(classname) {
    var ent;
    if (!spawnables[classname]) {
      return;
    }
    ent = typeof spawnables[classname] === "function" ? new spawnables[classname]() : void 0;
    WORLD.entAdd(ent);
    return ent;
  };

  loadent = function(entdatum) {
    var ent, spawner;
    spawner = new Spawner();
    spawner.pos.x = entdatum.pos.x;
    spawner.pos.y = entdatum.pos.y;
    console.log(entdatum);
    spawner.entdata = entdatum;
    WORLD.entAdd(spawner);
    ent = jame.spawn(entdatum["class"]);
    return ent.load(entdatum);
  };

  WORLD.addblock = function(block) {
    if (block.layer === 2) {
      return WORLD.entAdd(block);
    } else {
      return WORLD.bglayer.push(block);
    }
  };

  loadents = function(entdata) {
    return entdata.forEach(function(entdatum) {
      return loadent(entdatum);
    });
  };

  WORLDINIT = function() {
    var bugmeter, energymeter;
    WORLD.entities.push(new Cloud());
    WORLD.entities.push(new Grid());
    bugmeter = new BugMeter;
    WORLD.entities.push(bugmeter);
    energymeter = new EnergyMeter;
    WORLD.entities.push(energymeter);
    WORLD.entities.push(new MoneyMeter);
    this.bugmeter = bugmeter;
    if (settings.hat) {
      WORLD.entities.push(new Hat());
    }
    WORLD.bglayer.forEach(function(block) {
      var fence;
      fence = new Fence();
      fence.pos = relativetobox(block, V(0, 0));
      WORLD.entAdd(fence);
      fence = new Fence();
      fence.pos = relativetobox(block, V(1, 0));
      return WORLD.entAdd(fence);
    });
    return WORLD.entAdd(ladybug);
  };

  randtri = function() {
    return new Poly([randpos(), randpos(), randpos()]);
  };

  WORLD.getallents = function() {
    return [].concat(WORLD.entities, WORLD.spritelayer, WORLD.bglayer, WORLD.fglayer);
  };

  WORLD.clear = function() {
    var ALLENTS, renderables;
    tickno = 0;
    ALLENTS = WORLD.getallents();
    renderables = ALLENTS.filter(function(ent) {
      return ent instanceof Renderable;
    });
    renderables.forEach(function(ent) {
      return typeof ent.cleanup === "function" ? ent.cleanup() : void 0;
    });
    WORLD.entities = [];
    WORLD.spritelayer = [];
    WORLD.bglayer = [];
    WORLD.fglayer = [];
    return resetstage();
  };

  roboblockdata = [];

  roboblockdata.push([-64, 64 * 4, 64 * 12, 100]);

  roboblockdata.push([64 * 12, 64 * 5, 64 * 12, 100]);

  COLLTEST_INIT = function() {
    scatterents(Jelly, 8);
    loadblocks(roboblockdata);
    return WORLD.entAdd(randtri());
  };


  /*
  levelfilename = "levels/1.json"
  $.ajax levelfilename, success: (data,status,xhr) ->
    jsondata=JSON.parse data
    loadlevel jsondata
   */

  loadlevel = function(data) {
    loadblocks(data.blockdata);
    return loadents(data.ents);
  };

  loadlevelfile = function(levelfilename) {
    WORLD.doneloading = false;
    return $.ajax(levelfilename, {
      success: function(data, status, xhr) {
        var jsondata;
        jsondata = data;
        loadlevel(jsondata);
        WORLD.doneloading = true;
        return settings.paused = false;
      }
    });
  };

  _loadcurrlevel();

  WORLDINIT();

  camera = {};

  jame.camera = camera;

  camera.offset = V();

  camera.pos = V();

  camera.trackingent = ladybug;

  camera.zoomout = function() {
    scale -= 0.1;
    return scale = mafs.clamp(scale, 0.1, 1);
  };

  camera.zoomin = function() {
    scale += 0.1;
    return scale = mafs.clamp(scale, 0.1, 1);
  };

  cameraoffset = function() {
    var tmppos;
    if (settings.grid || ladybug.timers.fightstance) {
      return camera.pos;
    }
    tmppos = camera.trackingent.pos.nadd(0);
    offs = camera.trackingent.vel.vmul(V(5, 0));
    tmppos = tmppos.vadd(offs);
    tmppos.y = mafs.roundn(tmppos.y, 256);
    tmppos = tmppos.vsub(camera.offset.ndiv(scale));
    tmppos = tmppos.vsub(screensize.ndiv(2 * scale));
    return camera.pos.vadd(tmppos).ndiv(2);
  };

  camera.tick = function() {
    return camera.pos = cameraoffset();
  };


  /*
  stage.updateLayersOrder = ->
    stage.children.sort (a,b) ->
      a.zIndex ?= 0
      b.zIndex ?= 0
      return b.zIndex-a.zIndex
   */

  render = function() {
    var highlighted, renderables;
    camera.tick();
    renderables = [].concat(WORLD.bglayer, WORLD.spritelayer, [ladybug], WORLD.fglayer, WORLD.entities);
    renderables.forEach(function(ent) {
      return typeof ent.render === "function" ? ent.render() : void 0;
    });
    highlighted = renderables.filter(function(ent) {
      return ent.HIGHLIGHT != null;
    });
    if (settings.grid) {
      highlighted = renderables;
    }
    return drawhitboxes(highlighted);
  };

  drawhitboxes = function(ents) {
    var graf;
    stage.removeChild(hitboxlayer);
    hitboxlayer = new PIXI.Container;
    stage.addChild(hitboxlayer);
    graf = new PIXI.Graphics();
    graf.lineStyle(1, 0x00ff00, 1);
    graf.beginFill(0xff0000, 1 / 8);
    ents.forEach(function(ent) {
      var box, velbox;
      graf.lineStyle(1, 0x00ff00, 1);
      graf.drawCircle(ent.pos.x, ent.pos.y, 4);
      box = typeof ent.gethitbox === "function" ? ent.gethitbox() : void 0;
      if (!box) {
        return;
      }
      graf.drawRect(box.x, box.y, box.w, box.h);
      velbox = typeof ent.fallbox === "function" ? ent.fallbox() : void 0;
      if (!velbox) {
        return;
      }
      graf.lineStyle(1, 0x0000ff, 1);
      return graf.drawRect(velbox.x, velbox.y, velbox.w, velbox.h);
    });
    return hitboxlayer.addChild(graf);
  };

  timecall = function(func) {
    var starttime;
    starttime = Date.now();
    func();
    return Date.now() - starttime;
  };

  tickwaitms = 20;

  skipframes = 0;

  ticktimes = [];

  WORLD.gethitbox = function(sprite) {
    return sprite.gethitbox();
  };

  checkcolls = function(ent, otherents) {
    var bawks;
    if (settings.NOCOLLS) {
      return false;
    }
    bawks = WORLD.gethitbox(ent);
    return otherents.forEach(function(target) {
      var targethitbox;
      if (target === ent) {
        return;
      }
      targethitbox = WORLD.gethitbox(target);
      if (bawks.overlaps(targethitbox)) {
        return typeof target.collide === "function" ? target.collide(ent) : void 0;
      }
    });
  };

  WORLD.euthanasia = function() {
    var doomedsprites;
    doomedsprites = WORLD.spritelayer.filter(function(sprite) {
      return sprite.KILLME != null;
    });
    doomedsprites.forEach(function(sprite) {
      return typeof sprite.cleanup === "function" ? sprite.cleanup() : void 0;
    });
    return WORLD.spritesRemove(doomedsprites);
  };

  reset_tick_stats = function() {
    return stats.collisionchecks = 0;
  };

  COLLGRIDSIZE = 64;

  WORLD.collgrid = {
    contents: [],
    clear: function() {
      return this.contents = [];
    },
    getraw: function(rect, ignore) {
      var ar, ref2;
      if (ignore == null) {
        ignore = [];
      }
      i = Math.floor(rect.x / COLLGRIDSIZE);
      ar = ((ref2 = this.contents) != null ? ref2[i] : void 0) || [];
      ar = ar.filter(function(objrect) {
        var ref3;
        return ref3 = objrect.obj, indexOf.call(ignore, ref3) < 0;
      });
      return ar;
    },
    get: function(rect, ignore) {
      var ar, ref2;
      if (ignore == null) {
        ignore = [];
      }
      if (!Array.isArray(ignore)) {
        ignore = [ignore];
      }
      i = Math.floor(rect.x / COLLGRIDSIZE);
      ar = ((ref2 = this.contents) != null ? ref2[i] : void 0) || [];
      ar = ar.filter(function(objrect) {
        var ref3;
        return ref3 = objrect.obj, indexOf.call(ignore, ref3) < 0;
      });
      return _.pluck(ar, 'rect');
    },
    set: function(rect, obj) {
      i = Math.floor(rect.x / COLLGRIDSIZE);
      this.contents[i] = this.contents[i] || [];
      return this.contents[i].push({
        obj: obj,
        rect: rect
      });
    }
  };

  WORLD.updateboxes = function() {
    var JELS;
    WORLD.collgrid.clear();
    WORLD.BOXCACHE = [];
    JELS = get_sprites_of_class(Jelly);
    JELS = JELS.concat(get_sprites_of_class(Platform));
    return JELS.forEach((function(_this) {
      return function(ent) {
        var box;
        box = typeof ent.gethitbox === "function" ? ent.gethitbox() : void 0;
        return WORLD.collgrid.set(box, ent);
      };
    })(this));
  };

  css = {
    transition: "background .2s",
    boxShadow: "4px 4px 8px rgba(0,0,0,.5)",
    top: "200px",
    left: "400px",
    position: "absolute",
    width: 32,
    height: 32,
    background: "url('sprites/metroid like.png')"
  };

  WORLD.xx = [
    {
      elm: (function() {
        var e;
        e = $("<div>");
        e.css(css);
        e.appendTo(body);
        return e;
      })(),
      tick: function() {
        var pos;
        pos = gettileoffs(TILESELECT, 20, 16);
        pos = pos.nmul(-16);
        this.elm.css({
          backgroundPosition: pos.x + " " + pos.y
        });
        return this.elm.css({
          left: 16 + SCREENCURS.x + 'px',
          top: 16 + SCREENCURS.y + 'px'
        });
      }
    }
  ];

  jame.demofile = [];

  recordinputs = function() {
    var ech;
    if (!settings.recordingdemo) {
      return false;
    }
    ech = [];
    ech = ech.concat(control.heldkeys);
    return jame.demofile.push(ech);
  };

  _repdupes = function(arr, rep) {
    var ab, len2, prev, results1, x;
    results1 = [];
    for (ab = 0, len2 = arr.length; ab < len2; ab++) {
      x = arr[ab];
      if (x === prev) {
        results1.push(rep);
      } else {
        results1.push(prev = x);
      }
    }
    return results1;
  };

  _demotick = function() {
    var tmpks;
    recordinputs();
    if (settings.playingdemo) {
      tmpks = jame.demofile.slice(tickno, +(tickno + 64) + 1 || 9e9).map(function(x) {
        return x.toString();
      });
      tmpks = _repdupes(tmpks, "~~");
      tmpks = tmpks.map(function(s) {
        if (s === "") {
          return "  ";
        } else {
          return s;
        }
      });
      TICKLOG(xmlwrap('pre', tmpks.join(",")));
      if (tickno >= jame.demofile.length) {
        settings.playingdemo = false;
        return makealert("replay over");
      } else {
        return control.heldkeys = jame.demofile[tickno];
      }
    }
  };

  WORLD.tick = function() {
    var ACTIVEENTS, ab, base1, len2, ref2;
    _demotick();
    reset_tick_stats();
    ref2 = control.heldkeys;
    for (ab = 0, len2 = ref2.length; ab < len2; ab++) {
      key = ref2[ab];
      if (typeof (base1 = control.holdbindings)[key] === "function") {
        base1[key]();
      }
    }
    WORLD.updateboxes();
    checkcolls(ladybug, WORLD.spritelayer);
    WORLD.spritelayer.forEach(function(sprite) {
      return checkcolls(sprite, _.without(WORLD.spritelayer, sprite));
    });
    WORLD.euthanasia();
    ACTIVEENTS = [].concat(WORLD.spritelayer, WORLD.entities, WORLD.xx);
    ACTIVEENTS.forEach(function(ent) {
      return typeof ent.tick === "function" ? ent.tick() : void 0;
    });
    render();
    return tickno++;
  };

  fpscounter = $(xmltag());

  fpscounter.attr({
    "class": "ticklog"
  });

  tt = 0;

  updateinfobox = function() {
    text = control.heldkeys.map(function(key) {
      return "<span>" + keyCodeToChar[key] + "</span>";
    });
    return $(infobox).html(text.join(" "));
  };

  TICKLOG = function(datum) {
    if (!settings.devmode) {
      return;
    }
    return fpscounter.append($(xmlwrap('div', datum)));
  };

  _ml = function() {
    return getCursorBlocks().forEach(function(bl) {
      var tmp;
      tmp = [bl.x, bl.y, bl.w, bl.h].map(function(n) {
        return n / settings.gridsize;
      });
      return TICKLOG(tmp.join(", "));
    });
  };

  hz = function(ms) {
    return Math.round(1000 / ms);
  };

  mainloop = function() {
    var dms, fps, fpsgoal, idealfps, ticktime;
    if (tickno % 300 === 0) {
      updatesettingstable();
    }
    updateinfobox();
    if (!WORLD.doneloading) {
      settings.paused = true;
    }
    fpscounter.html("");
    if (!settings.paused) {
      ticktime = timecall(WORLD.tick);
      tt = ticktime;
      fps = hz(Math.max(tickwaitms, ticktime));
      idealfps = hz(tickwaitms);
      TICKLOG("~" + fps + "/" + idealfps + " fps ; per tick: " + tt + "ms");
      TICKLOG(stats.collisionchecks + " collisionchecks");
      _ml();
    }
    fpsgoal = settings.slowmo ? 4 : settings.fps;
    tickwaitms = hz(fpsgoal);
    dms = tickwaitms - ticktime;
    TICKLOG(dms);
    setTimeout(mainloop, Math.max(dms, 1));
    return requestAnimationFrame(animate);
  };

  xmlwrap = function(tagname, body) {
    return xmltag(tagname, void 0, body);
  };

  maketablerow = function(values) {
    var tds;
    tds = values.map(function(v) {
      return xmlwrap("td", v);
    });
    return xmlwrap("tr", tds);
  };

  jame.maketable = function(arrofarr) {
    var domelm, k, v;
    domelm = $('<table>');
    for (k in arrofarr) {
      v = arrofarr[k];
      domelm.append(maketablerow(v));
    }
    return domelm;
  };

  selectall = function(classname) {
    return jame.WORLD.spritelayer.filter(function(obj) {
      return obj.constructor.name === classname;
    });
  };

  jame.listents = function() {
    var ents;
    ents = _.pairs(_.countBy(jame.WORLD.spritelayer, function(obj) {
      return obj.constructor.name;
    }));
    return body.append(jame.maketable(ents));
  };

  infobox = $("<div>");

  infobox.css({
    float: "right",
    border: "1px solid black"
  });

  body.append(infobox);

  bindingsDOM = $("<table>");

  bindingsDOMcontainer = $("<details>");

  bindingsDOMcontainer.append(bindingsDOM);

  ref2 = control.bindingnames;
  for (k in ref2) {
    v = ref2[k];
    bindingsDOM.append(maketablerow([keyCodeToChar[k], v || "??"]));
  }

  _CHARbindingnames = {};

  ref3 = control.bindingnames;
  for (k in ref3) {
    v = ref3[k];
    _CHARbindingnames[keyCodeToChar[k]] = v;
  }

  settingsDOM = $("<table>");

  settingsDOMcontainer = $("<details>");

  settingsDOMcontainer.append(settingsDOM);

  updatesettingstable = function() {
    var results1, tempv;
    settingsDOM.html("");
    results1 = [];
    for (k in settings) {
      v = settings[k];
      if (v === true || v === false) {
        tempv = xmltag("button", {
          onclick: "jame.settings." + k + "=!jame.settings." + k
        }, v);
      } else if (typeof v === "number") {
        tempv = xmltag("input", {
          type: "number",
          oninput: "jame.settings." + k + "=parseFloat(this.value)",
          value: v
        });
      } else {
        tempv = v;
      }
      results1.push(settingsDOM.append(maketablerow([k, tempv])));
    }
    return results1;
  };

  INIT = function() {
    if (settings.devmode) {
      body.append(fpscounter);
    }
    bindingsDOMcontainer.append("<summary>bindings:</summary>");
    body.append($("<br/>"));
    body.append(keyboardlayout.visualize(_CHARbindingnames));
    body.append(bindingsDOMcontainer);
    settingsDOMcontainer.append("<summary>settings:</summary>");
    body.append(settingsDOMcontainer);
    return mainloop();
  };

  INIT();

  adjustmouseevent = function(e) {
    var adjusted, coffs;
    coffs = $(renderer.view).offset();
    adjusted = V(e.pageX - coffs.left, e.pageY - coffs.top);
    adjusted = adjusted.ndiv(scale);
    adjusted = adjusted.vadd(camera.pos);
    adjusted = adjusted.op(Math.round);
    return adjusted;
  };

  Tool = (function() {
    function Tool() {}

    return Tool;

  })();

  NOOPTOOL = {
    name: 'noop',
    mousedown: (function() {}),
    mouseup: (function() {}),
    mousemove: (function() {})
  };

  BLOCKCREATIONTOOL = _.extend({}, NOOPTOOL, {
    name: 'create block',
    creatingblock: false,
    mousedown: function(e) {
      var adjusted;
      if (e.button !== 0) {
        return;
      }
      adjusted = adjustmouseevent(e);
      adjusted = snapmouseadjust(adjusted);
      BLOCKCREATIONTOOL.creatingblock = new Block(adjusted.x, adjusted.y, 32, 32);
      BLOCKCREATIONTOOL.creatingblock.layer = settings.layer;
      WORLD.addblock(BLOCKCREATIONTOOL.creatingblock);
      return BLOCKCREATIONTOOL.creatingblock.src = selectedtexture;
    },
    mouseup: function(e) {
      if (e.button !== 0) {
        return;
      }
      BLOCKCREATIONTOOL.creatingblock.fixnegative();
      return BLOCKCREATIONTOOL.creatingblock = false;
    },
    mousemove: function(e) {
      var creatingblock, currclickpos, mpos, offset;
      mpos = snapmouseadjust(adjustmouseevent(e));
      creatingblock = BLOCKCREATIONTOOL.creatingblock;
      if (creatingblock) {
        creatingblock.w = mpos.x - creatingblock.x;
        creatingblock.h = mpos.y - creatingblock.y;
        creatingblock.removesprite();
      }
      if (ORIGCLICKPOS) {
        currclickpos = V(e.pageX, e.pageY);
        offset = currclickpos.vsub(ORIGCLICKPOS);
        return camera.offset = offset;
      }
    }
  });

  __snap = function(mpos, func) {
    return mpos.ndiv(settings.gridsize).op(func).nmul(settings.gridsize);
  };

  snapmouseadjust_always = function(mpos) {
    return __snap(mpos, Math.round);
  };

  snapmouseadjust_down = function(mpos) {
    return __snap(mpos, Math.floor);
  };

  snapmouseadjust = function(mpos) {
    var snaptogrid;
    snaptogrid = isholdingkey('z');
    if (!snaptogrid) {
      return snapmouseadjust_always(mpos);
    }
    return mpos;
  };

  smame = function(e) {
    return snapmouseadjust(adjustmouseevent(e));
  };

  MoveTool = (function(superClass) {
    extend(MoveTool, superClass);

    function MoveTool() {
      return MoveTool.__super__.constructor.apply(this, arguments);
    }

    return MoveTool;

  })(Tool);

  MoveTool.prototype.name = 'move entities';

  MoveTool.prototype.constructor = function() {
    return this.selected = [];
  };

  MoveTool.prototype.mouseup = function(e) {
    this.selected = [];
    return setcursor('auto');
  };

  MoveTool.prototype.mousemove = function(e) {
    var entsundercursor, isSelecting, p;
    this.selected = this.selected || [];
    isSelecting = this.selected.length > 0;
    p = adjustmouseevent(e);
    entsundercursor = getentsunderpoint(p);
    if (isSelecting) {
      setcursor(browserprefix + "grabbing");
    } else {
      setcursor('auto');
    }
    if (entsundercursor.length > 0) {
      setcursor(browserprefix + "grab");
    }
    p = snapmouseadjust(p);
    return this.selected.forEach(function(ent) {
      ent.pos = p;
      return ent.vel = V();
    });
  };

  MoveBlockTool = (function(superClass) {
    extend(MoveBlockTool, superClass);

    MoveBlockTool.prototype.name = 'move blocks';

    function MoveBlockTool() {
      this.selected = [];
      this.relpos = V(0, 0);
    }

    MoveBlockTool.prototype.mouseup = function(e) {
      this.selected = [];
      return setcursor('auto');
    };

    MoveBlockTool.prototype.mousemove = function(e) {
      var isSelecting, p;
      this.selected = this.selected || [];
      isSelecting = this.selected.length > 0;
      p = adjustmouseevent(e);
      p = p.vsub(this.relpos);
      p = snapmouseadjust(p);
      return this.selected.forEach((function(_this) {
        return function(ent) {
          ent.pos = p;
          ent.x = p.x;
          ent.y = p.y;
          return ent.removesprite();
        };
      })(this));
    };

    return MoveBlockTool;

  })(Tool);

  MoveBlockTool.prototype.mousedown = function(e) {
    var blocksundercursor, p;
    p = adjustmouseevent(e);
    blocksundercursor = blocksatpoint(WORLD.bglayer, p);
    this.selected = blocksundercursor;
    return this.relpos = p.vsub(this.selected[0].pos);
  };

  getentsunderpoint = function(p) {
    return WORLD.spritelayer.filter(function(ent) {
      var box;
      box = typeof ent.gethitbox === "function" ? ent.gethitbox() : void 0;
      return box && box.containspoint(p);
    });
  };

  MoveTool.prototype.mousedown = function(e) {
    var entsundercursor, p;
    p = adjustmouseevent(e);
    entsundercursor = getentsunderpoint(p);
    return this.selected = entsundercursor;
  };

  setcursor = function(cursorname) {
    return $(renderer.view).css('cursor', cursorname);
  };

  MOVETOOL = new MoveTool();

  MOVETOOL.selected = [];

  MOVEBLOCKTOOL = new MoveBlockTool();

  tool = MOVETOOL;

  prevtool = MOVETOOL;

  $(renderer.view).mousedown(function(e) {
    if (e.button === MLEFT) {
      if (typeof tool.mousedown === "function") {
        tool.mousedown(e);
      }
    }
    if (e.button === MRIGHT) {
      return typeof prevtool.mousedown === "function" ? prevtool.mousedown(e) : void 0;
    }
  });

  $(renderer.view).mouseup(function(e) {
    if (e.button === MLEFT) {
      if (typeof tool.mouseup === "function") {
        tool.mouseup(e);
      }
    }
    if (e.button === MRIGHT) {
      return typeof prevtool.mouseup === "function" ? prevtool.mouseup(e) : void 0;
    }
  });

  $(renderer.view).mousemove(function(e) {
    console.log(tool.held, prevtool.held);
    if (typeof tool.mousemove === "function") {
      tool.mousemove(e);
    }
    return typeof prevtool.mousemove === "function" ? prevtool.mousemove(e) : void 0;
  });

  randposrel = function(p) {
    if (p == null) {
      p = V();
    }
    return p.vadd(mafs.randvec().vmul(V(32, 32)));
  };

  TRIANGLETOOL = _.extend({}, NOOPTOOL, {
    name: "add triangle",
    mousedown: function(e) {
      var p, triangle;
      p = adjustmouseevent(e);
      triangle = new Poly([randposrel(p), randposrel(p), randposrel(p)]);
      return WORLD.entAdd(triangle);
    },
    mouseup: function(e) {},
    mousemove: function(e) {}
  });

  SPAWNTOOL = {
    name: 'Spawn entity'
  };

  SPAWNTOOL.classname = 'burd';

  SPAWNTOOL.mousedown = function(e) {
    var ent, p;
    p = adjustmouseevent(e);
    ent = jame.spawn(SPAWNTOOL.classname);
    return ent.pos = p;
  };

  SPAWNTOOL.mouseup = function(e) {};

  SPAWNTOOL.mousemove = function(e) {};

  SPAWNERTOOL = _.extend({}, NOOPTOOL, {
    name: 'Spawn entity',
    classname: 'burd',
    mousedown: function(e) {
      var ent, p;
      p = adjustmouseevent(e);
      WORLD.entAdd(ent = new Spawner(p));
      ent.pos = p;
      ent.entdata["class"] = SPAWNTOOL.classname;
      return ent.spawn();
    }
  });

  TELEPORTTOOL = _.extend({}, NOOPTOOL, {
    name: "teleport",
    mousedown: function(e) {
      var p;
      p = adjustmouseevent(e);
      ladybug.pos = p;
      return ladybug.vel = V(0, 0);
    }
  });

  boxesbounding = function(boxlist) {
    var b, bs, l, ls, r, rs, t, ts;
    ls = boxlist.map(function(b) {
      return b.left();
    });
    rs = boxlist.map(function(b) {
      return b.right();
    });
    ts = boxlist.map(function(b) {
      return b.top();
    });
    bs = boxlist.map(function(b) {
      return b.bottom();
    });
    l = ls.reduce(function(n, m) {
      return Math.min(n, m);
    });
    r = rs.reduce(function(n, m) {
      return Math.max(n, m);
    });
    t = ts.reduce(function(n, m) {
      return Math.min(n, m);
    });
    b = bs.reduce(function(n, m) {
      return Math.max(n, m);
    });
    return new Block(l, t, r - l, b - t);
  };

  blockcarve = function(aa, bb) {
    var a, ab, b, blok, blokx, len2, results1, x1, x2, x3, x4, y1, y2, y3, y4;
    b = boxesbounding([aa, bb]);
    a = aa.intersection(bb);
    x1 = b.left();
    x2 = a.left();
    x3 = a.right();
    x4 = b.right();
    y1 = b.top();
    y2 = a.top();
    y3 = a.bottom();
    y4 = b.bottom();
    blokx = [[x1, y1, x2 - x1, y2 - y1], [x2, y1, x3 - x2, y2 - y1], [x3, y1, x4 - x3, y2 - y1], [x1, y2, x2 - x1, y3 - y2], [x2, y2, x3 - x2, y3 - y2], [x3, y2, x4 - x3, y3 - y2], [x1, y3, x2 - x1, y4 - y3], [x2, y3, x3 - x2, y4 - y3], [x3, y3, x4 - x3, y4 - y3]];
    blokx = blokx.map(function(blok) {
      var newthing;
      newthing = new Block(blok[0], blok[1], blok[2], blok[3]);
      newthing.fixnegative();
      return newthing;
    });
    blokx = blokx.filter(function(blok) {
      return blok.strictoverlaps(aa) || blok.strictoverlaps(bb);
    });
    results1 = [];
    for (ab = 0, len2 = blokx.length; ab < len2; ab++) {
      blok = blokx[ab];
      results1.push(WORLD.addblock(blok));
    }
    return results1;
  };

  unfuck = function(p) {
    var a, b, blocks;
    blocks = blocksatpoint(WORLD.bglayer, p);
    if (blocks.length === 2) {
      a = blocks[0];
      b = blocks[1];
      blockcarve(a, b);
      WORLD.bglayer = _.without(WORLD.bglayer, a);
      WORLD.bglayer = _.without(WORLD.bglayer, b);
      stage.removeChild(a._pixisprite);
      return stage.removeChild(b._pixisprite);
    }
  };

  UNIONTOOL = _.extend({}, NOOPTOOL, {
    name: "unfuck block overlaps",
    mousedown: function(e) {
      var p;
      p = adjustmouseevent(e);
      return unfuck(p);
    }
  });

  carveoutblock = function(b) {
    var ab, ac, block, bloke, len2, len3, results1, tocarve, todelete;
    block = new Block(b.x, b.y, b.w, b.h);
    tocarve = block.allstrictoverlaps();
    for (ab = 0, len2 = tocarve.length; ab < len2; ab++) {
      bloke = tocarve[ab];
      blockcarve(bloke, block);
    }
    todelete = block.allstrictoverlaps();
    results1 = [];
    for (ac = 0, len3 = todelete.length; ac < len3; ac++) {
      bloke = todelete[ac];
      WORLD.bglayer = _.without(WORLD.bglayer, bloke);
      if (bloke._pixisprite != null) {
        results1.push(stage.removeChild(bloke._pixisprite));
      } else {
        results1.push(void 0);
      }
    }
    return results1;
  };

  CARVER = _.extend({}, NOOPTOOL, {
    name: "block carver",
    carve: function(p) {
      CARVER.creatingblock = new Block(p.x, p.y, 32, 32);
      return WORLD.addblock(CARVER.creatingblock);
    },
    mousedown: function(e) {
      var adjusted;
      if (e.button !== 0) {
        return;
      }
      adjusted = adjustmouseevent(e);
      adjusted = snapmouseadjust(adjusted);
      return this.carve(adjusted);
    },
    mouseup: function(e) {
      if (e.button !== 0) {
        return;
      }
      CARVER.creatingblock.fixnegative();
      carveoutblock(CARVER.creatingblock);
      return CARVER.creatingblock = false;
    },
    mousemove: function(e) {
      var creatingblock, currclickpos, mpos, offset;
      mpos = snapmouseadjust(adjustmouseevent(e));
      creatingblock = CARVER.creatingblock;
      if (creatingblock) {
        creatingblock.w = mpos.x - creatingblock.x;
        creatingblock.h = mpos.y - creatingblock.y;
        creatingblock.src = "lila.png";
        creatingblock.removesprite();
      }
      if (ORIGCLICKPOS) {
        currclickpos = V(e.pageX, e.pageY);
        offset = currclickpos.vsub(ORIGCLICKPOS);
        return camera.offset = offset;
      }
    }
  });

  WATERTOOL = _.extend({}, NOOPTOOL, {
    name: "turn block into water",
    mousedown: function(e) {
      var ab, adjusted, bl, blocksundercursor, len2, results1;
      if (e.button !== 0) {
        return;
      }
      adjusted = adjustmouseevent(e);
      adjusted = snapmouseadjust(adjusted);
      blocksundercursor = blocksatpoint(WORLD.bglayer, adjusted);
      results1 = [];
      for (ab = 0, len2 = blocksundercursor.length; ab < len2; ab++) {
        bl = blocksundercursor[ab];
        WORLD.spritelayer.unshift(new Water(bl.x, bl.y, bl.w, bl.h));
        results1.push(bglayer_remove_block(bl));
      }
      return results1;
    }
  });

  BASETOOL = _.extend({}, NOOPTOOL, {
    held: false,
    mousedown: function(e) {
      this.held = true;
      return this.leftclick(adjustmouseevent(e));
    },
    mouseup: function(e) {
      return this.held = false;
    },
    mousemove: function(e) {
      if (this.held) {
        return this.lefthold(adjustmouseevent(e));
      }
    },
    leftclick: function(p) {
      return this.action(p);
    },
    lefthold: function(p) {
      return this.action(p);
    }
  });

  BLOCKPAINT = _.extend({}, BASETOOL, {
    name: "draw blocks",
    action: function(p) {
      var blocksundercursor, gs, newblock, snapped, tmp;
      gs = 32;
      tmp = settings.gridsize;
      settings.gridsize = gs;
      snapped = snapmouseadjust_down(p);
      blocksundercursor = blocksatpoint(WORLD.bglayer, p);
      if (blocksundercursor.length === 0) {
        newblock = new Block(snapped.x, snapped.y, gs, gs);
        WORLD.addblock(newblock);
        newblock.src = selectedtexture;
      }
      return settings.gridsize = tmp;
    }
  });

  alltools = [MOVETOOL, TRIANGLETOOL, SPAWNERTOOL, TELEPORTTOOL];

  blocktools = [BLOCKCREATIONTOOL, MOVEBLOCKTOOL, UNIONTOOL, CARVER, WATERTOOL, BLOCKPAINT];

  alltools.push(_.extend({}, NOOPTOOL, {
    name: "delete block",
    mousedown: function(e) {
      var adjusted, selected;
      adjusted = adjustmouseevent(e);
      adjusted = snapmouseadjust(adjusted);
      selected = blocksatpoint(WORLD.bglayer, adjusted);
      return tool_clickdelete(adjusted);
    }
  }));

  alltools.push(_.extend({}, NOOPTOOL, {
    name: "select entity",
    mousedown: function(e) {
      var adjusted, selected;
      if (e.button !== 0) {
        return;
      }
      adjusted = adjustmouseevent(e);
      adjusted = snapmouseadjust(adjusted);
      selected = getentsunderpoint(adjusted);
      return console.log(selected[0]);
    }
  }));

  mktool = function(obj) {
    return alltools.push(_.extend({}, BASETOOL, obj));
  };

  mktool({
    name: "painter",
    action: function(p) {
      var ab, bl, len2, ref4, results1;
      ref4 = getCursorBlocks();
      results1 = [];
      for (ab = 0, len2 = ref4.length; ab < len2; ab++) {
        bl = ref4[ab];
        bl.tile = TILESELECT;
        results1.push(bl.removesprite());
      }
      return results1;
    }
  });

  mktool({
    name: "picker",
    action: function(p) {
      var selected;
      selected = blocksatpoint(WORLD.bglayer, p);
      return TILESELECT = selected[0].tile;
    }
  });

  alltools.push(_.extend({}, NOOPTOOL, {
    name: "turn block into oneway",
    mousedown: function(e) {
      var ab, adjusted, bl, blocksundercursor, len2, results1;
      if (e.button !== 0) {
        return;
      }
      adjusted = adjustmouseevent(e);
      adjusted = snapmouseadjust(adjusted);
      blocksundercursor = blocksatpoint(WORLD.bglayer, adjusted);
      results1 = [];
      for (ab = 0, len2 = blocksundercursor.length; ab < len2; ab++) {
        bl = blocksundercursor[ab];
        WORLD.bglayer.unshift(new OnewayBlock(bl.x, bl.y, bl.w, bl.h));
        results1.push(bglayer_remove_block(bl));
      }
      return results1;
    }
  }));

  alltools.push(_.extend({}, NOOPTOOL, {
    name: "turn block into background",
    mousedown: function(e) {
      var ab, adjusted, bl, blocksundercursor, len2, results1;
      if (e.button !== 0) {
        return;
      }
      adjusted = adjustmouseevent(e);
      adjusted = snapmouseadjust(adjusted);
      blocksundercursor = blocksatpoint(WORLD.bglayer, adjusted);
      results1 = [];
      for (ab = 0, len2 = blocksundercursor.length; ab < len2; ab++) {
        bl = blocksundercursor[ab];
        WORLD.entities.unshift(bl);
        results1.push(bglayer_remove_block(bl));
      }
      return results1;
    }
  }));

  if (settings.devmode) {
    toolbar = $(xmltag('details', {
      "class": 'toolbar'
    }));
    toolbar.append($(xmltag('summary', void 0, 'tools')));
    toolbar.insertAfter($(renderer.view));
    blocktools.forEach(function(t) {
      var but;
      but = $(xmltag('button', void 0, t.name));
      but.click(function() {
        return tool = t;
      });
      return toolbar.append(but);
    });
    alltools.forEach(function(t) {
      var but;
      but = $(xmltag('button', void 0, t.name));
      but.click(function() {
        prevtool = tool;
        tool = t;
        $(".toolbar button").css({
          backgroundColor: 'lightgray'
        });
        return but.css({
          backgroundColor: 'pink'
        });
      });
      return toolbar.append(but);
    });
  }

  allactions = {};

  this.allactions = allactions;

  bindaction = function(key, actionname) {
    return control.keytapbindname(key, actionname, allactions[actionname]);
  };

  this.bindaction = bindaction;

  readablebindings = function() {
    var ks, vs;
    ks = _.keys(control.bindingnames);
    vs = _.values(control.bindingnames);
    ks = ks.map(function(k) {
      return keyCodeToChar[Number(k)];
    });
    return _.zip(ks, vs);
  };

  getotherhero = function() {
    var heroes;
    heroes = jame.WORLD.spritelayer.filter(function(ent) {
      return ent instanceof Hero;
    });
    i = heroes.indexOf(ladybug);
    i = (i + 1) % heroes.length;
    return heroes[i];
  };

  allactions['swap character'] = function() {
    ladybug = getotherhero();
    return camera.trackingent = ladybug;
  };

  bindaction('u', "swap character");

  unzip = function(data) {
    return _.zip.apply(_, data);
  };

  allactions['export keybindings'] = function() {
    var data;
    data = JSON.stringify(readablebindings());
    return window.open().document.write(data);
  };

  allactions['import keybindings'] = function() {
    var data, func, newbinds, newholdbinds, rawdata;
    rawdata = prompt('paste data here');
    newbinds = [];
    newholdbinds = [];
    if (rawdata != null) {
      data = JSON.parse(rawdata);
      for (k in data) {
        v = data[k];
        k = keyCharToCode[v[0]];
        v = v[1];
        console.log(k, v);
        func = control.bindings[k];
        if (func != null) {
          newbinds.push({
            k: k,
            name: v,
            f: func
          });
        }
        func = control.holdbindings[k];
        if (func != null) {
          newholdbinds.push({
            k: k,
            name: v,
            f: func
          });
        }
      }
      console.log(newbinds);
      console.log(newholdbinds);
      control.bindings = {};
      control.holdbindings = {};
      control.bindingnames = {};
      newbinds.forEach(function(binding) {
        return control.bindings[binding.k] = binding.f;
      });
      return newholdbinds.forEach(function(binding) {
        return control.holdbindings[binding.k] = binding.f;
      });
    }
  };

  allactions['export level'] = function() {
    var data, ents, spawners;
    ents = WORLD.getallents();
    spawners = ents.filter(function(ent) {
      return ent instanceof Spawner;
    });
    data = {
      ents: spawners,
      blockdata: WORLD.bglayer
    };
    return window.open().document.write(JSON.stringify(data));
  };

  allactions['import level'] = function() {
    var data, rawdata;
    rawdata = prompt('paste data here');
    if (rawdata != null) {
      data = JSON.parse(rawdata);
      WORLD.clear();
      loadlevel(data);
      WORLDINIT();
      return ladybug.respawn();
    }
  };

  allactions['load .json test level'] = function() {
    var levelfilename;
    levelfilename = "levels/2.json";
    return $.ajax(levelfilename, {
      success: function(data, status, xhr) {
        var jsondata;
        jsondata = JSON.parse(data);
        WORLD.clear();
        loadlevel(jsondata);
        WORLDINIT();
        return ladybug.respawn();
      }
    });
  };

  actioncategories = {
    silly: {}
  };

  actioncategories.silly['evolve babb'] = function() {
    return settings.skathi = true;
  };

  actioncategories.silly['become queen of the slimes'] = function() {
    var hat;
    WORLD.entAdd(hat = new Hat());
    return hat.src = 'crown.png';
  };

  actioncategories.silly['become queen of the cats'] = function() {
    var hat;
    WORLD.entAdd(hat = new Hat());
    hat.anchor = V(1 / 2, 1 / 4);
    return hat.src = 'cheshface.png';
  };

  actioncategories.silly["toggle moonjump"] = function() {
    return settings.moonjump = !settings.moonjump;
  };

  actioncategories.silly["tiny horse"] = function() {
    return settings.pone = !settings.pone;
  };

  actioncategories["level editing"] = {
    "align all blocks to grid": function() {
      var ab, block, gridsize, len2, ref4, results1;
      gridsize = settings.gridsize;
      ref4 = WORLD.bglayer;
      results1 = [];
      for (ab = 0, len2 = ref4.length; ab < len2; ab++) {
        block = ref4[ab];
        block.x = mafs.roundn(block.x, gridsize);
        block.y = mafs.roundn(block.y, gridsize);
        block.w = mafs.roundn(block.w, gridsize);
        block.h = mafs.roundn(block.h, gridsize);
        results1.push(block.removesprite());
      }
      return results1;
    },
    "spawn some dudes": function() {
      scatterents(Jelly, 8);
      scatterents(Thug, 8);
      return scatterents(Robo, 4);
    }
  };

  actioncategories["debug"] = {
    "jelly stress test": function() {
      if (!confirm("r u sure")) {
        return;
      }
      return scatterents(Jelly, 32);
    }
  };

  mafs.roundn = function(num, base) {
    return Math.round(num / base) * base;
  };

  highlightoverlaps = function() {
    var alloverlaps, blox, flatlaps;
    blox = WORLD.bglayer;
    alloverlaps = blox.map(function(b) {
      return b.alloverlaps();
    });
    alloverlaps = alloverlaps.filter(function(i) {
      return i.length > 1;
    });
    flatlaps = _.flatten(alloverlaps);
    blox.forEach(function(b) {
      return b.HIGHLIGHT = void 0;
    });
    return flatlaps.forEach(function(b) {
      return b.HIGHLIGHT = true;
    });
  };

  allactions['highlight overlapping blocks'] = highlightoverlaps;

  objnames = function(objs) {
    return objs.map(function(obj) {
      return obj.constructor.name;
    });
  };

  allactions['generate entity list'] = function() {
    var entlist;
    entlist = $("<div>");
    body.append(entlist);
    return entlist.html(objnames(WORLD.spritelayer).join());
  };

  if (settings.devmode) {
    toolbar.append($(xmltag('em', void 0, 'actions: ')));
    for (k in allactions) {
      v = allactions[k];
      but = $(xmltag('button', void 0, k));
      but.click(v);
      toolbar.append(but);
    }
    for (ck in actioncategories) {
      cv = actioncategories[ck];
      tb = $(xmltag('details', {
        "class": 'toolbar'
      }));
      toolbar.append(tb);
      tb.append($(xmltag('summary', void 0, ck + " actions: ")));
      for (k in cv) {
        v = cv[k];
        but = $(xmltag('button', void 0, k));
        but.click(v);
        tb.append(but);
      }
    }
  }

  ORIGCLICKPOS = false;

  mousemiddledownhandler = function(e) {
    if (e.button !== 1) {
      return;
    }
    e.preventDefault();
    return ORIGCLICKPOS = V(e.pageX, e.pageY);
  };

  mousemiddleuphandler = function(e) {
    if (e.button !== 1) {
      return;
    }
    e.preventDefault();
    ORIGCLICKPOS = false;
    return camera.offset = V();
  };

  $(body).mousemove(function(e) {
    var p;
    p = smame(e);
    SCREENCURS = V(e.pageX, e.pageY);
    return CURSOR = p;
  });

  $(renderer.view).mousedown(mousemiddledownhandler);

  $(renderer.view).mouseup(mousemiddleuphandler);

  edithistory = {
    data: [],
    add: function(entry) {
      this.data.push(entry);
      return console.log(this.data);
    },
    undo: function() {
      var ent, lastevent, type;
      if (this.data.length === 0) {
        return;
      }
      lastevent = this.data.pop();
      type = lastevent[0], ent = lastevent[1];
      if (type === "remove") {
        console.log(ent);
        return WORLD.addblock(ent);
      }
    }
  };

  control.keyBindCharNamed('Backspace', 'undo', function() {
    return edithistory.undo();
  });

  bglayer_remove_block = function(ent) {
    edithistory.add(["remove", ent]);
    WORLD.bglayer = _.without(WORLD.bglayer, ent);
    return removesprite(ent);
  };

  tool_clickdelete = function(p) {
    var blox, ent;
    blox = blocksatpoint(WORLD.bglayer, p);
    if (blox.length > 0) {
      ent = blox[0];
      return bglayer_remove_block(ent);
    }
  };

  mouserightdownhandler = function(e) {
    var adjusted;
    if (e.button !== 2) {
      return;
    }
    e.preventDefault();
    return adjusted = adjustmouseevent(e);
  };

  $(renderer.view).mousedown(mouserightdownhandler);

  $(renderer.view).contextmenu(function() {
    return false;
  });

  getCursorBlocks = function() {
    return blocksatpoint(WORLD.bglayer, CURSOR);
  };

  _wheelin = function(offs) {
    var ab, bl, len2, ref4, results1, size;
    size = isholdingkey('z') ? 20 : 1;
    TILESELECT += offs * size;
    ref4 = getCursorBlocks();
    results1 = [];
    for (ab = 0, len2 = ref4.length; ab < len2; ab++) {
      bl = ref4[ab];
      bl.tile = TILESELECT;
      results1.push(bl.removesprite());
    }
    return results1;
  };

  wheel = {
    up: function(e) {
      return _wheelin(-1);
    },
    down: function(e) {
      return _wheelin(1);
    }
  };

  $(renderer.view).bind('wheel', function(e) {
    var delta;
    e.preventDefault();
    delta = e.originalEvent.deltaY;
    up = delta < 0;
    if (up) {
      wheel.up(e);
    }
    if (!up) {
      return wheel.down(e);
    }
  });

  _lastmodified = function(date) {
    return body.append(xmlwrap("footer", "last modified " + xmltag("time", {
      title: date,
      datetime: date
    }, jQuery.timeago(new Date(date)))));
  };

  _versionfoot = function(data, status, xhr) {
    return body.append(xmlwrap("footer", "version " + data));
  };

  $.ajax(THISFILE, {
    type: "HEAD",
    success: function(data, status, xhr) {
      return _lastmodified(xhr.getResponseHeader("Last-Modified"));
    }
  });

  $.ajax("./version.json", {
    success: _versionfoot
  });

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  spawnselection = $(xmltag('select'));

  for (classname in spawnables) {
    spawnselection.append($(xmltag('option', {
      value: classname
    }, classname)));
  }

  if (settings.devmode) {
    toolbar.append($(xmltag('em', void 0, "entity class:")));
    toolbar.append(spawnselection);
  }

  spawnselection.change(function(e) {
    return SPAWNTOOL.classname = $(this).val();
  });

  jame.WORLD = WORLD;

  jame.control = control;

  jame.stats = stats;

  jame.settings = settings;

  root.jame = jame;

  root.stage = stage;

  Block.prototype.allstrictoverlaps = function() {
    var blox;
    blox = WORLD.bglayer;
    return blox.filter((function(_this) {
      return function(otherblock) {
        return _this.strictoverlaps(otherblock);
      };
    })(this));
  };

  Block.prototype.alloverlaps = function() {
    var blox;
    blox = WORLD.bglayer;
    return blox.filter((function(_this) {
      return function(otherblock) {
        return _this.overlaps(otherblock);
      };
    })(this));
  };

  Block.prototype.equals = function(b) {
    return this.x = b.x && (this.y = b.y && (this.w = b.w && (this.h = b.h)));
  };

  jame.cleanobj = function(obj) {
    var val;
    arr = (function() {
      var results1;
      results1 = [];
      for (key in obj) {
        if (!hasProp.call(obj, key)) continue;
        val = obj[key];
        results1.push([key, val]);
      }
      return results1;
    })();
    return _.object(arr);
  };

}).call(this);

//# sourceMappingURL=platformindev.js.map
