// Generated by CoffeeScript 1.10.0
(function() {
  var AKA, BASETOOL, BLOCKCREATIONTOOL, BLOCKPAINT, Block, BoggleParticle, BugLady, BugMeter, Bullet, CARVER, COLLGRIDSIZE, CUE_DIALOGUE, CURRENT_LEVEL, CURSOR, Cloud, ControlObj, DEPRECATE, Damagebox, DoubleJumper, Energy, EnergyMeter, GenericSprite, Goal, Gold, Grid, HUDLAYER, Hero, HitboxRayIntersect, HurtWire, INIT, Lila, Line2d, MAXBUGSPEED, MLEFT, MOVEBLOCKTOOL, MOVETOOL, MRIGHT, MoneyMeter, MoveBlockTool, MoveTool, NOOPE, NOOPTOOL, ORIGCLICKPOS, OnewayBlock, PP, PchooParticle, Pickup, PlaceholderSprite, Platform, PowerSuit, Rect, Renderable, Robo, SCREENCURS, SPAWNERTOOL, SPAWNTOOL, Shieldbubble, Shrub, Smoochie, Spawner, TELEPORTTOOL, TEXBYNAME, THISFILE, TICKLOG, TILESELECT, TOOLTIP, TRIANGLETOOL, TextEnt, Thug, Tool, Turret, UNIONTOOL, V, VTOPP, WARN, WATERTOOL, WORLD, WORLDINIT, Water, World, XXXX, _CHARbindingnames, _DEFAULTHITBOXSIZE, _Rectmethods, __makebutton, __snap, _bind, _cycle, _dash, _demotick, _doc, _facing, _isholdingkey, _lastmodified, _loadcurrlevel, _maketiles, _ml, _move, _particle, _repdupes, _sidestep, _toggleFullScreen, _versionfoot, _wheelin, achieve, actioncategories, adjustedscreensize, adjustmouseevent, allactions, alltools, animate, arr, ascii, assert, audiobaseurl, audiocache, audiocachelength, availableactions, b2n, bglayer_remove_block, bindaction, bindingsDOM, bindingsDOMcontainer, blockcarve, blocksatpoint, blocktextures, blocktools, body, bottomcenter, boxesbounding, boxtouchingwall, browserprefix, bts, bugspeed, bugtextures, bugthrust, call, camera, cameraoffset, cameratool, cancelFullScreen, carveoutblock, changelayer, checkcolls, chtool, ck, classname, closestpoint, control, css, curraudiotrack, cv, dotfilt, down, drawhitboxes, drawsprite, edithistory, entcenter, entitycount, eventelement, firebullet, fixbox, fontmap, fontsrc, fonttexs, fpscounter, getCursorBlocks, get_sprites_of_class, getentsunderpoint, gettileoffs, highlightoverlaps, hitboxfilter, hitboxfilter_OLD, hitboxlayer, hz, infobox, initsprite, is_firefox, isfullscreen, isholdingbound, isholdingkey, j, jame, jump, k, key, kick, ladybug, launchFullScreen, left, len, level_files, linterpolate, load, loadblocks, loadent, loadents, loadlevel, loadlevelfile, loadspawners, mainloop, makebox, makebutton, maketablerow, maketiles, mktool, mouserightdownhandler, n, nextlevel, normalizekey, o, objnames, paintwheel, parentstage, pausefunc, pausescreen, pausetext, placeshrub, playsound, pointlisttoedges, preload, prevtool, punch, q, randpos, randposrel, randtri, readablebindings, record_l, record_s, recordinputs, ref, ref1, ref2, ref3, register_tool, relativetobox, removesprite, render, renderer, reserveKeyNamed, reservedkeys, reset_tick_stats, resetstage, restartlevel, results, right, root, save, scale, screensize, screensize_default, selectall, selectframe, setcursor, settings, settingsDOM, settingsDOMcontainer, skipframes, smame, snapmouseadjust, snapmouseadjust_always, snapmouseadjust_down, sourcebaseurl, spawnables, spawnselection, stage, stageremovesprite, stats, string_to_pixi, tb, tickno, ticktimes, tickwaitms, timecall, tmpcanvas, tmpcanvasjq, tmpinnerstage, tmpstage, toggleFullScreen, tool, tool_clickdelete, tool_index, toolbar, tt, unfuck, up, updateinfobox, updatesettingstable, v, wheel, xmlmultiwrap, xmlwrap, zoomwheel,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  THISFILE = "js/platformindev.js";

  settings = {
    gridsize: 16,
    fps: 30,
    drawsprites: true,
    slowmo: false,
    altcostume: true,
    muted: true,
    paused: false,
    volume: 0.2,
    variablejump: false,
    moonjump: false,
    NOSUBSCREENS: true,
    NOCOLLS: false,
    HD: false,
    scale: 1,
    recordingdemo: false,
    forcemove: false,
    aircontrol: true,
    devmode: false,
    hudscale: 2
  };

  settings.devmode = window.location.hash === "#dev";

  TILESELECT = 0;

  tickno = 0;

  MLEFT = 0;

  MRIGHT = 2;

  mafs.roundn = function(num, base) {
    return Math.round(num / base) * base;
  };

  linterpolate = function(a, b, frac) {
    return a + (b - a) * frac;
  };

  TEXBYNAME = function(imgsrc) {
    return PIXI.Texture.fromImage(sourcebaseurl + imgsrc);
  };

  assert = function(expr, msg) {
    if (!expr) {
      console.log(Error);
      throw msg || "assert failed!";
    }
  };

  WARN = function(msg) {
    console.log(msg);
  };

  DEPRECATE = function() {
    throw "deprecated";
  };

  b2n = function(bool) {
    if (bool) {
      return 1;
    } else {
      return 0;
    }
  };

  arr = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return args;
  };

  call = function(func) {
    return func();
  };

  xmlwrap = function(tagname, body) {
    return xmltag(tagname, void 0, body);
  };

  xmlmultiwrap = function(tagname, bodyarr) {
    var item;
    return ((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = bodyarr.length; j < len; j++) {
        item = bodyarr[j];
        results.push(xmlwrap(tagname, item));
      }
      return results;
    })()).join("");
  };

  browserprefix = '-webkit-';

  is_firefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

  if (is_firefox) {
    browserprefix = '-moz-';
  }

  stats = {
    collisionchecks: 0
  };

  V = function(x, y) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    return new V2d(x, y);
  };

  screensize_default = V(960, 540);

  screensize = screensize_default.nadd(0);

  sourcebaseurl = "./sprites/";

  audiobaseurl = "./audio/";

  preload = function(str) {
    return PIXI.loader.add(sourcebaseurl + str).load();
  };

  XXXX = function(tilesrc, tileW, tileH, cols, rows) {
    var _tileset, numtiles, pxSheetH, pxSheetW, rowcount, tilesize, tsw;
    preload(tilesrc);
    pxSheetW = tileW * cols;
    pxSheetH = tileH * rows;
    _tileset = TEXBYNAME(tilesrc);
    _tileset.baseTexture.width = pxSheetW;
    _tileset.baseTexture.height = pxSheetH;
    tsw = 20;
    tilesize = 16;
    rowcount = 8;
    numtiles = rows * cols;
    return _maketiles(_tileset, tileW, tileH, cols, rows);
  };

  gettileoffs = function(n, tsw, tilesize) {
    return V(n % tsw, Math.floor(n / tsw));
  };

  maketiles = function(tileset, tsize, cols, numtiles) {
    var rows;
    rows = numtiles / cols;
    return _maketiles(tileset, tsize, tsize, cols, rows);
  };

  _maketiles = function(tileset, tileW, tileH, cols, rows) {
    var i, j, numtiles, range, rec, results, tex, texs, x, y;
    numtiles = cols * rows;
    range = (function() {
      results = [];
      for (var j = 0; 0 <= numtiles ? j < numtiles : j > numtiles; 0 <= numtiles ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this);
    return texs = (function() {
      var len, o, ref, results1;
      results1 = [];
      for (o = 0, len = range.length; o < len; o++) {
        i = range[o];
        tex = new PIXI.Texture(tileset);
        ref = gettileoffs(i, cols), x = ref.x, y = ref.y;
        rec = new PIXI.Rectangle(x * tileW, y * tileH, tileW, tileH);
        tex.frame = rec;
        results1.push(tex);
      }
      return results1;
    })();
  };

  fontsrc = "font-hand-white-12x16.png";

  fonttexs = XXXX(fontsrc, 12, 16, 16, 6);

  blocktextures = (function() {
    var numtiles, rowcount, tileset, tilesize, tilesrc, tsw;
    tilesrc = "metroid like.png";
    preload(tilesrc);
    tileset = TEXBYNAME(tilesrc);
    tileset.baseTexture.width = 320;
    tileset.baseTexture.height = 256;
    console.log(tileset);
    tsw = 20;
    tilesize = 16;
    rowcount = 8;
    numtiles = rowcount * tsw;
    return maketiles(tileset, tilesize, tsw, numtiles);
  })();

  bts = TEXBYNAME("bugrunhd.png");

  bts.baseTexture.width = 310;

  bts.baseTexture.height = 47;

  bugtextures = maketiles(bts, 21, 4, 4);

  Line2d = mafs.Line2d;

  HitboxRayIntersect = mafs.HitboxRayIntersect;

  pointlisttoedges = mafs.pointlisttoedges;

  body = $("body");

  PP = function(x, y) {
    return new PIXI.Point(x, y);
  };

  VTOPP = function(v) {
    return PP(v.x, v.y);
  };

  CURSOR = V(0, 0);

  SCREENCURS = V(0, 0);

  audiocache = [];

  audiocachelength = 10;

  for (n = j = 0, ref = audiocachelength; 0 <= ref ? j < ref : j > ref; n = 0 <= ref ? ++j : --j) {
    audiocache[n] = new Audio();
  }

  curraudiotrack = 0;

  playsound = function(src, volume) {
    var snd;
    curraudiotrack++;
    curraudiotrack = curraudiotrack % audiocachelength;
    if (settings.muted) {
      return;
    }
    snd = audiocache[curraudiotrack];
    snd.src = audiobaseurl + src;
    snd.volume = volume || settings.volume;
    return snd.play();
  };

  parentstage = new PIXI.Stage(0x66FF99);

  dotfilt = new PIXI.filters.DotScreenFilter();

  dotfilt.scale = 6;

  stage = new PIXI.Container;

  parentstage.addChild(stage);

  hitboxlayer = new PIXI.Container;

  stage.addChild(hitboxlayer);

  resetstage = function() {
    parentstage.removeChild(stage);
    stage = new PIXI.Container;
    parentstage.addChild(stage);
    hitboxlayer = new PIXI.Container;
    return stage.addChild(hitboxlayer);
  };

  HUDLAYER = new PIXI.Container;

  parentstage.addChild(HUDLAYER);

  renderer = new PIXI.CanvasRenderer(screensize.x, screensize.y);

  pausescreen = new PIXI.Graphics();

  pausescreen.beginFill(0x000000);

  pausescreen.drawRect(0, 0, screensize.x, screensize.y);

  pausescreen.alpha = 0.5;

  pausetext = new PIXI.Text("PAUSED", {
    font: "32px Arial",
    fill: "white",
    strokeThickness: 8,
    stroke: 'red'
  });

  pausetext.position = VTOPP(screensize.ndiv(2));

  pausetext.anchor = PP(1 / 2, 1);

  pausescreen.addChild(pausetext);

  pausetext = new PIXI.Text("GO GET SOME SNACKS\nPERHAPS A CARBONATED SODA", {
    font: "16px Arial",
    fill: "white"
  });

  pausetext.position = VTOPP(screensize.ndiv(2).vadd(V(0, 64)));

  pausetext.anchor = PP(1 / 2, 0);

  pausescreen.addChild(pausetext);

  ascii = String.fromCharCode.apply(this, (function() {
    results = [];
    for (o = 32; o <= 126; o++){ results.push(o); }
    return results;
  }).apply(this));

  fontmap = ascii;

  string_to_pixi = function(text) {
    var char, glyph, i, len, offs, q, spr, textcontainer, wspacing;
    if (text == null) {
      text = "I AM ERROR";
    }
    textcontainer = new PIXI.Graphics();
    for (i = q = 0, len = text.length; q < len; i = ++q) {
      char = text[i];
      offs = V(0, 0);
      wspacing = 16;
      glyph = fonttexs[fontmap.indexOf(char)];
      spr = new PIXI.Sprite(glyph);
      spr.tint = 0xFF0000;
      spr.anchor = PP(1 / 2, 1 / 2);
      spr.position = VTOPP(offs.vadd(V(i * wspacing, 0)));
      spr.scale = PP(2, 2);
      textcontainer.addChild(spr);
    }
    return textcontainer;
  };

  body.append(renderer.view);

  $(renderer.view).attr({
    tabindex: 0
  });

  scale = 1;

  tmpstage = new PIXI.Container();

  tmpinnerstage = new PIXI.Container();

  tmpstage.addChild(tmpinnerstage);

  animate = function() {
    var cam;
    camera.tick();
    render();
    cam = cameraoffset().nmul(-scale);
    stage.position = VTOPP(cam);
    stage.scale = PP(scale, scale);
    renderer.render(parentstage);
    return requestAnimationFrame(animate);
  };

  achieve = function(title) {
    return WARN("there's nothing to achieve");
  };

  Renderable = (function() {
    function Renderable() {
      this.pos = V();
    }

    return Renderable;

  })();

  Renderable.prototype.hassprite = function() {
    return typeof this._pixisprite !== "undefined";
  };

  Renderable.prototype.removesprite = function() {
    return removesprite(this);
  };

  GenericSprite = (function(superClass) {
    extend(GenericSprite, superClass);

    function GenericSprite(pos1, src1) {
      this.pos = pos1 != null ? pos1 : V();
      this.src = src1;
      this.vel = V();
    }

    GenericSprite.prototype.render = function() {
      var anchor, box, flip, pos;
      anchor = this.anchor || V(0, 0);
      flip = !this.facingleft;
      box = this.gethitbox();
      pos = relativetobox(box, anchor);
      return drawsprite(this, this.src, pos, flip, anchor);
    };

    return GenericSprite;

  })(Renderable);

  GenericSprite.prototype.cleanup = function() {
    return removesprite(this);
  };

  TextEnt = (function(superClass) {
    extend(TextEnt, superClass);

    function TextEnt(text1) {
      this.text = text1;
      TextEnt.__super__.constructor.call(this);
      this.age = 0;
      this.targetpos = this.pos;
    }

    TextEnt.prototype.initsprite = function() {
      var textcontainer;
      textcontainer = string_to_pixi(this.text);
      this._pixisprite = textcontainer;
      return stage.addChild(this._pixisprite);
    };

    TextEnt.prototype.render = function() {
      var sprit;
      if (!this.hassprite()) {
        this.initsprite();
      }
      if (this.age < 20) {
        this._pixisprite.alpha = Math.max(0, this.age / 20);
      }
      if (this.age > 180) {
        this._pixisprite.alpha = 1 - (this.age - 180) / 20;
      }
      if (this._pixisprite != null) {
        sprit = this._pixisprite;
        sprit.position = VTOPP(this.pos);
      }
    };

    TextEnt.prototype.tick = function() {
      this.age++;
      this.pos.y = linterpolate(this.pos.y, this.targetpos.y, 1 / 2);
      if ((this.age % 60) === 0) {
        this.targetpos.y -= 32;
      }
      if (this.age > 200) {
        return this.KILLME = true;
      }
    };

    return TextEnt;

  })(GenericSprite);

  CUE_DIALOGUE = function(location) {
    var len, line, lines, offs, q, results1, te;
    CUE_DIALOGUE = function() {};
    lines = ["oh hai marl", "this is dialogue", "anyway how's your sex life", "what a story marl"];
    offs = 0;
    n = 0;
    results1 = [];
    for (q = 0, len = lines.length; q < len; q++) {
      line = lines[q];
      te = new TextEnt(line);
      WORLD.entAdd(te);
      te.targetpos = location.nadd(0);
      te.targetpos.y += offs;
      te.age = n * -60;
      offs += 32;
      results1.push(n += 1);
    }
    return results1;
  };

  GenericSprite.prototype.load = function(obj) {
    if (obj.pos != null) {
      return _.extend(this.pos, obj.pos);
    }
  };

  PlaceholderSprite = (function(superClass) {
    extend(PlaceholderSprite, superClass);

    function PlaceholderSprite(pos1) {
      this.pos = pos1;
      PlaceholderSprite.__super__.constructor.call(this, this.pos);
      this.label = 'a thing';
      this.anchor = V(0, 0);
    }

    return PlaceholderSprite;

  })(GenericSprite);

  PlaceholderSprite.prototype.render = function() {
    var box, sprit, txt;
    if (this._pixisprite != null) {
      sprit = this._pixisprite;
      sprit.position = VTOPP(this.pos);
      return;
    }
    txt = new PIXI.Text(this.label, {
      font: "12px Arial",
      fill: "black"
    });
    txt.anchor = VTOPP(this.anchor);
    sprit = new PIXI.Graphics();
    sprit.beginFill(0xFF00FF);
    sprit.pivot = VTOPP(V(0, 32));
    box = this.gethitbox();
    sprit.position = VTOPP(this.pos);
    sprit.drawRect(0, 0, box.w, box.h);
    sprit.alpha = 0.9;
    sprit.addChild(txt);
    stage.addChild(sprit);
    return this._pixisprite = sprit;
  };

  _DEFAULTHITBOXSIZE = V(32, 32);

  GenericSprite.prototype.gethitbox = function() {
    var anchor, size;
    size = this.size || _DEFAULTHITBOXSIZE;
    anchor = this.anchor || V(1 / 2, 1 / 2);
    this.hitboxcache = makebox(this.pos, size, anchor);
    return this.hitboxcache;
  };

  GenericSprite.prototype.updatehitbox = function() {
    var anchor, h, ref1, size, w, x, y;
    size = this.size || _DEFAULTHITBOXSIZE;
    anchor = this.anchor || V(1 / 2, 1 / 2);
    if (this.hitboxcache != null) {
      ref1 = fixbox(this.pos, size, anchor), x = ref1[0], y = ref1[1], w = ref1[2], h = ref1[3];
      this.hitboxcache.x = x;
      this.hitboxcache.y = y;
      this.hitboxcache.w = w;
      this.hitboxcache.h = h;
    }
    return this.hitboxcache;
  };

  fixbox = function(position, dimensions, anchor) {
    var truepos;
    truepos = position.vsub(dimensions.vmul(anchor));
    return [truepos.x, truepos.y, dimensions.x, dimensions.y];
  };

  entitycount = function(classtype) {
    var ents;
    ents = WORLD.spritelayer.filter(function(sprite) {
      return sprite instanceof classtype;
    });
    return ents.length;
  };

  GenericSprite.prototype.gravitate = function() {
    if (!this.touchingground()) {
      return this.vel.y++;
    }
  };

  Pickup = (function(superClass) {
    extend(Pickup, superClass);

    function Pickup(pos1) {
      this.pos = pos1 != null ? pos1 : V();
      this.vel = V();
      this.src = "energy1.png";
    }

    return Pickup;

  })(GenericSprite);

  Pickup.prototype.collide = function(otherent) {
    if (otherent instanceof BugLady) {
      return this.pickedup(otherent);
    }
  };

  Pickup.prototype.pickedup = function(otherent) {
    playsound('boip.wav');
    return this.KILLME = true;
  };

  Energy = (function(superClass) {
    extend(Energy, superClass);

    function Energy(pos1) {
      this.pos = pos1 != null ? pos1 : V();
      this.vel = V();
      this.src = "energy1.png";
    }

    return Energy;

  })(Pickup);

  Energy.prototype.getsprite = function() {
    var framelist;
    framelist = [1, 2, 3, 4, 5, 6].map(function(n) {
      return "energy" + n + ".png";
    });
    return this.src = selectframe(framelist, 4);
  };

  Energy.prototype.tick = function() {
    Energy.__super__.tick.call(this);
    return this.getsprite();
  };

  Energy.prototype.pickedup = function(otherent) {
    Energy.__super__.pickedup.call(this);
    return otherent.energy += 1;
  };

  Gold = (function(superClass) {
    extend(Gold, superClass);

    function Gold(pos1) {
      this.pos = pos1 != null ? pos1 : V();
      this.vel = V();
      this.src = "crown.png";
    }

    return Gold;

  })(Pickup);

  Gold.prototype.getsprite = function() {};

  Gold.prototype.pickedup = function(otherent) {
    Gold.__super__.pickedup.call(this);
    return otherent.score += 1;
  };

  relativetobox = function(box, anchor) {
    var pos, size;
    pos = V(box.x, box.y);
    size = V(box.w, box.h);
    pos = pos.vadd(size.vmul(anchor));
    return pos;
  };

  Thug = (function(superClass) {
    extend(Thug, superClass);

    function Thug(pos1) {
      this.pos = pos1 != null ? pos1 : V();
      this.lifetime = -1;
      this.vel = V();
      this.src = 'bugthug.png';
      this.facingleft = true;
      this.health = 3;
    }

    return Thug;

  })(GenericSprite);

  bottomcenter = V(1 / 2, 1);

  Thug.prototype.size = V(24, 64 + 16);

  Thug.prototype.anchor = bottomcenter;

  Thug.prototype.tick = function() {
    this.physmove();
    return this.getsprite();
  };

  Thug.prototype.getsprite = function() {
    if (this.lifetime <= 0) {
      this.src = 'bugthug.png';
    }
    if (this.health <= 0) {
      this.src = 'thugded.png';
    }
    if (this.lifetime > 0) {
      this.lifetime--;
      return this.src = "bugthugoof.png";
    }
  };

  Thug.prototype.collide = function(otherent) {
    var ref1, ref2, ref3;
    if (otherent instanceof BoggleParticle) {
      this.vel = this.vel.vadd(otherent.vel.nmul(1 / 8));
    }
    if ((((ref1 = otherent.timers) != null ? ref1.attack : void 0) != null) && ((ref2 = otherent.timers) != null ? ref2.attack : void 0) > 0 && this.lifetime <= 0) {
      this.vel = this.vel.vadd(otherent.vel.nmul(1 / 2));
      this.gethitby(otherent);
    }
    if (this.health <= 0) {
      return;
    }
    if (otherent instanceof Hero && ((ref3 = otherent.timers) != null ? ref3.invincible : void 0) === 0) {
      playsound('excardon.wav');
      return otherent.flinch();
    }
  };

  Thug.prototype.gethitby = function(otherent) {
    var dir;
    this.vel.y += otherent.vel.y;
    dir = _facing(otherent);
    this.vel.x += dir * 1;
    this.lifetime = 10;
    return this.health -= 1;
  };

  Lila = (function(superClass) {
    extend(Lila, superClass);

    function Lila() {
      return Lila.__super__.constructor.apply(this, arguments);
    }

    return Lila;

  })(Thug);

  Robo = (function(superClass) {
    extend(Robo, superClass);

    function Robo() {
      return Robo.__super__.constructor.apply(this, arguments);
    }

    return Robo;

  })(Thug);

  Lila.prototype.scampersubroutine = Robo.prototype.scampersubroutine = function() {
    if (!this.scampering && Math.random() < 1 / 10) {
      this.scampering = true;
    }
    if (this.scampering && Math.random() < 1 / 10) {
      this.scampering = false;
    }
    if (this.scampering && Math.abs(this.vel.x) < 3) {
      this.vel.x += this.facingleft ? -this.scamperspeed : this.scamperspeed;
    }
    if (!this.scampering && Math.random() < 1 / 20) {
      return this.facingleft = !this.facingleft;
    }
  };

  Lila.prototype.tick = function() {
    if (this.kisstimeout > 0) {
      this.kisstimeout--;
    }
    Lila.__super__.tick.call(this);
    if (this.kisstimeout > 50) {
      return;
    }
    this.scamperspeed = 2;
    return this.scampersubroutine();
  };

  Robo.prototype.visioncheck = function() {
    var CENTER, dim, visionarea;
    CENTER = V(1 / 2, 1 / 2);
    dim = 64 * 4;
    visionarea = makebox(this.pos, V(dim, dim), CENTER);
    if (this.angerlevel == null) {
      this.angerlevel = 0;
    }
    if (visionarea.containspoint(ladybug.pos)) {
      this.angerlevel++;
    } else if (this.angerlevel > 0) {
      this.angerlevel--;
    }
    return this.angry = this.angerlevel > 40;
  };

  Robo.prototype.tick = function() {
    var isdead;
    Robo.__super__.tick.call(this);
    isdead = this.health <= 0;
    this.state = this.scampering && this.angry ? "attacking" : "idle";
    if (isdead) {
      this.scampering = false;
      return;
    }
    this.visioncheck();
    this.scamperspeed = 1;
    if (this.angry) {
      this.scamperspeed = 6;
    }
    if (this.angry) {
      this.facingleft = ladybug.pos.x < this.pos.x;
    }
    return this.scampersubroutine();
  };

  Turret = (function(superClass) {
    extend(Turret, superClass);

    function Turret() {
      return Turret.__super__.constructor.apply(this, arguments);
    }

    return Turret;

  })(Thug);

  Turret.prototype.visioncheck = function() {
    var CENTER, dim, visionarea;
    CENTER = V(1 / 2, 1 / 2);
    dim = 64 * 4;
    visionarea = makebox(this.pos, V(dim, dim), CENTER);
    return this.angry = visionarea.containspoint(ladybug.pos);
  };

  Turret.prototype.tick = function() {
    this.visioncheck();
    if (this.angry && tickno % 10 === 0) {
      return firebullet(this);
    }
  };

  selectframe = function(framelist, framewait) {
    var framechoice, totalframes;
    totalframes = framelist.length;
    framechoice = Math.floor(tickno / framewait) % totalframes;
    return framelist[framechoice];
  };

  Lila.prototype.getsprite = function() {
    var framelist, framewait, idlecycle, scampercycle;
    idlecycle = ['lilaidle1.png', 'lilaidle2.png'];
    scampercycle = (function() {
      var q, results1;
      results1 = [];
      for (n = q = 1; q <= 4; n = ++q) {
        results1.push("lilascamper" + n + ".png");
      }
      return results1;
    })();
    framewait = 4;
    framelist = idlecycle;
    if (!this.scampering) {
      framewait = 20;
    }
    if (this.scampering) {
      framelist = scampercycle;
    }
    if (this.kisstimeout > 90) {
      framelist = ["lilakiss.png"];
    }
    return this.src = selectframe(framelist, framewait);
  };

  _cycle = function(name, range) {
    return range.map(function(n) {
      return "" + name + n + ".png";
    });
  };

  Robo.prototype.getsprite = function() {
    var framelist, framewait, idlecycle, scampercycle;
    idlecycle = ['robocalm1.png'];
    scampercycle = _cycle("robocalm", [1, 2]);
    if (this.angerlevel > 10) {
      idlecycle = _cycle("roboroll", [1, 2]);
      scampercycle = _cycle("roboroll", [1, 2]);
    }
    if (this.angry) {
      idlecycle = _cycle("roborage", [1, 2]);
      scampercycle = _cycle("roborage", [2, 3, 4]);
    }
    framelist = idlecycle;
    if (this.scampering) {
      framelist = scampercycle;
    }
    if (this.lifetime > 0) {
      this.lifetime--;
      framelist = ["robohurt.png"];
    }
    if (this.health <= 0) {
      framelist = ["robobody.png"];
    }
    if (this.health <= 0 && this.lifetime === 0 && this.touchingground()) {
      framelist = ["roboded.png"];
    }
    framewait = 4;
    return this.src = selectframe(framelist, framewait);
  };

  Robo.prototype.collide = function(otherent) {
    if (otherent instanceof Hero && this.state === "attacking") {
      return otherent.takedamage();
    }
  };

  Lila.prototype.collide = function(otherent) {
    if (otherent instanceof Hero) {
      CUE_DIALOGUE(this.pos);
    }
    if (otherent instanceof BoggleParticle) {
      if (!(this.kisstimeout > 0)) {
        ladybug.heal();
        WORLD.entAdd(new Smoochie(this.pos));
      }
      return this.kisstimeout = 1;
    }
  };

  BoggleParticle = (function(superClass) {
    extend(BoggleParticle, superClass);

    function BoggleParticle(pos1) {
      this.pos = pos1 != null ? pos1 : V();
      this.vel = mafs.randvec().norm();
      this.src = 'huh.png';
      this.life = 50;
      this.anchor = V(0, 0);
    }

    BoggleParticle.prototype.tick = function() {
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      this.pos = this.pos.vadd(this.vel);
      this.vel = this.vel.vadd(mafs.randvec().norm().ndiv(8));
      if (this.life <= 10) {
        return this._pixisprite.alpha = this.life / 10;
      }
    };

    return BoggleParticle;

  })(GenericSprite);

  BoggleParticle.prototype.render = function() {
    return drawsprite(this, 'emily.png', this.pos, false);
  };

  Smoochie = (function(superClass) {
    extend(Smoochie, superClass);

    function Smoochie(pos1) {
      this.pos = pos1;
      this.anchor = V(1 / 2, 1);
      this.vel = mafs.randvec().norm();
      this.src = 'kissparticle1.png';
      this.life = 50;
    }

    Smoochie.prototype.tick = function() {
      var dif, guipos;
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      guipos = cameraoffset().nadd(32);
      dif = guipos.vsub(this.pos);
      if (this.life < 10) {
        this.vel = this.vel.vadd(dif.ndiv(64));
      }
      this.pos = this.pos.vadd(this.vel);
      this.vel = this.vel.vadd(mafs.randvec().norm().ndiv(8));
      return this.vel = this.vel.vadd(V(0, -1 / 8));
    };

    Smoochie.prototype.render = function() {
      Smoochie.__super__.render.call(this);
      this.src = this.getsprite();
      return this._pixisprite.rotation = mafs.degstorads(Math.cos(this.life / 100) * 10);
    };

    return Smoochie;

  })(GenericSprite);

  Smoochie.prototype.getsprite = function() {
    var framechoice, framelist, framewait;
    framewait = 16;
    framelist = [3, 2, 1].map(function(n) {
      return "kissparticle" + n + ".png";
    });
    framechoice = Math.floor(this.life / framewait);
    return framelist[framechoice];
  };

  PchooParticle = (function(superClass) {
    extend(PchooParticle, superClass);

    function PchooParticle(pos1) {
      this.pos = pos1 != null ? pos1 : V();
      this.vel = ladybug.vel.nmul(-1).norm();
      this.life = 20;
      this.src = 'energy4.png';
      this.anchor = V(1 / 2, 1 / 2);
    }

    PchooParticle.prototype.tick = function() {
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      this.pos = this.pos.vadd(this.vel);
      return this.vel = this.vel.vadd(mafs.randvec().norm().ndiv(64));
    };

    PchooParticle.prototype.render = function() {
      drawsprite(this, this.src, this.pos, false, this.anchor);
      this._pixisprite.alpha = 0.25 + this.life / 40;
      return this._pixisprite.rotation = -Math.atan2(this.vel.x, this.vel.y);
    };

    return PchooParticle;

  })(GenericSprite);

  Bullet = (function(superClass) {
    extend(Bullet, superClass);

    function Bullet(pos1) {
      this.pos = pos1 != null ? pos1 : V();
      this.owner = void 0;
      this.vel = V(8, 0);
      this.life = 10;
      this.src = 'particlepunch.png';
      this.anchor = V(1 / 2, 1 / 2);
    }

    Bullet.prototype.tick = function() {
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      this.pos = this.pos.vadd(this.vel);
      return this.vel = this.vel.vadd(mafs.randvec().norm().ndiv(64));
    };

    Bullet.prototype.render = function() {
      var flip;
      flip = this.vel.x < 0;
      drawsprite(this, this.src, this.pos, flip, this.anchor);
      return this._pixisprite.alpha = 0.8;
    };

    return Bullet;

  })(GenericSprite);

  Shieldbubble = (function(superClass) {
    extend(Shieldbubble, superClass);

    function Shieldbubble(pos1) {
      this.pos = pos1 != null ? pos1 : V();
      this.owner = ladybug;
      this.src = 'bubble.png';
      this.anchor = V(1 / 2, 1);
      this.vel = V();
    }

    Shieldbubble.prototype.tick = function() {
      this.pos = this.owner.pos;
      if (this._pixisprite) {
        return this._pixisprite.alpha = 1 / 2;
      }
    };

    return Shieldbubble;

  })(GenericSprite);

  Bullet.prototype.collide = function(otherent) {
    if ((otherent.health != null) && otherent !== this.owner) {
      if (typeof otherent.gethitby === "function") {
        otherent.gethitby(this.owner);
      }
      return this.KILLME = true;
    }
  };

  isholdingkey = function(key) {
    key = key.toUpperCase().charCodeAt(0);
    return indexOf.call(control.heldkeys, key) >= 0;
  };

  _isholdingkey = function(keyname) {
    var ref1;
    return ref1 = keyCharToCode[keyname], indexOf.call(control.heldkeys, ref1) >= 0;
  };

  isholdingbound = function(name) {
    var keys;
    keys = control.heldkeys.map(function(key) {
      return control.bindingnames[key];
    });
    return indexOf.call(keys, name) >= 0;
  };

  Hero = (function(superClass) {
    extend(Hero, superClass);

    function Hero() {
      Hero.__super__.constructor.call(this);
      this.jumping = false;
      this.attacking = false;
      this.timers = {
        attack: 0,
        stun: 0,
        mildstun: 0,
        invincible: 0
      };
      this.health = 3;
      this.energy = 0;
      this.score = 0;
      this.facingleft = false;
      this.anchor = V(1 / 2, 1);
    }

    return Hero;

  })(GenericSprite);

  BugLady = (function(superClass) {
    extend(BugLady, superClass);

    function BugLady() {
      BugLady.__super__.constructor.call(this);
      this.controls = {};
      this.controls.tapstatus = {};
      this.state = "normal";
      this.state_frame = 0;
    }

    BugLady.prototype.state_call = function() {
      var ref1;
      if ((ref1 = this.state_functions[this.state]) != null) {
        ref1.call(this);
      }
      return this.state_frame++;
    };

    BugLady.prototype.state_set = function(statename) {
      this.state_frame = 0;
      return this.state = statename;
    };

    BugLady.prototype.state_functions = {
      recover: function() {
        if (this.state_frame > 4) {
          return this.state_set("normal");
        }
      },
      punch: function() {
        this.vel = V(0, 8);
        this.state_punch();
        if (this.state_frame > 4) {
          return this.state_set("recover");
        }
      },
      kick: function() {
        if (this.state_frame === 0) {
          this.vel = V(this.dirfaced() * 4, -1);
        }
        if (this.state_frame > 4) {
          return this.state_set("recover");
        }
      },
      roundhouse: function() {
        if (this.state_frame === 0) {
          this.vel = V(this.dirfaced() * 4, -8);
        }
        if (this.state_frame > 4) {
          return this.state_set("recover");
        }
      }
    };

    return BugLady;

  })(Hero);

  BugLady.prototype.heal = function() {
    return this.health = 3;
  };

  BugLady.prototype.respawn = function() {
    this.pos = V();
    this.vel = V();
    return this.heal();
  };

  BugLady.prototype.flinch = function() {
    var knockbackDir;
    knockbackDir = this.facingleft || -1;
    this.vel.x *= 1 / 2;
    this.vel.x += knockbackDir * 8;
    this.timers.invincible = 20;
    return this.timers.flinching = 20;
  };

  Hero.prototype.gethitby = function(otherent) {
    return this.takedamage();
  };

  BugLady.prototype.takedamage = function() {
    if (this.timers.invincible > 0) {
      return;
    }
    if (this.timers.stun <= 0) {
      this.flinch();
    }
    this.health -= 1;
    if (this.health <= 0) {
      return this.kill();
    }
  };

  entcenter = function(ent) {
    var hb;
    hb = ent.gethitbox();
    return V(hb.x + hb.w / 2, hb.y + hb.h / 2);
  };

  GenericSprite.prototype.blockcollisions = function() {
    var box, candidates;
    box = this.gethitbox();
    candidates = hitboxfilter(box, WORLD.bglayer);
    candidates.forEach((function(_this) {
      return function(candidate) {
        if (_this.gethitbox().bottom() >= candidate.top()) {
          _this.pos.y = candidate.y;
          return _this.vel.y = 0;
        }
      };
    })(this));
    if (candidates.length > 0 && this.vel.y < 0) {
      return this.vel.y = 0;
    }
  };

  BugLady.prototype.blockcollisions = function() {
    var box, candidates, platforms;
    box = this.fallbox();
    platforms = hitboxfilter(box, WORLD.BOXCACHE);
    if (platforms.length > 0) {
      WARN("stuck in wall");
      this.pos.y -= 2;
    }
    candidates = hitboxfilter(box, WORLD.bglayer);
    return candidates.forEach((function(_this) {
      return function(candidate) {
        var cond, jumpthroughable;
        if (_this.gethitbox().bottom() <= candidate.top()) {
          _this.pos.y = candidate.y;
          _this.vel.y = 0;
          if ((!_this.timers.fightstance) && !_this.timers.mildstun) {
            _this.timers.mildstun = 4;
          }
        }
        jumpthroughable = candidate instanceof OnewayBlock;
        cond = box.strictoverlaps(candidate);
        if (_this.vel.y < 0 && !jumpthroughable && box.top() > candidate.top()) {
          return _this.vel.y = 0;
        }
      };
    })(this));
  };

  closestpoint = function(p, pointarr) {
    var closest, len, point, q;
    closest = pointarr[0];
    for (q = 0, len = pointarr.length; q < len; q++) {
      point = pointarr[q];
      if (closest.dist(p) > point.dist(p)) {
        closest = point;
      }
    }
    return closest;
  };

  Hero.prototype.checkcontrols = function() {};

  BugLady.prototype.checkcontrols = function() {
    if (this !== ladybug) {
      return;
    }
    this.holdingboggle = isholdingbound('boggle');
    this.holdingjump = isholdingbound('jump');
    if (!this.holdingjump) {
      this.controls.tapstatus.jump = true;
    }
    return this.controls.crouch = isholdingbound('down');
  };

  BugLady.prototype.cancelattack = function() {
    this.timers.attack = 0;
    return this.attacking = false;
  };

  Hero.prototype.outofbounds = function() {
    return this.pos.y > 6400;
  };

  BugLady.prototype.kill = function() {
    return this.respawn();
  };

  BugLady.prototype.timeoutcheck = function() {
    var k, ref1, v;
    ref1 = this.timers;
    for (k in ref1) {
      v = ref1[k];
      if (v > 0) {
        this.timers[k]--;
      }
    }
    if (this.timers.powerup > 0) {
      this.vel = V2d.zero();
    }
    if (this.timers.stun > 0) {
      achieve("fall");
      this.vel = V2d.zero();
    }
    if (this.timers.invincible === 0 && this.shield) {
      this.shield.KILLME = true;
      return this.shield = null;
    }
  };

  BugLady.prototype.state_punch = function() {
    if (this.attacking && this.punching) {
      if (entitycount(Bullet) < 3 && this.energy > 0) {
        this.energy -= 0.1;
        return firebullet(this);
      }
    }
  };

  BugLady.prototype.attackchecks = function() {};

  NOOPE = function() {
    var dashing, down, forward, heading, nent, up;
    this.attacking = this.timers.attack > 0;
    heading = _facing(this);
    dashing = Math.abs(this.vel.x) > 11;
    if (this.attacking && dashing) {
      this.vel.x *= 1 / 2;
      this.timers.uppercut = 10;
    }
    forward = isholdingbound('left') || isholdingbound('right');
    up = isholdingbound('up');
    down = isholdingbound('down');
    if (this.attacking && up) {
      this.vel.x *= 1 / 2;
      this.timers.uppercut = 10;
    }
    if (this.attacking && this.kicking && down) {
      this.timers.slide = 10;
      this.vel = V(heading * 10, 0);
    }
    if (this.attacking && this.kicking && forward) {
      this.vel = V(heading * 10, 0);
    }
    if (this.attacking && this.kicking && up && !this.timers.roundhouse) {
      this.timers.roundhouse = 20;
    }
    if (this.state === "punching") {
      this.state_punch();
    }
    if (this.attacking && !this.timers.hitboxery) {
      this.timers.hitboxery = 10;
      nent = new Damagebox(this);
      return WORLD.entAdd(nent);
    }
  };

  Damagebox = (function(superClass) {
    extend(Damagebox, superClass);

    function Damagebox(owner) {
      this.owner = owner;
      this.pos = this.owner.pos;
      this.life = 15;
      this.anchor = V(0.5, 2);
      this.size = V(64, 16);
    }

    Damagebox.prototype.tick = function() {
      if (this.life-- <= 0) {
        return this.KILLME = true;
      }
    };

    Damagebox.prototype.gethitbox = GenericSprite.prototype.gethitbox;

    return Damagebox;

  })(Renderable);

  firebullet = function(ent) {
    var CENTER, bullet, heading;
    heading = _facing(ent);
    bullet = new Bullet();
    bullet.owner = ent;
    bullet.vel = V(heading * 32, 0);
    bullet.life = 2;
    CENTER = V(1 / 2, 1 / 2);
    bullet.pos = relativetobox(ent.gethitbox(), CENTER);
    WORLD.entAdd(bullet);
    return bullet;
  };

  get_sprites_of_class = function(classtype) {
    var ents;
    return ents = WORLD.spritelayer.filter(function(sprite) {
      return sprite instanceof classtype;
    });
  };

  BugLady.prototype.tick = function() {
    TICKLOG(this.state);
    TICKLOG(xmlwrap("table", xmlmultiwrap("td", [this.vel.x, this.vel.y])));
    TICKLOG(xmlwrap("table", xmlmultiwrap("td", [this.pos.x, this.pos.y])));
    this.state_call();
    this.timeoutcheck();
    return this.movetick();
  };

  BugLady.prototype.state_functions.normal = function() {
    var unpowered, vel, walking;
    this.energy += 0.001;
    if (this.getsprite() === "bugdash.png") {
      WORLD.entAdd(new PchooParticle(entcenter(this)));
    }
    unpowered = settings.altcostume;
    if (unpowered) {
      this.cancelattack();
    }
    this.checkcontrols();
    if (this.outofbounds()) {
      this.kill();
    }
    vel = Math.abs(this.vel.x);
    return walking = vel > 0.2;
  };

  BugLady.prototype.limitvelocity = function() {
    var vellimit;
    vellimit = 800;
    return this.vel.x = mafs.clamp(this.vel.x, -vellimit, vellimit);
  };

  BugLady.prototype.gravitate = function() {
    if (!this.touchingground() && !this.touchingwall()) {
      this.vel.y += 1;
      if (this.timers.fightstance) {
        this.vel.y += 1;
      }
      if (settings.variablejump) {
        if (!this.holdingjump && this.vel.y < 0) {
          return this.vel.y /= 2;
        }
      }
    }
  };

  BugLady.prototype.canhurdle = function() {
    var b_cansqueezein, b_hitsomething, box, candidates;
    if (!isholdingbound('cling')) {
      return;
    }
    if (settings.altcostume) {
      return;
    }
    box = this.fallbox();
    box.x += this.facingleft ? -2 : 2;
    candidates = hitboxfilter(box, WORLD.bglayer);
    b_hitsomething = candidates.length > 0;
    box.y -= 4;
    candidates = hitboxfilter(box, WORLD.bglayer);
    b_cansqueezein = candidates.length > 0;
    return b_hitsomething && b_cansqueezein;
  };

  BugLady.prototype.hurdlecheck = function() {
    if (this.canhurdle()) {
      return this.vel.y -= 2;
    }
  };

  GenericSprite.prototype.physmove = function() {
    this.blockcollisions();
    this.avoidwalls();
    if (this.vel.y > 0 && this.touchingground()) {
      this.vel.y = 0;
    }
    this.pos = this.pos.vadd(this.vel);
    this.gravitate();
    if (this.touchingground()) {
      return this.friction();
    }
  };

  BugLady.prototype.physmove = function() {
    var pressingwalk;
    this.hurdlecheck();
    this.limitvelocity();
    this.blockcollisions();
    this.avoidwalls();
    if (this.vel.y > 0 && this.touchingground()) {
      this.vel.y = 0;
    }
    if (this.timers.mildstun <= 2) {
      this.pos = this.pos.vadd(this.vel);
    }
    if (!this.timers.hover) {
      this.gravitate();
    }
    pressingwalk = isholdingbound('left') || isholdingbound('right');
    if (this.touchingground()) {
      this.friction();
      if (!pressingwalk) {
        return this.friction();
      }
    }
  };

  BugLady.prototype.smashblock = function() {
    var block, blockcandidates, collidebox, len, q, results1;
    collidebox = this.gethitbox();
    blockcandidates = hitboxfilter(collidebox, WORLD.bglayer);
    results1 = [];
    for (q = 0, len = blockcandidates.length; q < len; q++) {
      block = blockcandidates[q];
      if (block.src !== "genblackrocks.png") {
        continue;
      }
      WORLD.bglayer = _.without(WORLD.bglayer, block);
      results1.push(block.removesprite());
    }
    return results1;
  };

  BugLady.prototype.movetick = function() {
    var jumpvel, unpowered;
    unpowered = settings.altcostume;
    this.physmove();
    this.attackchecks();
    jumpvel = unpowered ? 11 : 13;
    this.jumpimpulse(jumpvel);
    if (this.vel.y > 1 && this.controls.crouch && this.timers.charge) {
      ladybug.timers.charge = 0;
      this.state = 'headfirst';
      this.vel.y += 0.1;
    }
    if (this.touchingground() && this.state === 'headfirst') {
      this.smashblock();
      this.state = '';
      this.timers.stun = 20;
    }
    if (this.state === 'headfirst') {
      this.vel.y += 2;
      this.vel.x *= 0.9;
    }
    this.jumping = false;
    return this.climbing = this.canhurdle();
  };

  BugLady.prototype.jumpimpulse = function(jumpvel) {
    var doublejumplegal, jumplegal, unpowered;
    unpowered = settings.altcostume;
    if (this.touchingground()) {
      this.spentdoublejump = false;
      this.timers.jumpgraceperiod = 4;
      if (settings.moonjump) {
        this.timers.jumpgraceperiod = 100;
      }
    }
    jumplegal = this.touchingground() || this.timers.jumpgraceperiod > 0;
    jumplegal = jumplegal && this.controls.tapstatus.jump;
    doublejumplegal = !unpowered && settings.airjump && this.energy > 0;
    doublejumplegal = doublejumplegal && this.controls.tapstatus.jump;
    if (this.spentdoublejump) {
      doublejumplegal = false;
    }
    if (this.jumping && doublejumplegal && !jumplegal) {
      this.spentdoublejump = true;
      this.energy--;
    }
    if (this.jumping && (jumplegal || doublejumplegal)) {
      this.controls.tapstatus.jump = false;
      this.vel.y = -jumpvel;
    }
    if (this.spentdoublejump && this.vel.y < 0) {
      return WORLD.entAdd(new PchooParticle(entcenter(this)));
    }
  };

  GenericSprite.prototype.OLD_friction = function() {
    return this.vel.x = this.vel.x * 0.9;
  };

  GenericSprite.prototype.friction = function() {
    var sign, x;
    x = this.vel.x;
    sign = Math.sign(x);
    x -= sign / 2;
    if (Math.abs(x) < 1 / 2) {
      x = 0;
    }
    return this.vel.x = x;
  };

  BugLady.prototype.boggle = function() {
    WORLD.entAdd(new BoggleParticle(entcenter(this)));
    return this.energy++;
  };

  BugLady.prototype.getsprite = function() {
    var running, src, vel, walking;
    src = "lovelyshorter";
    vel = Math.abs(this.vel.x);
    walking = vel > 0.2;
    running = vel > 5;
    if (walking) {
      src = selectframe(['lovelyrun1', 'lovelyrun2'], 6);
    }
    if (running) {
      src = selectframe(['lovelyrun1', 'lovelyrun2'], 2);
    }
    if (!this.touchingground()) {
      src = this.vel.y < 0 ? 'lovelyjump' : 'lovelycrouch';
    }
    if (this.timers.fightstance > 0) {
      src = "bugstance";
    }
    if (!walking) {
      if (this.controls.crouch) {
        src = 'lovelycrouch';
      }
      if (isholdingbound('up')) {
        src = 'bugstance';
      }
      if (this.touchingground() && this.holdingboggle) {
        src = 'boggle';
      }
    }
    if (this.attacking) {
      src = 'viewtiful';
      if (this.timers.attack < 2 && this.punching) {
        src = 'lovelyrun2';
      }
      if (this.state === "kick") {
        src = 'bugkick';
        if (this.timers.slide) {
          src = 'lovelyfall';
        }
        if (this.timers.roundhouse) {
          src = 'lb_roundhouse';
        }
        if (this.timers.roundhouse >= 15) {
          src = 'bugkick';
        }
      }
    }
    if (this.timers.stun > 0) {
      src = 'lovelycrouch';
    }
    if (this.timers.mildstun > 2) {
      src = 'lovelycrouch';
    }
    if (this.timers.stun > 4) {
      src = 'bugbonk';
    }
    if (this.timers.powerup > 0) {
      src = 'viewtiful';
    }
    if (this.timers.powerup > 16) {
      src = 'boggle';
      this.facingleft = this.timers.powerup % 10 < 5;
    }
    if (vel > 11) {
      src = "bugdash";
    }
    if (this.timers.powerup > 32) {
      src = 'marl/boggle';
    }
    if (this.lastfacing !== this.facingleft) {
      this.timers.turn = 4;
      this.lastfacing = this.facingleft;
    }
    if (this.timers.turn > 0) {
      src = 'lovelycrouch';
    }
    if (settings.altcostume) {
      src = "marl/" + src;
    }
    if (this.climbing) {
      src = 'bugledge';
      if (settings.altcostume) {
        src = 'marl/boggle';
      }
    }
    if (this.state === 'headfirst') {
      src = 'bugdrop';
    }
    if (this.timers.flinching > 10 && this.touchingground()) {
      src = "bugflinch";
    }
    if (this.timers.flinching > 15) {
      src = "bugdmg";
    }
    if (this.timers.flinching > 0 && !this.touchingground()) {
      src = "bugdmg2";
    }
    if (this.state === "punch") {
      src = "buguppercut";
    }
    if (this.state === "kick") {
      src = "bugkick";
    }
    if (this.state === "roundhouse") {
      src = "lb_roundhouse";
    }
    if (this.state === "recover") {
      src = "bugbean";
    }
    return src + ".png";
  };

  BugLady.prototype.flickershield = function() {
    if (this.timers.invincible < 32 && this.shield) {
      this.shield._pixisprite.alpha = 0.5 * b2n(tickno % 8 !== 0);
    }
    if (this.timers.invincible < 10 && this.shield) {
      return this.shield._pixisprite.alpha = 0.5 * (tickno % 2);
    }
  };

  BugLady.prototype.render = function() {
    var flip, pos, sprit, src, vel, walking;
    vel = Math.abs(this.vel.x);
    walking = vel > 1;
    src = this.getsprite();
    flip = this.facingleft;
    pos = relativetobox(this.gethitbox(), this.anchor);
    sprit = drawsprite(this, src, pos, flip, this.anchor);
    if (src === 'boggle.png') {
      sprit.rotation = mafs.degstorads(mafs.randfloat() * 4);
    } else {
      sprit.rotation = 0;
    }
    if (this.timers.stun) {
      sprit.alpha = tickno % 2;
    } else {
      sprit.alpha = 1;
    }
    return this.flickershield();
  };

  stageremovesprite = function(stage, ent) {
    if (ent._pixisprite == null) {
      return;
    }
    stage.removeChild(ent._pixisprite);
    return ent._pixisprite = void 0;
  };

  removesprite = function(ent) {
    return stageremovesprite(stage, ent);
  };

  initsprite = function(ent, tex) {
    var sprit;
    sprit = new PIXI.Sprite(tex);
    ent._pixisprite = sprit;
    stage.addChild(sprit);
    return sprit;
  };

  drawsprite = function(ent, src, pos, flip, anchor) {
    var sprit, tex;
    if (anchor == null) {
      anchor = V();
    }
    tex = TEXBYNAME(src);
    if (!ent._pixisprite) {
      initsprite(ent, tex);
    }
    sprit = ent._pixisprite;
    sprit.position = VTOPP(pos);
    sprit.anchor = VTOPP(anchor);
    sprit.texture = tex;
    sprit.scale.x = flip ? -1 : 1;
    return sprit;
  };

  Rect = (function() {
    function Rect(x5, y5, w1, h1) {
      this.x = x5;
      this.y = y5;
      this.w = w1;
      this.h = h1;
    }

    return Rect;

  })();

  _Rectmethods = {
    containspoint: function(p) {
      return this.x <= p.x && this.y <= p.y && this.x + this.w >= p.x && this.y + this.h >= p.y;
    }
  };

  Block = (function(superClass) {
    extend(Block, superClass);

    function Block(x5, y5, w1, h1) {
      this.x = x5;
      this.y = y5;
      this.w = w1;
      this.h = h1;
      this.pos = V(this.x, this.y);
      this.timers = {};
      this.tile = 0;
    }

    return Block;

  })(Renderable);

  _.extend(Rect.prototype, _Rectmethods);

  _.extend(Block.prototype, _Rectmethods);

  Block.prototype.intersection = function(rectb) {
    var b, h, l, r, recta, t, w;
    recta = this;
    l = Math.max(recta.left(), rectb.left());
    t = Math.max(recta.top(), rectb.top());
    r = Math.min(recta.right(), rectb.right());
    b = Math.min(recta.bottom(), rectb.bottom());
    w = r - l;
    h = b - t;
    return new Block(l, t, w, h);
  };

  Block.prototype.strictoverlaps = function(rectb) {
    var recta;
    recta = this;
    if (recta.left() >= rectb.right() || recta.top() >= rectb.bottom() || recta.right() <= rectb.left() || recta.bottom() <= rectb.top()) {
      return false;
    } else {
      return true;
    }
  };

  Block.prototype.overlaps = function(rectb) {
    var recta;
    recta = this;
    if (recta.left() > rectb.right() || recta.top() > rectb.bottom() || recta.right() < rectb.left() || recta.bottom() < rectb.top()) {
      return false;
    } else {
      return true;
    }
  };

  Block.prototype.tostone = function() {
    return DEPRECATE();
  };

  Block.prototype.fixnegative = function() {
    if (this.w < 0) {
      this.x += this.w;
      this.w *= -1;
    }
    if (this.h < 0) {
      this.y += this.h;
      this.h *= -1;
    }
    this.pos = V(this.x, this.y);
    return this.removesprite();
  };

  hitboxfilter_OLD = function(hitbox, rectarray) {
    return rectarray.filter(function(box) {
      return hitbox.overlaps(box);
    });
  };

  hitboxfilter = function(hitbox, rectarray) {
    var res;
    stats.collisionchecks += rectarray.length;
    res = hitboxfilter_OLD(hitbox, rectarray);
    return res;
  };

  makebox = function(position, dimensions, anchor) {
    var truepos;
    truepos = position.vsub(dimensions.vmul(anchor));
    return new Block(truepos.x, truepos.y, dimensions.x, dimensions.y);
  };

  bottomcenter = V(1 / 2, 1);

  BugLady.prototype.anchor = bottomcenter;

  BugLady.prototype.size = V(16, 32 + 16);

  GenericSprite.prototype.fallbox = function() {
    var box;
    box = this.gethitbox();
    box.w += Math.abs(this.vel.x);
    box.h += Math.abs(this.vel.y);
    if (this.vel.x < 0) {
      box.x += this.vel.x;
    }
    if (this.vel.y < 0) {
      box.y += this.vel.y;
    }
    box.h -= 2;
    return box;
  };

  Block.prototype.left = function() {
    return this.x;
  };

  Block.prototype.right = function() {
    return this.x + this.w;
  };

  Block.prototype.bottom = function() {
    return this.y + this.h;
  };

  Block.prototype.top = function() {
    return this.y;
  };

  Block.prototype.issamebox = function(b) {
    return this.x === b.x && this.y === b.y && this.w === b.w && this.h === b.h;
  };

  blocksatpoint = function(blocks, p) {
    return blocks.filter(function(box) {
      return box.containspoint(p);
    });
  };

  boxtouchingwall = function(collidebox) {
    var block, blockcandidates, len, notontop, q;
    blockcandidates = hitboxfilter(collidebox, WORLD.bglayer);
    for (q = 0, len = blockcandidates.length; q < len; q++) {
      block = blockcandidates[q];
      notontop = collidebox.bottom() > block.top();
      if (notontop && collidebox.left() < block.left()) {
        return true;
      }
      if (notontop && collidebox.right() > block.right()) {
        return true;
      }
    }
    return false;
  };

  GenericSprite.prototype.touchingwall = function() {
    var collidebox;
    collidebox = this.gethitbox();
    return boxtouchingwall(collidebox);
  };

  GenericSprite.prototype.avoidwalls = function() {
    var actualbox, block, blockcandidates, collidebox, jumpthroughable, len, notontop, q, results1;
    actualbox = this.gethitbox();
    collidebox = this.fallbox();
    blockcandidates = hitboxfilter(collidebox, WORLD.bglayer);
    results1 = [];
    for (q = 0, len = blockcandidates.length; q < len; q++) {
      block = blockcandidates[q];
      jumpthroughable = block instanceof OnewayBlock;
      if (jumpthroughable) {
        continue;
      }
      notontop = actualbox.bottom() > block.top();
      if (boxtouchingwall(collidebox)) {
        if (typeof this.hitwall === "function") {
          this.hitwall();
        }
        results1.push(this.vel.x = 0);
      } else {
        results1.push(void 0);
      }
    }
    return results1;
  };

  BugLady.prototype.hitwall = function() {
    if (Math.abs(this.vel.x) > 11) {
      return this.timers.invincible = 10;
    }
  };

  GenericSprite.prototype.touchingground = function() {
    var block, blockcandidates, collidebox, fromgrid, len, otherboxes, q, touch;
    touch = false;
    collidebox = this.gethitbox();
    fromgrid = WORLD.collgrid.get(collidebox, this);
    otherboxes = [].concat(fromgrid, WORLD.bglayer);
    otherboxes = otherboxes.filter(function(b) {
      return !b.issamebox(collidebox);
    });
    blockcandidates = hitboxfilter(collidebox, otherboxes);
    for (q = 0, len = blockcandidates.length; q < len; q++) {
      block = blockcandidates[q];
      if (collidebox.bottom() <= block.bottom()) {
        touch = true;
      }
    }
    return touch;
  };

  PowerSuit = (function(superClass) {
    extend(PowerSuit, superClass);

    function PowerSuit(pos1) {
      this.pos = pos1;
      PowerSuit.__super__.constructor.call(this, this.pos, 'suit.png');
    }

    return PowerSuit;

  })(GenericSprite);

  PowerSuit.prototype.anchor = V(1 / 2, 1);

  PowerSuit.prototype.collide = function(otherent) {
    if (otherent instanceof BugLady) {
      this.KILLME = true;
      otherent.timers.powerup = 45;
      settings.altcostume = false;
      return achieve("suit");
    }
  };

  ControlObj = (function() {
    function ControlObj() {
      this.bindings = {};
      this.holdbindings = {};
      this.heldkeys = [];
      this.bindingnames = {};
      this.removedkeys = [];
    }

    return ControlObj;

  })();

  ControlObj.prototype.trimheldkeys = function() {
    this.heldkeys = _.difference(this.heldkeys, this.removedkeys);
    return this.removedkeys = [];
  };

  control = new ControlObj;

  this.control = control;

  normalizekey = function(key) {
    return key.toUpperCase().charCodeAt(0);
  };

  ControlObj.prototype.keytapbindraw = function(key, func) {
    return this.bindings[key] = func;
  };

  ControlObj.prototype.keytapbind = function(key, func) {
    return this.bindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keytapbind = function(key, func) {
    return this.bindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keytapbindname = function(key, name, func) {
    this.bindingnames[normalizekey(key)] = name;
    return this.keytapbind(key, func);
  };

  ControlObj.prototype.keyBindRawNamed = function(key, name, func) {
    this.bindingnames[key] = name;
    return this.keytapbindraw(key, func);
  };

  ControlObj.prototype.keyBindCharNamed = function(key, name, fnc) {
    return this.keyBindRawNamed(keyCharToCode[key], name, fnc);
  };

  ControlObj.prototype.keyholdbind = function(key, func) {
    return this.holdbindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keyholdbindname = function(key, name, func) {
    this.bindingnames[normalizekey(key)] = name;
    return this.holdbindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keyHoldBindRawNamed = function(key, name, func) {
    this.bindingnames[key] = name;
    return this.holdbindings[key] = func;
  };

  if (settings.devmode) {
    control.keytapbindname('9', 'zoom out', function() {
      return camera.zoomout();
    });
    control.keytapbindname('0', 'zoom in', function() {
      return camera.zoomin();
    });
  }

  _doc = document;

  launchFullScreen = function(elm) {
    if (typeof elm.requestFullScreen === "function") {
      elm.requestFullScreen();
    }
    if (typeof elm.mozRequestFullScreen === "function") {
      elm.mozRequestFullScreen();
    }
    return typeof elm.webkitRequestFullScreen === "function" ? elm.webkitRequestFullScreen() : void 0;
  };

  cancelFullScreen = function(elm) {
    if (typeof _doc.cancelFullScreen === "function") {
      _doc.cancelFullScreen();
    }
    if (typeof _doc.mozCancelFullScreen === "function") {
      _doc.mozCancelFullScreen();
    }
    return typeof _doc.webkitCancelFullScreen === "function" ? _doc.webkitCancelFullScreen() : void 0;
  };

  isfullscreen = function() {
    return _doc.fullscreenElement || _doc.mozFullscreenElement || _doc.webkitFullscreenElement;
  };

  _toggleFullScreen = function(elm) {
    if (isfullscreen()) {
      return cancelFullScreen(elm);
    } else {
      return launchFullScreen(elm);
    }
  };

  toggleFullScreen = function(elm) {
    var ref1, ref2, ref3, x, y;
    _toggleFullScreen(elm);
    ref1 = [0, 0], x = ref1[0], y = ref1[1];
    if (isfullscreen()) {
      ref2 = [screen.width, screen.height], x = ref2[0], y = ref2[1];
    } else {
      ref3 = [screensize_default.x, screensize_default.y], x = ref3[0], y = ref3[1];
    }
    renderer.resize(x, y);
    return screensize = V(x, y);
  };

  control.keytapbindname('y', 'toggle fullscreen', function() {
    return toggleFullScreen(renderer.view);
  });

  pausefunc = function() {
    playsound("pause.wav");
    settings.paused = !settings.paused;
    if (settings.paused) {
      playsound("gimmebreak.ogg", 1);
    } else {
      playsound("gameon.ogg", 1);
    }
    if (settings.paused) {
      parentstage.addChild(pausescreen);
    }
    if (!settings.paused) {
      return parentstage.removeChild(pausescreen);
    }
  };

  control.keytapbindname('p', 'pause', pausefunc);

  control.keyBindCharNamed('Pause/Break', 'pause', pausefunc);

  control.keyBindCharNamed('Enter', 'pause', function() {
    if (_isholdingkey("Alt")) {
      return toggleFullScreen(renderer.view);
    } else {
      return pausefunc();
    }
  });

  control.keyBindCharNamed('Esc', 'pause', pausefunc);

  if (settings.devmode) {
    control.keytapbindname('t', 'underclock/slowmo', function() {
      return settings.slowmo = !settings.slowmo;
    });
    control.keytapbindname('g', 'toggle grid', function() {
      return settings.grid = !settings.grid;
    });
  }

  control.keytapbindname('l', 'WHAM!', function() {});

  control.keyholdbind('l', function() {
    return ladybug.timers.attack = 10;
  });

  BugLady.prototype.dirfaced = function() {
    if (this.facingleft) {
      return -1;
    } else {
      return 1;
    }
  };

  _facing = function(ent) {
    if (ent.facingleft) {
      return -1;
    } else {
      return 1;
    }
  };

  punch = function() {
    return ladybug.state_set("punch");
  };

  kick = function() {
    if (isholdingbound('up')) {
      return ladybug.state_set("roundhouse");
    } else {
      return ladybug.state_set("kick");
    }
  };

  control.keytapbindname('e', 'charge suit', function() {
    if (settings.altcostume) {
      return;
    }
    if (ladybug.energy < 1) {
      return;
    }
    ladybug.energy--;
    return ladybug.timers.charge = 10;
  });

  control.keyholdbindname('i', 'guard', function() {
    var sb;
    if (ladybug.timers.charge) {
      ladybug.timers.charge = 0;
      ladybug.timers.invincible = 60;
      sb = new Shieldbubble();
      sb.pos = ladybug.pos;
      WORLD.entAdd(sb);
      ladybug.shield = sb;
    }
    return ladybug.timers.fightstance = 4;
  });

  control.keytapbindname('j', 'POW!', punch);

  control.keytapbindname('k', 'BAM!', kick);

  control.keytapbindname('m', 'mute', function() {
    return settings.muted = !settings.muted;
  });

  up = function() {
    if (ladybug.timers.charge) {
      ladybug.timers.charge = 0;
      ladybug.jumping = true;
      return ladybug.vel.y -= 20;
    }
  };

  jump = function() {
    if (ladybug.touchingground()) {
      playsound("jump.wav");
    }
    return ladybug.jumping = true;
  };

  down = function() {};

  bugspeed = function() {
    return 1;
  };

  MAXBUGSPEED = 10;

  _particle = function() {
    var pcho;
    pcho = new PchooParticle(entcenter(ladybug));
    pcho.vel = mafs.randvec().nmul(2);
    return WORLD.entAdd(pcho);
  };

  bugthrust = function(vel) {
    ladybug.vel.x = vel;
    ladybug.vel.y = 0;
    ladybug.timers.hover = 8;
    return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].forEach(_particle);
  };

  _sidestep = function(dir) {
    if (ladybug.touchingground()) {
      ladybug.vel.x = dir * 8;
      return ladybug.vel.y -= 4;
    }
  };

  _dash = function(dir) {
    if (!ladybug.timers.charge) {
      return;
    }
    ladybug.timers.charge = 0;
    return bugthrust(dir * 20);
  };

  _move = function(dir) {
    var vx;
    if (isholdingbound('cling')) {
      MAXBUGSPEED = 12;
    } else {
      MAXBUGSPEED = 8;
    }
    if (ladybug.timers.fightstance > 0) {
      _sidestep(dir);
      return;
    }
    _dash(dir);
    if (!settings.aircontrol && !ladybug.touchingground()) {
      return;
    }
    if (ladybug.touchingground() || ladybug.vel.x * dir > 8) {
      ladybug.facingleft = dir === -1;
    }
    vx = ladybug.vel.x + bugspeed() * dir;
    if (!settings.forcemove && Math.abs(vx) < MAXBUGSPEED) {
      ladybug.vel.x = vx;
    }
    if (settings.forcemove && Math.abs(ladybug.vel.x) < MAXBUGSPEED) {
      return ladybug.vel.x += bugspeed() * dir;
    }
  };

  left = function() {
    return _move(-1);
  };

  right = function() {
    return _move(1);
  };

  availableactions = [up, down, left, right];

  AKA = (function(_this) {
    return function(func) {
      return function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return func.apply(null, args);
      };
    };
  })(this);

  _bind = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return control.keyholdbindname.apply(control, args);
  };

  _bind('w', 'up', up);

  _bind('s', 'down', down);

  _bind('a', 'left', left);

  _bind('d', 'right', right);

  _bind('x', 'boggle', function() {});

  ControlObj.prototype.keyHoldBindCharNamed = function(key, name, func) {
    return this.keyHoldBindRawNamed(keyCharToCode[key], name, func);
  };

  control.keyHoldBindCharNamed('Up', 'up', up);

  control.keyHoldBindCharNamed('Down', 'down', down);

  control.keyHoldBindCharNamed('Left', 'left', left);

  control.keyHoldBindCharNamed('Right', 'right', right);

  control.keyHoldBindCharNamed('Space', 'jump', jump);

  control.keyHoldBindCharNamed('Shift', 'cling', function() {});

  save = function() {
    var tmpladybug;
    console.log(ladybug);
    tmpladybug = $.extend({}, ladybug);
    tmpladybug._pixisprite = void 0;
    console.log("saving");
    localStorage["bug"] = JSON.stringify(tmpladybug);
    console.log(localStorage["bug"]);
    return localStorage["settings"] = JSON.stringify(settings);
  };

  load = function() {
    console.log("loading");
    $.extend(ladybug, JSON.parse(localStorage["bug"]));
    ladybug.pos = $.extend(V(), ladybug.pos);
    ladybug.vel = V(ladybug.vel.x, ladybug.vel.y);
    return $.extend(settings, JSON.parse(localStorage["settings"]));
  };

  record_s = function() {
    jame.demofile = [];
    settings.recordingdemo = true;
    settings.playingdemo = false;
    alert("recording demo");
    return restartlevel();
  };

  record_l = function() {
    settings.recordingdemo = false;
    settings.playingdemo = true;
    alert("replaying demo");
    console.log(jame.demofile);
    return restartlevel();
  };

  control.keytapbindname('6', 'record', record_s);

  control.keytapbindname('7', 'replay', record_l);

  settings.layer = 1;

  changelayer = function(num) {
    return settings.layer = num;
  };

  if (settings.devmode) {
    control.keytapbindname('1', 'tool: building', function() {
      return chtool("create block", "block carver");
    });
    control.keytapbindname('2', 'tool: painting', function() {
      return chtool("painter", "picker");
    });
    control.keytapbindname('3', 'tool: ??', function() {});
  }

  level_files = ["1.json", "2.json"];

  CURRENT_LEVEL = 0;

  _loadcurrlevel = function() {
    return loadlevelfile("levels/" + level_files[CURRENT_LEVEL]);
  };

  nextlevel = function() {
    if (settings.grid || ladybug.timers.fightstance) {
      return;
    }
    CURRENT_LEVEL++;
    if (CURRENT_LEVEL >= level_files.length) {
      CURRENT_LEVEL = 0;
      alert('u win');
      achieve("win");
    }
    return restartlevel();
  };

  restartlevel = function() {
    WORLD.clear();
    _loadcurrlevel();
    WORLDINIT();
    return ladybug.respawn();
  };

  if (settings.devmode) {
    control.keytapbindname('r', 'restart level', restartlevel);
    control.keytapbindname('n', 'change level', nextlevel);
  }

  this.CONTROL = control;

  eventelement = $(renderer.view);

  eventelement.attr({
    onclick: "this.focus()"
  });

  body.attr({
    onload: function() {
      return eventelement.focus();
    }
  });

  reservedkeys = [];

  reserveKeyNamed = function(key) {
    return reservedkeys.push(keyCharToCode[key]);
  };

  ref1 = ["Space", "Up", "Down", "Backspace"];
  for (q = 0, len = ref1.length; q < len; q++) {
    key = ref1[q];
    reserveKeyNamed(key);
  }

  eventelement.bind('keydown', function(e) {
    var base1;
    key = e.which;
    if (typeof (base1 = control.bindings)[key] === "function") {
      base1[key]();
    }
    if (!(indexOf.call(control.heldkeys, key) >= 0)) {
      control.heldkeys.push(key);
    }
    if (indexOf.call(reservedkeys, key) >= 0) {
      return false;
    }
  });

  eventelement.bind('keyup', function(e) {
    key = e.which;
    control.removedkeys.push(key);
    if (indexOf.call(reservedkeys, key) >= 0) {
      return false;
    }
  });

  tmpcanvasjq = $("<canvas>");

  tmpcanvas = tmpcanvasjq[0];

  Block.prototype.gethitbox = function() {
    return this;
  };

  Block.prototype.initsprite = function() {
    var sprit, tex;
    tex = blocktextures[this.tile];
    sprit = new PIXI.extras.TilingSprite(tex, this.w, this.h);
    this._pixisprite = sprit;
    return stage.addChild(sprit);
  };

  Block.prototype.render = function() {
    var sprit;
    if (!this.hassprite()) {
      this.initsprite();
    }
    sprit = this._pixisprite;
    sprit.tilePosition = PP(-this.x, -this.y);
    return sprit.position = PP(this.x, this.y);
  };

  Water = (function(superClass) {
    extend(Water, superClass);

    function Water(x5, y5, w1, h1) {
      this.x = x5;
      this.y = y5;
      this.w = w1;
      this.h = h1;
      Water.__super__.constructor.call(this, this.x, this.y, this.w, this.h);
      this.src = "snow.png";
    }

    return Water;

  })(Block);

  Water.prototype.render = function() {
    Water.__super__.render.call(this);
    this._pixisprite.tilePosition.y = -tickno / 2;
    this._pixisprite.tilePosition.x = 16 * Math.cos(tickno / 100);
    return this._pixisprite.alpha = 0.5;
  };

  OnewayBlock = (function(superClass) {
    extend(OnewayBlock, superClass);

    function OnewayBlock(x5, y5, w1, h1) {
      this.x = x5;
      this.y = y5;
      this.w = w1;
      this.h = h1;
      OnewayBlock.__super__.constructor.call(this, this.x, this.y, this.w, this.h);
      this.src = "groundstone.png";
    }

    return OnewayBlock;

  })(Block);

  ladybug = new BugLady;

  Cloud = (function(superClass) {
    extend(Cloud, superClass);

    function Cloud() {
      Cloud.__super__.constructor.call(this);
      this.src = 'bigcloud.png';
    }

    return Cloud;

  })(Renderable);

  Cloud.prototype.spriteinit = function() {
    var sprit, tex;
    tex = TEXBYNAME(this.src);
    sprit = new PIXI.extras.TilingSprite(tex, screensize.x, screensize.y);
    this._pixisprite = sprit;
    parentstage.addChildAt(sprit, 0);
    return sprit;
  };

  Grid = (function(superClass) {
    extend(Grid, superClass);

    function Grid() {
      Grid.__super__.constructor.call(this);
      this.src = 'square.png';
    }

    return Grid;

  })(Renderable);

  adjustedscreensize = function() {
    return {
      x: screensize.x * 10,
      y: screensize.y * 10
    };
  };

  Grid.prototype.PIXINIT = Cloud.prototype.PIXINIT = function() {
    var ref2, sprit, tex, x, y;
    if (!this._pixisprite) {
      tex = TEXBYNAME(this.src);
      ref2 = adjustedscreensize(), x = ref2.x, y = ref2.y;
      sprit = new PIXI.extras.TilingSprite(tex, x, y);
      this._pixisprite = sprit;
      return parentstage.addChildAt(sprit, 0);
    }
  };

  Cloud.prototype.cleanup = function() {
    if (this._pixisprite) {
      parentstage.removeChild(this._pixisprite);
      return this._pixisprite = void 0;
    }
  };

  Grid.prototype.PIXREMOVE = function() {
    if (!settings.grid && this._pixisprite) {
      parentstage.removeChild(this._pixisprite);
      return this._pixisprite = void 0;
    }
  };

  Cloud.prototype.render = function() {
    var flip, offset, pos, sprit;
    pos = cameraoffset();
    flip = false;
    this.PIXINIT();
    sprit = this._pixisprite;
    offset = V(tickno * -0.2, 0);
    sprit.tilePosition = VTOPP(offset);
    if (settings.grid) {
      return this.cleanup();
    }
  };

  Grid.prototype.render = function() {
    var flip, offset, pos, sprit;
    pos = cameraoffset();
    flip = false;
    this.PIXINIT();
    sprit = this._pixisprite;
    offset = pos.nmul(-1);
    sprit.tilePosition = new PIXI.Point(offset.x, offset.y);
    return this.PIXREMOVE();
  };

  World = (function() {
    function World() {
      this.entities = [];
      this.bglayer = [];
      this.fglayer = [];
      this.spritelayer = [];
    }

    return World;

  })();

  World.prototype.entAdd = function(ent) {
    return this.spritelayer.push(ent);
  };

  World.prototype.spritesRemove = function(doomed) {
    return this.spritelayer = _.difference(this.spritelayer, doomed);
  };

  WORLD = new World;

  randpos = function() {
    return V(640 * 1.5, 64 * 2).vadd(mafs.randvec().vmul(V(640, 480)));
  };

  Shrub = (function(superClass) {
    extend(Shrub, superClass);

    function Shrub(pos1) {
      this.pos = pos1;
      Shrub.__super__.constructor.call(this, this.pos, 'shrub.png');
      this.anchor = V(1 / 2, 1);
    }

    return Shrub;

  })(GenericSprite);

  placeshrub = function(pos) {
    return WORLD.fglayer.push(new Shrub(pos));
  };

  DoubleJumper = (function(superClass) {
    extend(DoubleJumper, superClass);

    function DoubleJumper(pos1) {
      this.pos = pos1;
      DoubleJumper.__super__.constructor.call(this, this.pos);
      this.label = "airjump";
    }

    DoubleJumper.prototype.anchor = V(1 / 2, 1);

    DoubleJumper.prototype.collide = function(otherent) {
      if (otherent instanceof BugLady) {
        this.KILLME = true;
        otherent.timers.powerup = 45;
        return settings.airjump = true;
      }
    };

    return DoubleJumper;

  })(PlaceholderSprite);

  BugMeter = (function(superClass) {
    extend(BugMeter, superClass);

    function BugMeter() {
      BugMeter.__super__.constructor.call(this);
      this.src = 'bughealth.png';
      this.value = 3;
      this.abspos = V(0, 0);
      this.spritesize = V(32, 32);
      this.layer = HUDLAYER;
    }

    return BugMeter;

  })(GenericSprite);

  BugMeter.prototype.spriteinit = function() {
    var sprit, tex;
    tex = TEXBYNAME(this.src);
    sprit = new PIXI.extras.TilingSprite(tex, this.spritesize.x * this.value, this.spritesize.y);
    this._pixisprite = sprit;
    this.layer.addChild(sprit);
    return sprit;
  };

  BugMeter.prototype.cleanup = function() {
    return stageremovesprite(this.layer, this);
  };

  BugMeter.prototype.render = function() {
    var flip, pos, sprit;
    pos = this.abspos;
    flip = false;
    if (!this._pixisprite) {
      this.spriteinit();
    }
    sprit = this._pixisprite;
    sprit.zIndex = 100;
    sprit.width = this.spritesize.x * this.value;
    sprit.scale = PP(settings.hudscale, settings.hudscale);
    return sprit.position = VTOPP(pos);
  };

  BugMeter.prototype.tick = function() {
    return this.update(ladybug.health);
  };

  BugMeter.prototype.update = function(value) {
    stageremovesprite(HUDLAYER, this);
    return this.value = value;
  };

  EnergyMeter = (function(superClass) {
    extend(EnergyMeter, superClass);

    function EnergyMeter() {
      EnergyMeter.__super__.constructor.call(this);
      this.src = 'energy1.png';
      this.abspos = V(0, 16);
    }

    return EnergyMeter;

  })(BugMeter);

  EnergyMeter.prototype.tick = function() {
    return this.update(ladybug.energy);
  };

  MoneyMeter = (function(superClass) {
    extend(MoneyMeter, superClass);

    function MoneyMeter() {
      MoneyMeter.__super__.constructor.call(this);
      this.src = 'crown.png';
      this.spritesize = V(16, 16);
      this.abspos = V(8, 64 - 16);
    }

    MoneyMeter.prototype.tick = function() {
      return this.update(ladybug.score);
    };

    return MoneyMeter;

  })(BugMeter);

  Block.prototype.toJSON = function() {
    return [this.x, this.y, this.w, this.h, this.tile];
  };

  loadblocks = function(blockdata) {
    return blockdata.forEach(function(blockdatum) {
      var bl, h, src, w, x, y;
      x = blockdatum[0], y = blockdatum[1], w = blockdatum[2], h = blockdatum[3], src = blockdatum[4];
      WORLD.addblock(bl = new Block(x, y, w, h));
      if (typeof src === "number") {
        bl.tile = src;
      }
      return bl.src = src;
    });
  };

  loadspawners = function(entdata) {
    return entdata.forEach(function(entdatum) {
      var spawner;
      WORLD.entAdd(spawner = new Spawner(entdatum.pos));
      return spawner.entdata = entdatum;
    });
  };

  Goal = (function(superClass) {
    extend(Goal, superClass);

    function Goal(pos1) {
      this.pos = pos1;
      Goal.__super__.constructor.call(this, this.pos);
      this.label = "GOAL";
    }

    return Goal;

  })(PlaceholderSprite);

  Goal.prototype.collide = function(otherent) {
    if (otherent instanceof Hero) {
      return nextlevel();
    }
  };

  Platform = (function(superClass) {
    extend(Platform, superClass);

    function Platform(pos1) {
      this.pos = pos1;
      Platform.__super__.constructor.call(this, this.pos);
      this.size = V(64, 32);
      this.label = "platform";
      this.anchor = V(0, 1);
      this.t = 0;
    }

    Platform.prototype.tick = function() {
      if (!this.origpos) {
        this.origpos = this.pos.nadd(0);
      }
      this.t++;
      return this.pos.y = this.origpos.y + Math.sin(this.t / 100) * 64;
    };

    return Platform;

  })(PlaceholderSprite);

  HurtWire = (function(superClass) {
    extend(HurtWire, superClass);

    function HurtWire() {
      return HurtWire.__super__.constructor.apply(this, arguments);
    }

    return HurtWire;

  })(GenericSprite);

  HurtWire.prototype.size = V(8, 32);

  HurtWire.prototype.anchor = V(1 / 2, 0);

  HurtWire.prototype.getsprite = function() {
    var framelist, framewait;
    framewait = 1;
    framelist = ["wire.png"];
    if (this.state === "sparking") {
      framelist = [1, 2, 3, 4].map(function(n) {
        return "wirespark" + n + ".png";
      });
    }
    return selectframe(framelist, framewait);
  };

  HurtWire.prototype.tick = function() {
    this.age = this.age || 0;
    this.age = (this.age + 1) % 100;
    if (this.age < 30) {
      return this.state = "sparking";
    } else {
      return this.state = "inert";
    }
  };

  HurtWire.prototype.collide = function(otherent) {
    if (this.state === "sparking" && otherent instanceof Hero) {
      return otherent.takedamage();
    }
  };

  HurtWire.prototype.render = function() {
    this.src = this.getsprite();
    return HurtWire.__super__.render.call(this);
  };

  spawnables = {
    powersuit: PowerSuit,
    doublejumper: DoubleJumper,
    gold: Gold,
    energy: Energy,
    lila: Lila,
    platform: Platform,
    robot: Robo,
    robo: Robo,
    turret: Turret,
    "HurtWire": HurtWire,
    "Energy": Energy,
    "Gold": Gold,
    "Thug": Thug,
    "Shrub": Shrub,
    goal: Goal
  };

  Spawner = (function(superClass) {
    extend(Spawner, superClass);

    function Spawner(pos1) {
      this.pos = pos1;
      Spawner.__super__.constructor.call(this, this.pos);
      this.label = "Entity spawner";
      this.entdata = {
        "class": GenericSprite,
        pos: this.pos
      };
    }

    return Spawner;

  })(PlaceholderSprite);

  Spawner.prototype.render = function() {
    if (!settings.grid) {
      return removesprite(this);
    } else {
      return Spawner.__super__.render.call(this);
    }
  };

  Spawner.prototype.tick = function() {
    this.entdata.pos = this.pos;
    return this.label = this.entdata["class"];
  };

  Spawner.prototype.spawn = function() {
    return loadents([this.entdata]);
  };

  Spawner.prototype.toJSON = function() {
    return this.entdata;
  };

  jame = {};

  jame.spawn = function(classname) {
    var ent;
    if (!spawnables[classname]) {
      return;
    }
    ent = typeof spawnables[classname] === "function" ? new spawnables[classname]() : void 0;
    WORLD.entAdd(ent);
    return ent;
  };

  loadent = function(entdatum) {
    var ent, spawner;
    if (!spawnables[entdatum["class"]]) {
      WARN("tried to spawn nonexistant entity class " + classname);
      return;
    }
    spawner = new Spawner();
    spawner.pos.x = entdatum.pos.x;
    spawner.pos.y = entdatum.pos.y;
    console.log(entdatum);
    spawner.entdata = entdatum;
    WORLD.entAdd(spawner);
    ent = jame.spawn(entdatum["class"]);
    return ent.load(entdatum);
  };

  WORLD.addblock = function(block) {
    if (block.layer === 2) {
      return WORLD.entAdd(block);
    } else {
      return WORLD.bglayer.push(block);
    }
  };

  loadents = function(entdata) {
    return entdata.forEach(function(entdatum) {
      return loadent(entdatum);
    });
  };

  WORLDINIT = function() {
    var bugmeter, energymeter;
    WORLD.entities.push(new Cloud());
    WORLD.entities.push(new Grid());
    bugmeter = new BugMeter;
    WORLD.entities.push(bugmeter);
    energymeter = new EnergyMeter;
    WORLD.entities.push(energymeter);
    WORLD.entities.push(new MoneyMeter);
    this.bugmeter = bugmeter;
    return WORLD.entAdd(ladybug);
  };

  randtri = function() {
    return new Poly([randpos(), randpos(), randpos()]);
  };

  WORLD.getallents = function() {
    return [].concat(WORLD.entities, WORLD.spritelayer, WORLD.bglayer, WORLD.fglayer);
  };

  WORLD.clear = function() {
    var ALLENTS, renderables;
    tickno = 0;
    ALLENTS = WORLD.getallents();
    renderables = ALLENTS.filter(function(ent) {
      return ent instanceof Renderable;
    });
    renderables.forEach(function(ent) {
      return typeof ent.cleanup === "function" ? ent.cleanup() : void 0;
    });
    WORLD.entities = [];
    WORLD.spritelayer = [];
    WORLD.bglayer = [];
    WORLD.fglayer = [];
    return resetstage();
  };

  loadlevel = function(data) {
    loadblocks(data.blockdata);
    return loadents(data.ents);
  };

  loadlevelfile = function(levelfilename) {
    WORLD.doneloading = false;
    return $.ajax(levelfilename, {
      success: function(data, status, xhr) {
        var jsondata;
        jsondata = data;
        loadlevel(jsondata);
        WORLD.doneloading = true;
        return settings.paused = false;
      }
    });
  };

  _loadcurrlevel();

  WORLDINIT();

  camera = {};

  jame.camera = camera;

  camera.offset = V();

  camera.pos = V();

  camera.trackingent = ladybug;

  camera.zoomout = function() {
    scale -= 0.1;
    return scale = mafs.clamp(scale, 0.1, 1);
  };

  camera.zoomin = function() {
    scale += 0.1;
    return scale = mafs.clamp(scale, 0.1, 1);
  };

  cameraoffset = function() {
    var offs, tmppos;
    tmppos = camera.trackingent.pos.nadd(0);
    offs = camera.trackingent.vel.vmul(V(5, 0));
    tmppos = tmppos.vadd(offs);
    tmppos.y = mafs.roundn(tmppos.y, 256);
    tmppos = tmppos.vsub(camera.offset.ndiv(scale));
    tmppos = tmppos.vsub(screensize.ndiv(2 * scale));
    return camera.pos.vadd(tmppos.vsub(camera.pos).ndiv(10));
  };

  camera.tick = function() {
    return camera.pos = cameraoffset();
  };


  /*
  stage.updateLayersOrder = ->
    stage.children.sort (a,b) ->
      a.zIndex ?= 0
      b.zIndex ?= 0
      return b.zIndex-a.zIndex
   */

  render = function() {
    var highlighted, renderables;
    camera.tick();
    renderables = [].concat(WORLD.bglayer, WORLD.spritelayer, [ladybug], WORLD.fglayer, WORLD.entities);
    renderables.forEach(function(ent) {
      return typeof ent.render === "function" ? ent.render() : void 0;
    });
    highlighted = renderables.filter(function(ent) {
      return ent.HIGHLIGHT != null;
    });
    if (settings.devmode) {
      highlighted = highlighted.concat(getCursorBlocks());
    }
    if (settings.grid) {
      highlighted = renderables;
    }
    return drawhitboxes(highlighted);
  };

  drawhitboxes = function(ents) {
    var graf;
    stage.removeChild(hitboxlayer);
    hitboxlayer = new PIXI.Container;
    stage.addChild(hitboxlayer);
    graf = new PIXI.Graphics();
    graf.lineStyle(1, 0x00ff00, 1);
    graf.beginFill(0xff0000, 1 / 8);
    ents.forEach(function(ent) {
      var box, velbox;
      graf.lineStyle(1, 0x00ff00, 1);
      graf.drawCircle(ent.pos.x, ent.pos.y, 4);
      box = typeof ent.gethitbox === "function" ? ent.gethitbox() : void 0;
      if (!box) {
        return;
      }
      graf.drawRect(box.x, box.y, box.w, box.h);
      velbox = typeof ent.fallbox === "function" ? ent.fallbox() : void 0;
      if (!velbox) {
        return;
      }
      graf.lineStyle(1, 0x0000ff, 1);
      return graf.drawRect(velbox.x, velbox.y, velbox.w, velbox.h);
    });
    return hitboxlayer.addChild(graf);
  };

  timecall = function(func) {
    var starttime;
    starttime = Date.now();
    func();
    return Date.now() - starttime;
  };

  tickwaitms = 20;

  skipframes = 0;

  ticktimes = [];

  WORLD.gethitbox = function(sprite) {
    return sprite.gethitbox();
  };

  checkcolls = function(ent, otherents) {
    var bawks;
    if (settings.NOCOLLS) {
      return false;
    }
    bawks = WORLD.gethitbox(ent);
    return otherents.forEach(function(target) {
      var targethitbox;
      if (target === ent) {
        return;
      }
      targethitbox = WORLD.gethitbox(target);
      if (bawks.overlaps(targethitbox)) {
        return typeof target.collide === "function" ? target.collide(ent) : void 0;
      }
    });
  };

  WORLD.euthanasia = function() {
    var doomedsprites;
    doomedsprites = WORLD.spritelayer.filter(function(sprite) {
      return sprite.KILLME != null;
    });
    doomedsprites.forEach(function(sprite) {
      return typeof sprite.cleanup === "function" ? sprite.cleanup() : void 0;
    });
    return WORLD.spritesRemove(doomedsprites);
  };

  reset_tick_stats = function() {
    return stats.collisionchecks = 0;
  };

  COLLGRIDSIZE = 64;

  WORLD.collgrid = {
    contents: [],
    clear: function() {
      return this.contents = [];
    },
    getraw: function(rect, ignore) {
      var ar, i, ref2;
      if (ignore == null) {
        ignore = [];
      }
      i = Math.floor(rect.x / COLLGRIDSIZE);
      ar = ((ref2 = this.contents) != null ? ref2[i] : void 0) || [];
      ar = ar.filter(function(objrect) {
        var ref3;
        return ref3 = objrect.obj, indexOf.call(ignore, ref3) < 0;
      });
      return ar;
    },
    get: function(rect, ignore) {
      var ar, i, ref2;
      if (ignore == null) {
        ignore = [];
      }
      if (!Array.isArray(ignore)) {
        ignore = [ignore];
      }
      i = Math.floor(rect.x / COLLGRIDSIZE);
      ar = ((ref2 = this.contents) != null ? ref2[i] : void 0) || [];
      ar = ar.filter(function(objrect) {
        var ref3;
        return ref3 = objrect.obj, indexOf.call(ignore, ref3) < 0;
      });
      return _.pluck(ar, 'rect');
    },
    set: function(rect, obj) {
      var i;
      i = Math.floor(rect.x / COLLGRIDSIZE);
      this.contents[i] = this.contents[i] || [];
      return this.contents[i].push({
        obj: obj,
        rect: rect
      });
    }
  };

  WORLD.updateboxes = function() {
    WORLD.collgrid.clear();
    return WORLD.BOXCACHE = [];
  };

  css = {
    transition: "background .2s",
    boxShadow: "4px 4px 8px rgba(0,0,0,.5)",
    top: "200px",
    left: "400px",
    position: "absolute",
    width: 32,
    height: 32,
    background: "url('sprites/metroid like.png')"
  };

  WORLD.xx = [
    {
      elm: (function() {
        var e;
        e = $("<div class=tooltip>");
        e.css(css);
        if (!settings.devmode) {
          e.css({
            display: "none"
          });
        }
        e.appendTo(body);
        return e;
      })(),
      tick: function() {
        var pos;
        if (!settings.devmode) {
          return;
        }
        pos = gettileoffs(TILESELECT, 20, 16);
        pos = pos.nmul(-16);
        this.elm.css({
          backgroundPosition: pos.x + " " + pos.y
        });
        return this.elm.css({
          left: 16 + SCREENCURS.x + 'px',
          top: 16 + SCREENCURS.y + 'px'
        });
      }
    }
  ];

  jame.demofile = [];

  recordinputs = function() {
    var ech;
    if (!settings.recordingdemo) {
      return false;
    }
    ech = [];
    ech = ech.concat(control.heldkeys);
    return jame.demofile.push(ech);
  };

  _repdupes = function(arr, rep) {
    var len1, prev, results1, u, x;
    results1 = [];
    for (u = 0, len1 = arr.length; u < len1; u++) {
      x = arr[u];
      if (x === prev) {
        results1.push(rep);
      } else {
        results1.push(prev = x);
      }
    }
    return results1;
  };

  _demotick = function() {
    var tmpks;
    recordinputs();
    if (settings.playingdemo) {
      tmpks = jame.demofile.slice(tickno, +(tickno + 64) + 1 || 9e9).map(function(x) {
        return x.toString();
      });
      tmpks = _repdupes(tmpks, "~~");
      tmpks = tmpks.map(function(s) {
        if (s === "") {
          return "  ";
        } else {
          return s;
        }
      });
      TICKLOG(xmlwrap('pre', tmpks.join(",")));
      if (tickno >= jame.demofile.length) {
        settings.playingdemo = false;
        return alert("replay over");
      } else {
        return control.heldkeys = jame.demofile[tickno];
      }
    }
  };

  WORLD.tick = function() {
    var ACTIVEENTS, base1, len1, ref2, u;
    _demotick();
    reset_tick_stats();
    ref2 = control.heldkeys;
    for (u = 0, len1 = ref2.length; u < len1; u++) {
      key = ref2[u];
      if (typeof (base1 = control.holdbindings)[key] === "function") {
        base1[key]();
      }
    }
    WORLD.updateboxes();
    checkcolls(ladybug, WORLD.spritelayer);
    WORLD.spritelayer.forEach(function(sprite) {
      return checkcolls(sprite, _.without(WORLD.spritelayer, sprite));
    });
    WORLD.euthanasia();
    ACTIVEENTS = [].concat(WORLD.spritelayer, WORLD.entities, WORLD.xx);
    ACTIVEENTS.forEach(function(ent) {
      return typeof ent.tick === "function" ? ent.tick() : void 0;
    });
    return tickno++;
  };

  fpscounter = $(xmltag());

  fpscounter.attr({
    "class": "ticklog"
  });

  tt = 0;

  updateinfobox = function() {
    var text;
    text = control.heldkeys.map(function(key) {
      return "<span>" + keyCodeToChar[key] + "</span>";
    });
    return $(infobox).html(text.join(" "));
  };

  TICKLOG = function(datum) {
    if (!settings.devmode) {
      return;
    }
    return fpscounter.append($(xmlwrap('div', datum)));
  };

  TOOLTIP = function(datum) {
    return WORLD.xx[0].elm.append($(xmlwrap('div', datum)));
  };

  _ml = function() {
    TOOLTIP(tool.name + "/" + prevtool.name);
    getCursorBlocks().forEach(function(bl) {
      var tmp;
      tmp = [bl.x, bl.y, bl.w, bl.h].map(function(n) {
        return n / settings.gridsize;
      });
      return TOOLTIP("Block " + tmp.join(", "));
    });
    return TOOLTIP(objnames(getentsunderpoint(CURSOR)).join());
  };

  hz = function(ms) {
    return Math.round(1000 / ms);
  };

  mainloop = function() {
    var dms, fps, fpsgoal, idealfps, ticktime;
    if (tickno % 300 === 0) {
      updatesettingstable();
    }
    updateinfobox();
    if (!WORLD.doneloading) {
      settings.paused = true;
    }
    fpscounter.html("");
    WORLD.xx[0].elm.html("");
    if (!settings.paused) {
      ticktime = timecall(WORLD.tick);
      tt = ticktime;
      fps = hz(Math.max(tickwaitms, ticktime));
      idealfps = hz(tickwaitms);
      TICKLOG("~" + fps + "/" + idealfps + " fps ; per tick: " + tt + "ms");
      TICKLOG(stats.collisionchecks + " collisionchecks");
      TICKLOG(WORLD.spritelayer.length + " entities");
      _ml();
    }
    fpsgoal = settings.slowmo ? 4 : settings.fps;
    tickwaitms = hz(fpsgoal);
    dms = tickwaitms - ticktime;
    TICKLOG("dms: " + dms);
    control.trimheldkeys();
    return setTimeout(mainloop, Math.max(dms, 1));
  };

  maketablerow = function(values) {
    var tds;
    tds = values.map(function(v) {
      return xmlwrap("td", v);
    });
    return xmlwrap("tr", tds);
  };

  jame.maketable = function(arrofarr) {
    var domelm, k, v;
    domelm = $('<table>');
    for (k in arrofarr) {
      v = arrofarr[k];
      domelm.append(maketablerow(v));
    }
    return domelm;
  };

  selectall = function(classname) {
    return jame.WORLD.spritelayer.filter(function(obj) {
      return obj.constructor.name === classname;
    });
  };

  jame.listents = function() {
    var ents;
    ents = _.pairs(_.countBy(jame.WORLD.spritelayer, function(obj) {
      return obj.constructor.name;
    }));
    return body.append(jame.maketable(ents));
  };

  infobox = $("<div>");

  infobox.css({
    float: "right",
    border: "1px solid black"
  });

  body.append(infobox);

  bindingsDOM = $("<table>");

  bindingsDOMcontainer = $("<details>");

  bindingsDOMcontainer.append(bindingsDOM);

  ref2 = control.bindingnames;
  for (k in ref2) {
    v = ref2[k];
    bindingsDOM.append(maketablerow([keyCodeToChar[k], v || "??"]));
  }

  _CHARbindingnames = {};

  ref3 = control.bindingnames;
  for (k in ref3) {
    v = ref3[k];
    _CHARbindingnames[keyCodeToChar[k]] = v;
  }

  settingsDOM = $("<table>");

  settingsDOMcontainer = $("<details>");

  settingsDOMcontainer.append(settingsDOM);

  updatesettingstable = function() {
    var results1, tempv;
    settingsDOM.html("");
    results1 = [];
    for (k in settings) {
      v = settings[k];
      if (v === true || v === false) {
        tempv = xmltag("button", {
          onclick: "jame.settings." + k + "=!jame.settings." + k
        }, v);
      } else if (typeof v === "number") {
        tempv = xmltag("input", {
          type: "number",
          oninput: "jame.settings." + k + "=parseFloat(this.value)",
          value: v
        });
      } else {
        tempv = v;
      }
      results1.push(settingsDOM.append(maketablerow([k, tempv])));
    }
    return results1;
  };

  INIT = function() {
    if (settings.devmode) {
      body.append(fpscounter);
    }
    bindingsDOMcontainer.append("<summary>bindings:</summary>");
    body.append($("<br/>"));
    body.append(keyboardlayout.visualize(_CHARbindingnames));
    body.append(bindingsDOMcontainer);
    settingsDOMcontainer.append("<summary>settings:</summary>");
    body.append(settingsDOMcontainer);
    mainloop();
    return requestAnimationFrame(animate);
  };

  INIT();

  adjustmouseevent = function(e) {
    var adjusted, coffs;
    coffs = $(renderer.view).offset();
    adjusted = V(e.pageX - coffs.left, e.pageY - coffs.top);
    adjusted = adjusted.ndiv(scale);
    adjusted = adjusted.vadd(camera.pos);
    adjusted = adjusted.op(Math.round);
    return adjusted;
  };

  Tool = (function() {
    function Tool() {}

    return Tool;

  })();

  NOOPTOOL = {
    name: 'noop',
    mousedown: (function() {}),
    mouseup: (function() {}),
    mousemove: (function() {})
  };

  BLOCKCREATIONTOOL = _.extend({}, NOOPTOOL, {
    name: 'create block',
    creatingblock: false,
    mousedown: function(e) {
      var adjusted;
      adjusted = adjustmouseevent(e);
      adjusted = snapmouseadjust(adjusted);
      this.creatingblock = new Block(adjusted.x, adjusted.y, 16, 16);
      this.creatingblock.layer = settings.layer;
      this.creatingblock.tile = TILESELECT;
      return WORLD.addblock(this.creatingblock);
    },
    mouseup: function(e) {
      this.creatingblock.fixnegative();
      return this.creatingblock = false;
    },
    mousemove: function(e) {
      var creatingblock, mpos;
      mpos = snapmouseadjust(adjustmouseevent(e));
      creatingblock = this.creatingblock;
      if (creatingblock) {
        creatingblock.w = mpos.x - creatingblock.x;
        creatingblock.h = mpos.y - creatingblock.y;
        if (creatingblock.w === 0) {
          creatingblock.w = 16;
        }
        if (creatingblock.h === 0) {
          creatingblock.h = 16;
        }
        return creatingblock.removesprite();
      }
    }
  });

  __snap = function(mpos, func) {
    return mpos.ndiv(settings.gridsize).op(func).nmul(settings.gridsize);
  };

  snapmouseadjust_always = function(mpos) {
    return __snap(mpos, Math.round);
  };

  snapmouseadjust_down = function(mpos) {
    return __snap(mpos, Math.floor);
  };

  snapmouseadjust = function(mpos) {
    var snaptogrid;
    snaptogrid = isholdingkey('z');
    if (!snaptogrid) {
      return snapmouseadjust_always(mpos);
    }
    return mpos;
  };

  smame = function(e) {
    return snapmouseadjust(adjustmouseevent(e));
  };

  MoveTool = (function(superClass) {
    extend(MoveTool, superClass);

    function MoveTool() {
      return MoveTool.__super__.constructor.apply(this, arguments);
    }

    return MoveTool;

  })(Tool);

  MoveTool.prototype.name = 'move entities';

  MoveTool.prototype.constructor = function() {
    return this.selected = [];
  };

  MoveTool.prototype.mouseup = function(e) {
    this.selected = [];
    return setcursor('auto');
  };

  MoveTool.prototype.mousemove = function(e) {
    var entsundercursor, isSelecting, p;
    this.selected = this.selected || [];
    isSelecting = this.selected.length > 0;
    p = adjustmouseevent(e);
    entsundercursor = getentsunderpoint(p);
    if (isSelecting) {
      setcursor(browserprefix + "grabbing");
    } else {
      setcursor('auto');
    }
    if (entsundercursor.length > 0) {
      setcursor(browserprefix + "grab");
    }
    p = snapmouseadjust(p);
    return this.selected.forEach(function(ent) {
      ent.pos = p;
      return ent.vel = V();
    });
  };

  MoveBlockTool = (function(superClass) {
    extend(MoveBlockTool, superClass);

    MoveBlockTool.prototype.name = 'move blocks';

    function MoveBlockTool() {
      this.selected = [];
      this.relpos = V(0, 0);
      this.relative_positions = [];
    }

    MoveBlockTool.prototype.mouseup = function(e) {
      this.isholding = false;
      return setcursor('auto');
    };

    MoveBlockTool.prototype.mousehold = function(e) {
      var isSelecting;
      this.selected = this.selected || [];
      isSelecting = this.selected.length > 0;
      return this.selected.forEach((function(_this) {
        return function(ent, i) {
          var p;
          p = adjustmouseevent(e);
          p = p.vsub(_this.relative_positions[i]);
          p = snapmouseadjust(p);
          ent.pos = p;
          ent.x = p.x;
          ent.y = p.y;
          return ent.render();
        };
      })(this));
    };

    MoveBlockTool.prototype.mousemove = function(e) {
      if (this.isholding) {
        return this.mousehold(e);
      }
    };

    return MoveBlockTool;

  })(Tool);

  MoveBlockTool.prototype.mousedown = function(e) {
    var blocksundercursor, p;
    this.isholding = true;
    p = adjustmouseevent(e);
    blocksundercursor = blocksatpoint(WORLD.bglayer, p);
    if (blocksundercursor.length === 0) {
      this.selected.forEach(function(e) {
        return e.HIGHLIGHT = void 0;
      });
      this.selected = [];
    } else {
      this.selected = this.selected.concat(blocksundercursor);
    }
    this.selected.forEach(function(e) {
      return e.HIGHLIGHT = true;
    });
    this.relpos = p.vsub(this.selected[0].pos);
    return this.relative_positions = this.selected.map(function(e) {
      return p.vsub(e.pos);
    });
  };

  getentsunderpoint = function(p) {
    return WORLD.spritelayer.filter(function(ent) {
      var box;
      box = typeof ent.gethitbox === "function" ? ent.gethitbox() : void 0;
      return box && box.containspoint(p);
    });
  };

  MoveTool.prototype.mousedown = function(e) {
    var entsundercursor, p;
    p = adjustmouseevent(e);
    entsundercursor = getentsunderpoint(p);
    return this.selected = entsundercursor;
  };

  setcursor = function(cursorname) {
    return $(renderer.view).css('cursor', cursorname);
  };

  MOVETOOL = new MoveTool();

  MOVETOOL.selected = [];

  MOVEBLOCKTOOL = new MoveBlockTool();

  tool = MOVETOOL;

  prevtool = MOVETOOL;

  $(renderer.view).mousedown(function(e) {
    if (!settings.devmode) {
      return;
    }
    if (e.button === MLEFT) {
      if (typeof tool.mousedown === "function") {
        tool.mousedown(e);
      }
    }
    if (e.button === MRIGHT) {
      return typeof prevtool.mousedown === "function" ? prevtool.mousedown(e) : void 0;
    }
  });

  $(renderer.view).mouseup(function(e) {
    if (!settings.devmode) {
      return;
    }
    if (e.button === MLEFT) {
      if (typeof tool.mouseup === "function") {
        tool.mouseup(e);
      }
    }
    if (e.button === MRIGHT) {
      return typeof prevtool.mouseup === "function" ? prevtool.mouseup(e) : void 0;
    }
  });

  $(renderer.view).mousemove(function(e) {
    if (!settings.devmode) {
      return;
    }
    if (typeof tool.mousemove === "function") {
      tool.mousemove(e);
    }
    return typeof prevtool.mousemove === "function" ? prevtool.mousemove(e) : void 0;
  });

  randposrel = function(p) {
    if (p == null) {
      p = V();
    }
    return p.vadd(mafs.randvec().vmul(V(32, 32)));
  };

  TRIANGLETOOL = _.extend({}, NOOPTOOL, {
    name: "add triangle",
    mousedown: function(e) {
      var p, triangle;
      p = adjustmouseevent(e);
      triangle = new Poly([randposrel(p), randposrel(p), randposrel(p)]);
      return WORLD.entAdd(triangle);
    },
    mouseup: function(e) {},
    mousemove: function(e) {}
  });

  SPAWNTOOL = {
    name: 'Spawn entity'
  };

  SPAWNTOOL.classname = 'burd';

  SPAWNTOOL.mousedown = function(e) {
    var ent, p;
    p = adjustmouseevent(e);
    ent = jame.spawn(SPAWNTOOL.classname);
    return ent.pos = p;
  };

  SPAWNTOOL.mouseup = function(e) {};

  SPAWNTOOL.mousemove = function(e) {};

  SPAWNERTOOL = _.extend({}, NOOPTOOL, {
    name: 'Spawn entity',
    classname: 'burd',
    mousedown: function(e) {
      var ent, p;
      p = adjustmouseevent(e);
      WORLD.entAdd(ent = new Spawner(p));
      ent.pos = p;
      ent.entdata["class"] = SPAWNTOOL.classname;
      return ent.spawn();
    }
  });

  TELEPORTTOOL = _.extend({}, NOOPTOOL, {
    name: "teleport",
    mousedown: function(e) {
      var p;
      p = adjustmouseevent(e);
      ladybug.pos = p;
      return ladybug.vel = V(0, 0);
    }
  });

  boxesbounding = function(boxlist) {
    var b, bs, l, ls, r, rs, t, ts;
    ls = boxlist.map(function(b) {
      return b.left();
    });
    rs = boxlist.map(function(b) {
      return b.right();
    });
    ts = boxlist.map(function(b) {
      return b.top();
    });
    bs = boxlist.map(function(b) {
      return b.bottom();
    });
    l = ls.reduce(function(n, m) {
      return Math.min(n, m);
    });
    r = rs.reduce(function(n, m) {
      return Math.max(n, m);
    });
    t = ts.reduce(function(n, m) {
      return Math.min(n, m);
    });
    b = bs.reduce(function(n, m) {
      return Math.max(n, m);
    });
    return new Block(l, t, r - l, b - t);
  };

  blockcarve = function(aa, bb) {
    var a, b, blok, blokx, len1, u, x1, x2, x3, x4, y1, y2, y3, y4;
    b = boxesbounding([aa, bb]);
    a = aa.intersection(bb);
    x1 = b.left();
    x2 = a.left();
    x3 = a.right();
    x4 = b.right();
    y1 = b.top();
    y2 = a.top();
    y3 = a.bottom();
    y4 = b.bottom();
    blokx = [[x1, y1, x2 - x1, y2 - y1], [x2, y1, x3 - x2, y2 - y1], [x3, y1, x4 - x3, y2 - y1], [x1, y2, x2 - x1, y3 - y2], [x2, y2, x3 - x2, y3 - y2], [x3, y2, x4 - x3, y3 - y2], [x1, y3, x2 - x1, y4 - y3], [x2, y3, x3 - x2, y4 - y3], [x3, y3, x4 - x3, y4 - y3]];
    blokx = blokx.map(function(blok) {
      var newthing;
      newthing = new Block(blok[0], blok[1], blok[2], blok[3]);
      newthing.fixnegative();
      return newthing;
    });
    blokx = blokx.filter(function(blok) {
      return blok.strictoverlaps(aa) || blok.strictoverlaps(bb);
    });
    for (u = 0, len1 = blokx.length; u < len1; u++) {
      blok = blokx[u];
      WORLD.addblock(blok);
    }
    return blokx;
  };

  unfuck = function(p) {
    var a, b, blocks;
    blocks = blocksatpoint(WORLD.bglayer, p);
    if (blocks.length === 2) {
      a = blocks[0];
      b = blocks[1];
      blockcarve(a, b);
      WORLD.bglayer = _.without(WORLD.bglayer, a);
      WORLD.bglayer = _.without(WORLD.bglayer, b);
      stage.removeChild(a._pixisprite);
      return stage.removeChild(b._pixisprite);
    }
  };

  UNIONTOOL = _.extend({}, NOOPTOOL, {
    name: "unfuck block overlaps",
    mousedown: function(e) {
      var p;
      p = adjustmouseevent(e);
      return unfuck(p);
    }
  });

  carveoutblock = function(b) {
    var block, bloke, len1, len2, newcarved, results1, tocarve, todelete, u, z;
    block = new Block(b.x, b.y, b.w, b.h);
    tocarve = block.allstrictoverlaps();
    for (u = 0, len1 = tocarve.length; u < len1; u++) {
      bloke = tocarve[u];
      newcarved = blockcarve(bloke, block);
      newcarved.forEach(function(blech) {
        return blech.tile = bloke.tile;
      });
    }
    todelete = block.allstrictoverlaps();
    results1 = [];
    for (z = 0, len2 = todelete.length; z < len2; z++) {
      bloke = todelete[z];
      WORLD.bglayer = _.without(WORLD.bglayer, bloke);
      if (bloke._pixisprite != null) {
        results1.push(stage.removeChild(bloke._pixisprite));
      } else {
        results1.push(void 0);
      }
    }
    return results1;
  };

  CARVER = _.extend({}, NOOPTOOL, {
    name: "block carver",
    carve: function(p) {
      return CARVER.creatingblock = new Block(p.x, p.y, 32, 32);
    },
    mousedown: function(e) {
      var adjusted;
      adjusted = adjustmouseevent(e);
      adjusted = snapmouseadjust(adjusted);
      return this.carve(adjusted);
    },
    mouseup: function(e) {
      CARVER.creatingblock.fixnegative();
      carveoutblock(CARVER.creatingblock);
      return CARVER.creatingblock = false;
    },
    mousemove: function(e) {
      var creatingblock, mpos;
      mpos = snapmouseadjust(adjustmouseevent(e));
      creatingblock = CARVER.creatingblock;
      if (creatingblock) {
        creatingblock.w = mpos.x - creatingblock.x;
        return creatingblock.h = mpos.y - creatingblock.y;
      }
    }
  });

  WATERTOOL = _.extend({}, NOOPTOOL, {
    name: "turn block into water",
    mousedown: function(e) {
      var adjusted, bl, blocksundercursor, len1, results1, u;
      if (e.button !== 0) {
        return;
      }
      adjusted = adjustmouseevent(e);
      adjusted = snapmouseadjust(adjusted);
      blocksundercursor = blocksatpoint(WORLD.bglayer, adjusted);
      results1 = [];
      for (u = 0, len1 = blocksundercursor.length; u < len1; u++) {
        bl = blocksundercursor[u];
        WORLD.spritelayer.unshift(new Water(bl.x, bl.y, bl.w, bl.h));
        results1.push(bglayer_remove_block(bl));
      }
      return results1;
    }
  });

  BASETOOL = _.extend({}, NOOPTOOL, {
    held: false,
    mousedown: function(e) {
      this.held = true;
      return this.leftclick(adjustmouseevent(e));
    },
    mouseup: function(e) {
      return this.held = false;
    },
    mousemove: function(e) {
      if (this.held) {
        return this.lefthold(adjustmouseevent(e));
      }
    },
    leftclick: function(p) {
      return this.action(p);
    },
    lefthold: function(p) {
      return this.action(p);
    }
  });

  BLOCKPAINT = _.extend({}, BASETOOL, {
    name: "draw blocks",
    action: function(p) {
      var blocksundercursor, gs, newblock, snapped, tmp;
      gs = 32;
      tmp = settings.gridsize;
      settings.gridsize = gs;
      snapped = snapmouseadjust_down(p);
      blocksundercursor = blocksatpoint(WORLD.bglayer, p);
      if (blocksundercursor.length === 0) {
        newblock = new Block(snapped.x, snapped.y, gs, gs);
        WORLD.addblock(newblock);
      }
      return settings.gridsize = tmp;
    }
  });

  alltools = [MOVETOOL, TRIANGLETOOL, SPAWNERTOOL, TELEPORTTOOL];

  blocktools = [BLOCKCREATIONTOOL, MOVEBLOCKTOOL, UNIONTOOL, CARVER, WATERTOOL, BLOCKPAINT];

  blocktools.push(_.extend({}, NOOPTOOL, {
    name: "delete block",
    mousedown: function(e) {
      var adjusted, selected;
      adjusted = adjustmouseevent(e);
      adjusted = snapmouseadjust(adjusted);
      selected = blocksatpoint(WORLD.bglayer, adjusted);
      return tool_clickdelete(adjusted);
    }
  }));

  tool_index = {};

  mktool = function(obj) {
    var newobj;
    newobj = _.extend({}, BASETOOL, obj);
    alltools.push(newobj);
    return register_tool(newobj);
  };

  register_tool = function(tool) {
    return tool_index[tool.name] = tool;
  };

  register_tool(BLOCKCREATIONTOOL);

  register_tool(CARVER);

  chtool = function(name, secondtoolname) {
    tool = tool_index[name];
    if (secondtoolname) {
      return prevtool = tool_index[secondtoolname];
    }
  };

  mktool({
    name: "select entity",
    action: function(p) {
      var selected;
      selected = getentsunderpoint(p);
      return console.log(selected[0]);
    }
  });

  mktool({
    name: "painter",
    action: function(p) {
      var bl, len1, ref4, results1, u;
      ref4 = getCursorBlocks();
      results1 = [];
      for (u = 0, len1 = ref4.length; u < len1; u++) {
        bl = ref4[u];
        bl.tile = TILESELECT;
        results1.push(bl.removesprite());
      }
      return results1;
    }
  });

  mktool({
    name: "picker",
    action: function(p) {
      var selected;
      selected = blocksatpoint(WORLD.bglayer, p);
      return TILESELECT = selected[0].tile;
    }
  });

  mktool({
    name: "turn block into oneway",
    action: function(p) {
      var bl, blocksundercursor, len1, results1, u;
      blocksundercursor = blocksatpoint(WORLD.bglayer, p);
      results1 = [];
      for (u = 0, len1 = blocksundercursor.length; u < len1; u++) {
        bl = blocksundercursor[u];
        WORLD.bglayer.unshift(new OnewayBlock(bl.x, bl.y, bl.w, bl.h));
        results1.push(bglayer_remove_block(bl));
      }
      return results1;
    }
  });

  mktool({
    name: "turn block into background",
    mousedown: function(p) {
      var bl, blocksundercursor, len1, results1, u;
      blocksundercursor = blocksatpoint(WORLD.bglayer, p);
      results1 = [];
      for (u = 0, len1 = blocksundercursor.length; u < len1; u++) {
        bl = blocksundercursor[u];
        WORLD.entities.unshift(bl);
        results1.push(bglayer_remove_block(bl));
      }
      return results1;
    }
  });

  if (settings.devmode) {
    toolbar = $(xmltag('details', {
      "class": 'toolbar'
    }));
    toolbar.append($(xmltag('summary', void 0, 'tools')));
    toolbar.insertAfter($(renderer.view));
    makebutton = function(t) {
      var but;
      but = $(xmltag('button', void 0, t.name));
      but.click(function() {
        prevtool = tool;
        tool = t;
        $(".toolbar button").css({
          backgroundColor: 'lightgray'
        });
        but.css({
          backgroundColor: 'pink'
        });
        return eventelement.focus();
      });
      return toolbar.append(but);
    };
    toolbar.append($(xmltag('em', void 0, 'block tools: ')));
    blocktools.forEach(makebutton);
    toolbar.append($(xmltag('em', void 0, 'misc tools: ')));
    alltools.forEach(makebutton);
  }

  allactions = {};

  this.allactions = allactions;

  bindaction = function(key, actionname) {
    return control.keytapbindname(key, actionname, allactions[actionname]);
  };

  this.bindaction = bindaction;

  readablebindings = function() {
    var ks, vs;
    ks = _.keys(control.bindingnames);
    vs = _.values(control.bindingnames);
    ks = ks.map(function(k) {
      return keyCodeToChar[Number(k)];
    });
    return _.zip(ks, vs);
  };

  allactions['export keybindings'] = function() {
    var data;
    data = JSON.stringify(readablebindings());
    return window.open().document.write(data);
  };

  allactions['import keybindings'] = function() {
    var data, func, newbinds, newholdbinds, rawdata;
    rawdata = prompt('paste data here');
    newbinds = [];
    newholdbinds = [];
    if (rawdata != null) {
      data = JSON.parse(rawdata);
      for (k in data) {
        v = data[k];
        k = keyCharToCode[v[0]];
        v = v[1];
        console.log(k, v);
        func = control.bindings[k];
        if (func != null) {
          newbinds.push({
            k: k,
            name: v,
            f: func
          });
        }
        func = control.holdbindings[k];
        if (func != null) {
          newholdbinds.push({
            k: k,
            name: v,
            f: func
          });
        }
      }
      console.log(newbinds);
      console.log(newholdbinds);
      control.bindings = {};
      control.holdbindings = {};
      control.bindingnames = {};
      newbinds.forEach(function(binding) {
        return control.bindings[binding.k] = binding.f;
      });
      return newholdbinds.forEach(function(binding) {
        return control.holdbindings[binding.k] = binding.f;
      });
    }
  };

  allactions['export level'] = function() {
    var data, ents, spawners;
    ents = WORLD.getallents();
    spawners = ents.filter(function(ent) {
      return ent instanceof Spawner;
    });
    data = {
      ents: spawners,
      blockdata: WORLD.bglayer
    };
    return window.open().document.write(JSON.stringify(data));
  };

  allactions['import level'] = function() {
    var data, rawdata;
    rawdata = prompt('paste data here');
    if (rawdata != null) {
      data = JSON.parse(rawdata);
      WORLD.clear();
      loadlevel(data);
      WORLDINIT();
      return ladybug.respawn();
    }
  };

  allactions['load .json test level'] = function() {
    var levelfilename;
    levelfilename = "levels/2.json";
    return $.ajax(levelfilename, {
      success: function(data, status, xhr) {
        var jsondata;
        jsondata = JSON.parse(data);
        WORLD.clear();
        loadlevel(jsondata);
        WORLDINIT();
        return ladybug.respawn();
      }
    });
  };

  actioncategories = {
    silly: {}
  };

  actioncategories.silly["toggle moonjump"] = function() {
    return settings.moonjump = !settings.moonjump;
  };

  actioncategories["level editing"] = {
    "align all blocks to grid": function() {
      var block, gridsize, len1, ref4, results1, u;
      gridsize = settings.gridsize;
      ref4 = WORLD.bglayer;
      results1 = [];
      for (u = 0, len1 = ref4.length; u < len1; u++) {
        block = ref4[u];
        block.x = mafs.roundn(block.x, gridsize);
        block.y = mafs.roundn(block.y, gridsize);
        block.w = mafs.roundn(block.w, gridsize);
        block.h = mafs.roundn(block.h, gridsize);
        results1.push(block.removesprite());
      }
      return results1;
    }
  };

  mafs.roundn = function(num, base) {
    return Math.round(num / base) * base;
  };

  highlightoverlaps = function() {
    var alloverlaps, blox, flatlaps;
    blox = WORLD.bglayer;
    alloverlaps = blox.map(function(b) {
      return b.alloverlaps();
    });
    alloverlaps = alloverlaps.filter(function(i) {
      return i.length > 1;
    });
    flatlaps = _.flatten(alloverlaps);
    blox.forEach(function(b) {
      return b.HIGHLIGHT = void 0;
    });
    return flatlaps.forEach(function(b) {
      return b.HIGHLIGHT = true;
    });
  };

  allactions['highlight overlapping blocks'] = highlightoverlaps;

  actioncategories['core'] = allactions;

  objnames = function(objs) {
    return objs.map(function(obj) {
      return obj.constructor.name;
    });
  };

  __makebutton = function(k, v) {
    var but;
    but = $(xmltag('button', void 0, k));
    but.click(v);
    but.click(function() {
      return eventelement.focus();
    });
    return but;
  };

  if (settings.devmode) {
    for (ck in actioncategories) {
      cv = actioncategories[ck];
      tb = $(xmltag('details', {
        "class": 'toolbar'
      }));
      toolbar.append(tb);
      tb.append($(xmltag('summary', void 0, ck + " actions: ")));
      for (k in cv) {
        v = cv[k];
        tb.append(__makebutton(k, v));
      }
    }
  }

  ORIGCLICKPOS = false;

  cameratool = {
    down: function(e) {
      return ORIGCLICKPOS = V(e.pageX, e.pageY);
    },
    up: function(e) {
      ORIGCLICKPOS = false;
      return camera.offset = V();
    },
    move: function(e) {
      var currclickpos, mpos, offset;
      mpos = snapmouseadjust(adjustmouseevent(e));
      if (ORIGCLICKPOS) {
        currclickpos = V(e.pageX, e.pageY);
        offset = currclickpos.vsub(ORIGCLICKPOS);
        return camera.offset = offset.nmul(2);
      }
    }
  };

  $(renderer.view).mousedown(function(e) {
    if (e.button === 1) {
      return cameratool.down(e);
    }
  });

  $(renderer.view).mouseup(function(e) {
    if (e.button === 1) {
      return cameratool.up(e);
    }
  });

  $(renderer.view).mousemove(function(e) {
    return cameratool.move(e);
  });

  $(body).mousemove(function(e) {
    var p;
    p = smame(e);
    SCREENCURS = V(e.pageX, e.pageY);
    return CURSOR = p;
  });

  edithistory = {
    data: [],
    add: function(entry) {
      this.data.push(entry);
      return console.log(this.data);
    },
    undo: function() {
      var ent, lastevent, type;
      if (this.data.length === 0) {
        return;
      }
      lastevent = this.data.pop();
      type = lastevent[0], ent = lastevent[1];
      if (type === "remove") {
        console.log(ent);
        return WORLD.addblock(ent);
      }
    }
  };

  control.keyBindCharNamed('Backspace', 'undo', function() {
    return edithistory.undo();
  });

  bglayer_remove_block = function(ent) {
    edithistory.add(["remove", ent]);
    WORLD.bglayer = _.without(WORLD.bglayer, ent);
    return removesprite(ent);
  };

  tool_clickdelete = function(p) {
    var blox, ent;
    blox = blocksatpoint(WORLD.bglayer, p);
    if (blox.length > 0) {
      ent = blox[0];
      return bglayer_remove_block(ent);
    }
  };

  mouserightdownhandler = function(e) {
    var adjusted;
    if (e.button !== 2) {
      return;
    }
    e.preventDefault();
    return adjusted = adjustmouseevent(e);
  };

  $(renderer.view).mousedown(mouserightdownhandler);

  $(renderer.view).contextmenu(function() {
    return false;
  });

  getCursorBlocks = function() {
    return blocksatpoint(WORLD.bglayer, CURSOR);
  };

  zoomwheel = {
    up: function() {
      return camera.zoomin();
    },
    down: function() {
      return camera.zoomout();
    }
  };

  _wheelin = function(offs) {
    var bl, len1, ref4, results1, size, u;
    console.log(offs);
    size = isholdingkey('z') ? 20 : 1;
    TILESELECT += offs * size;
    ref4 = getCursorBlocks();
    results1 = [];
    for (u = 0, len1 = ref4.length; u < len1; u++) {
      bl = ref4[u];
      bl.tile = TILESELECT;
      results1.push(bl.removesprite());
    }
    return results1;
  };

  paintwheel = {
    up: function(e) {
      return _wheelin(-1);
    },
    down: function(e) {
      return _wheelin(1);
    }
  };

  wheel = {
    currmode: paintwheel,
    update: function() {
      if (_isholdingkey("X")) {
        return this.currmode = paintwheel;
      } else {
        return this.currmode = zoomwheel;
      }
    },
    up: function(e) {
      this.update();
      this.currmode.up(e);
      return console.log("up");
    },
    down: function(e) {
      this.update();
      this.currmode.down(e);
      return console.log("down");
    }
  };

  $(renderer.view).bind('wheel', function(e) {
    var delta;
    if (!settings.devmode) {
      return;
    }
    e.preventDefault();
    delta = e.originalEvent.deltaY;
    up = delta < 0;
    if (up) {
      wheel.up(e);
    }
    if (!up) {
      return wheel.down(e);
    }
  });

  _lastmodified = function(date) {
    return body.append(xmlwrap("footer", "last modified " + xmltag("time", {
      title: date,
      datetime: date
    }, jQuery.timeago(new Date(date)))));
  };

  _versionfoot = function(data, status, xhr) {
    return body.append(xmlwrap("footer", "version " + data));
  };

  $.ajax(THISFILE, {
    type: "HEAD",
    success: function(data, status, xhr) {
      return _lastmodified(xhr.getResponseHeader("Last-Modified"));
    }
  });

  $.ajax("./version.json", {
    success: _versionfoot
  });

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  spawnselection = $(xmltag('select'));

  for (classname in spawnables) {
    spawnselection.append($(xmltag('option', {
      value: classname
    }, classname)));
  }

  if (settings.devmode) {
    toolbar.append($(xmltag('em', void 0, "entity class:")));
    toolbar.append(spawnselection);
  }

  spawnselection.change(function(e) {
    return SPAWNTOOL.classname = $(this).val();
  });

  jame.WORLD = WORLD;

  jame.control = control;

  jame.stats = stats;

  jame.settings = settings;

  root.jame = jame;

  root.stage = stage;

  Block.prototype.allstrictoverlaps = function() {
    var blox;
    blox = WORLD.bglayer;
    return blox.filter((function(_this) {
      return function(otherblock) {
        return _this.strictoverlaps(otherblock);
      };
    })(this));
  };

  Block.prototype.alloverlaps = function() {
    var blox;
    blox = WORLD.bglayer;
    return blox.filter((function(_this) {
      return function(otherblock) {
        return _this.overlaps(otherblock);
      };
    })(this));
  };

  Block.prototype.equals = function(b) {
    return this.x = b.x && (this.y = b.y && (this.w = b.w && (this.h = b.h)));
  };

  jame.cleanobj = function(obj) {
    var val;
    arr = (function() {
      var results1;
      results1 = [];
      for (key in obj) {
        if (!hasProp.call(obj, key)) continue;
        val = obj[key];
        results1.push([key, val]);
      }
      return results1;
    })();
    return _.object(arr);
  };

}).call(this);

//# sourceMappingURL=platformindev.js.map
