// Generated by CoffeeScript 1.10.0
(function() {
  var Poly, hslToRgb, hue2rgb, rgbToHex,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Poly = (function(superClass) {
    extend(Poly, superClass);

    function Poly(points) {
      this.points = points != null ? points : [];
      this.pos = V();
    }

    return Poly;

  })(Renderable);

  Poly.prototype.initsprite = function() {
    var firstpoint, sprit;
    sprit = new PIXI.Graphics();
    sprit.beginFill(0xcc0000);
    sprit.lineStyle(1, 0x000000);
    firstpoint = this.points[0];
    this.points.forEach(function(point) {
      return sprit.lineTo(point.x, point.y);
    });
    sprit.lineTo(firstpoint.x, firstpoint.y);
    sprit.endFill();
    this._pixisprite = sprit;
    return stage.addChild(sprit);
  };

  Poly.prototype.render = function() {
    if (!this.hassprite()) {
      return this.initsprite();
    }
  };

  Poly.prototype.boundingbox = function() {
    var b, l, max, min, r, t, xs, ys;
    xs = this.points.map(function(pt) {
      return pt.x;
    });
    ys = this.points.map(function(pt) {
      return pt.y;
    });
    min = function(a, b) {
      return Math.min(a, b);
    };
    max = function(a, b) {
      return Math.max(a, b);
    };
    l = Math.round(xs.reduce(min));
    r = Math.round(xs.reduce(max));
    t = Math.round(ys.reduce(min));
    b = Math.round(ys.reduce(max));
    return makebox(V(l, t), V(r - l, b - t), V(0, 0));
  };

  Poly.prototype.gethitbox = function() {
    return this.boundingbox();
  };

  BugLady.prototype.polygoncollisions = function() {
    var allpolygons;
    stats.collisionchecks++;
    allpolygons = WORLD.spritelayer.filter(function(sprit) {
      return sprit instanceof Poly;
    });
    return allpolygons.forEach((function(_this) {
      return function(candidate) {
        var closest, edges, hits, p, trajectory;
        p = new V2d(_this.pos.x, _this.pos.y);
        trajectory = new Line2d(_this.pos, _this.pos.vadd(_this.vel));
        edges = pointlisttoedges(candidate.points);
        hits = edges.map(function(edg) {
          return trajectory.lineintersect(edg);
        });
        hits = _.compact(hits);
        if (hits.length > 0) {
          closest = closestpoint(p, hits);
          _this.pos = closest.vsub(_this.vel.norm());
          _this.vel.y = 0;
        }
        if (geometry.pointInsidePoly(p, candidate.points)) {
          return _this.vel.y--;
        }
      };
    })(this));
  };

  hue2rgb = function(p, q, t) {
    if (t < 0) {
      t++;
    }
    if (t > 1) {
      t--;
    }
    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  };

  hslToRgb = function(h, s, l) {
    var b, g, p, q, r;
    if (s === 0) {
      r = g = b = l;
    } else {
      q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
  };

  rgbToHex = function(rgb) {
    var b, g, r;
    r = rgb[0], g = rgb[1], b = rgb[2];
    return r * 256 * 256 + g * 256 + b;
  };

}).call(this);

//# sourceMappingURL=scrap.js.map
