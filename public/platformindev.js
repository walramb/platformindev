// Generated by CoffeeScript 1.6.3
(function() {
  var $deathmsg, BLOCKCREATIONTOOL, Block, BoggleParticle, BugLady, BugMeter, Bullet, Burd, COLLTEST_INIT, Cloud, ControlObj, Energy, EnergyMeter, Fence, GenericSprite, Goal, Gold, Grid, Hat, Hero, HurtWire, INIT, Jelly, Lila, MOVETOOL, MoneyMeter, MoveTool, NOOPTOOL, ORIGCLICKPOS, PP, PchooParticle, Pickup, PlaceholderSprite, PlayerBurd, Poly, PowerSuit, ROBOWORLD_INIT, Renderable, Robo, SPAWNERTOOL, SPAWNTOOL, Shrub, Smoochie, Spawner, THISFILE, TRIANGLETOOL, Target, Thug, Tool, V, VTOPP, WORLD, WORLDINIT, WORLD_ONE_INIT, World, achieve, adjustmouseevent, allactions, alltools, animate, audiobaseurl, availableactions, bindingsDOM, blockdata, blocksatpoint, body, bogglescreen, bogimg, bogsprite, bottomcenter, bottomof, boxtouchingwall, bugspeed, but, camera, cameraoffset, cancelFullScreen, checkcolls, chievs, classname, control, down, drawhitboxes, drawsprite, entcenter, entdata, entitycount, eventelement, firebullet, fixbox, fpscounter, getentsunderpoint, highlightoverlaps, hitboxfilter, hitboxlayer, infobox, initsprite, isholdingbound, isholdingkey, jame, k, kick, ladybug, lastmodified, launchFullScreen, left, leftof, load, loadblocks, loadent, loadents, mainloop, makebox, makechievbox, maketablerow, mousemiddledownhandler, mousemiddleuphandler, mousemovehandler, mouserightdownhandler, nextlevel, normalizekey, parentstage, pausescreen, pausetext, placeshrub, playsound, punch, randpos, randposrel, randtri, readablebindings, relativetobox, removesprite, render, renderer, resetstage, restartlevel, right, rightof, roboblockdata, root, save, scale, scatterents, screensize, selectall, selectframe, setcursor, settings, settingsDOM, skipframes, snapmouseadjust, sourcebaseurl, spawnables, spawnselection, stage, tex, text, tickno, ticktimes, tickwaitms, timecall, titlescreen, tmpcanvas, tmpcanvasjq, toggleFullScreen, tool, toolbar, topof, tt, up, updateinfobox, updatesettingstable, v, xmlwrap, _DEFAULTHITBOXSIZE, _ref, _ref1, _ref2, _ref3, _ref4,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  THISFILE = "src/platformindev.coffee";

  settings = {
    drawsprites: true,
    slowmo: false,
    altcostume: true,
    beanmode: false,
    muted: true,
    paused: false,
    volume: 0.2,
    decemberween: false,
    hat: false
  };

  settings.scale = 2 / 3;

  screensize = new V2d(64 * 16 * settings.scale, 64 * 9 * settings.scale);

  sourcebaseurl = "./sprites/";

  audiobaseurl = "./audio/";

  mafs.randfloat = function() {
    return -1 + Math.random() * 2;
  };

  mafs.randvec = function() {
    return V(mafs.randfloat(), mafs.randfloat());
  };

  mafs.randint = function(max) {
    return Math.floor(Math.random() * max);
  };

  mafs.randelem = function(arr) {
    return arr[mafs.randint(arr.length)];
  };

  mafs.degstorads = function(degs) {
    return degs * Math.PI / 180;
  };

  body = $("body");

  V = function(x, y) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    return new V2d(x, y);
  };

  PP = function(x, y) {
    return new PIXI.Point(x, y);
  };

  VTOPP = function(v) {
    return PP(v.x, v.y);
  };

  playsound = function(src) {
    var snd;
    if (settings.muted) {
      return;
    }
    snd = new Audio(audiobaseurl + src);
    snd.volume = settings.volume;
    return snd.play();
  };

  parentstage = new PIXI.Stage(0x66FF99);

  stage = new PIXI.DisplayObjectContainer;

  parentstage.addChild(stage);

  resetstage = function() {
    parentstage.removeChild(stage);
    stage = new PIXI.DisplayObjectContainer;
    return parentstage.addChild(stage);
  };

  hitboxlayer = new PIXI.DisplayObjectContainer;

  stage.addChild(hitboxlayer);

  renderer = PIXI.autoDetectRenderer(screensize.x, screensize.y);

  pausescreen = new PIXI.Graphics();

  pausescreen.beginFill(0x000000);

  pausescreen.drawRect(0, 0, screensize.x, screensize.y);

  pausescreen.alpha = 0.5;

  pausetext = new PIXI.Text("PAUSED", {
    font: "32px Arial",
    fill: "white",
    strokeThickness: 8,
    stroke: 'red'
  });

  pausetext.position = VTOPP(screensize.ndiv(2));

  pausetext.anchor = PP(1 / 2, 1);

  pausescreen.addChild(pausetext);

  pausetext = new PIXI.Text("GO GET SOME SNACKS\nPERHAPS A CARBONATED SODA", {
    font: "16px Arial",
    fill: "white"
  });

  pausetext.position = VTOPP(screensize.ndiv(2).vadd(V(0, 64)));

  pausetext.anchor = PP(1 / 2, 0);

  pausescreen.addChild(pausetext);

  bogglescreen = new PIXI.Graphics();

  bogglescreen.beginFill(0xFF00FF);

  bogglescreen.drawRect(0, 0, screensize.x, screensize.y);

  bogglescreen.alpha = 0.5;

  tex = PIXI.Texture.fromImage(sourcebaseurl + 'smooch.png');

  bogsprite = new PIXI.Sprite(tex);

  bogsprite.anchor = PP(1 / 2, 1 / 2);

  bogsprite.position = VTOPP(screensize.ndiv(2));

  bogsprite.scale = PP(2, 2);

  text = new PIXI.Text("wow a secret\nwarning, the following sprite is EXTREMELY CANON and EXTREMELY SEXY,\nchildrens avert your eyes", {
    font: "16px Arial",
    fill: "white"
  });

  text.position = VTOPP(screensize.ndiv(2).vadd(V(0, -128)));

  text.anchor = PP(1 / 2, 0);

  bogglescreen.addChild(text);

  bogglescreen.addChild(bogsprite);

  tex = PIXI.Texture.fromImage(sourcebaseurl + 'titleplaceholder.png');

  titlescreen = new PIXI.Sprite(tex);

  body.append(renderer.view);

  scale = 1;

  animate = function() {
    var cam;
    cam = cameraoffset().nmul(-scale);
    stage.position = VTOPP(cam);
    stage.scale = PP(scale, scale);
    return renderer.render(parentstage);
  };

  chievs = {};

  achieve = function(title) {
    if (chievs[title].gotten != null) {
      return;
    }
    chievs[title].gotten = true;
    console.log(chievs);
    return makechievbox(chievs[title].pic, mafs.randelem(chievs[title].text));
  };

  bogimg = xmltag('img', {
    src: sourcebaseurl + 'boggle.png'
  });

  chievs.fall = {
    pic: "lovelyfall.png",
    text: ["Fractured spine", "Faceplant", "Dats gotta hoit", "OW FUCK", "pomf =3", "Broken legs", "Have a nice trip", "Ow my organs", "Shattered pelvis", "Bugsplat"]
  };

  chievs.kick = {
    pic: "jelly.png",
    text: ["3 points field goal", "Into the dunklesphere", "Blasting off again", "pow zoom straight to the moon"]
  };

  chievs.boggle = {
    pic: "boggle.png",
    text: ["Buggy the boggle champ", "Bushboggler 2013", "Boggle that bush", "Collosal waste of time", "Boggle 2: Electric boggleoo", "Buggy bushboggle", "excuse me wtf are you doing", "Bush it, bush it real good", "Fondly regard flora", "&lt;chievo title unavailable due to trademark infringement&gt;", "Returning a bug to its natural habitat", "Bush it to the limit", "Live Free or Boggle Hard", "Identifying bushes, accurate results with simple tools", "Bugtester", "A proper lady (bug)", "Stupid achievement title", "The daily boggle", bogimg + bogimg + bogimg]
  };

  chievs.murder = {
    pic: "lovelyshorter.png",
    text: ["This isn't brave, it's murder", "Jellycide"]
  };

  chievs.target = {
    pic: "target.png",
    text: ["there's no achievement for this", "\"Pow, motherfucker, pow\" -socrates", "Expect more. Pay less.", "You're supposed to use arrows you dingus"]
  };

  chievs.start = {
    pic: "crown.png",
    text: ["wow u started playin the game, congrats", "walking to the right", "chievo modern gaming edition", "baby's first achievement"]
  };

  makechievbox = function(src, text) {
    var chievbox, pic, style;
    style = "style='display: inline-block; margin-left: 16px'";
    body.append(chievbox = $("<div class=chievbox><span " + style + "><b>ACHIEVEMENT UNLOCKED</b><br/>" + text + "</span></div>"));
    chievbox.prepend(pic = $(xmltag('img', {
      src: sourcebaseurl + src
    })));
    chievbox.animate({
      top: '32px'
    }).delay(4000);
    return chievbox.animate({
      top: '-100px'
    }, {
      queue: true
    }).delay(2000);
  };

  Renderable = (function() {
    function Renderable() {
      this.pos = V();
    }

    return Renderable;

  })();

  Renderable.prototype.hassprite = function() {
    return typeof this._pixisprite !== "undefined";
  };

  Renderable.prototype.removesprite = function() {
    return removesprite(this);
  };

  GenericSprite = (function(_super) {
    __extends(GenericSprite, _super);

    function GenericSprite(pos, src) {
      this.pos = pos != null ? pos : V();
      this.src = src;
      this.vel = V();
    }

    GenericSprite.prototype.render = function() {
      var anchor, box, flip, pos;
      anchor = this.anchor || V(0, 0);
      flip = !this.facingleft;
      box = this.gethitbox();
      pos = relativetobox(box, anchor);
      return drawsprite(this, this.src, pos, flip, anchor);
    };

    return GenericSprite;

  })(Renderable);

  GenericSprite.prototype.cleanup = function() {
    return removesprite(this);
  };

  GenericSprite.prototype.load = function(obj) {
    if (obj.pos != null) {
      return _.extend(this.pos, obj.pos);
    }
  };

  Hat = (function(_super) {
    __extends(Hat, _super);

    function Hat() {
      Hat.__super__.constructor.call(this);
      this.src = "hat.png";
      this.anchor = V(1 / 2, 1);
      this.parent = ladybug;
    }

    return Hat;

  })(GenericSprite);

  Hat.prototype.tick = function() {
    this.vel = this.parent.vel;
    this.pos = relativetobox(this.parent.gethitbox(), V(1 / 2, 0));
    return this.pos = this.pos.vadd(this.vel);
  };

  _DEFAULTHITBOXSIZE = V(32, 32);

  GenericSprite.prototype.gethitbox = function() {
    var anchor, size;
    size = this.size || _DEFAULTHITBOXSIZE;
    anchor = this.anchor || V(1 / 2, 1 / 2);
    this.hitboxcache = makebox(this.pos, size, anchor);
    return this.hitboxcache;
  };

  GenericSprite.prototype.updatehitbox = function() {
    var anchor, h, size, w, x, y, _ref;
    size = this.size || _DEFAULTHITBOXSIZE;
    anchor = this.anchor || V(1 / 2, 1 / 2);
    if (this.hitboxcache != null) {
      _ref = fixbox(this.pos, size, anchor), x = _ref[0], y = _ref[1], w = _ref[2], h = _ref[3];
      this.hitboxcache.x = x;
      this.hitboxcache.y = y;
      this.hitboxcache.w = w;
      this.hitboxcache.h = h;
    }
    return this.hitboxcache;
  };

  fixbox = function(position, dimensions, anchor) {
    var truepos;
    truepos = position.vsub(dimensions.vmul(anchor));
    return [truepos.x, truepos.y, dimensions.x, dimensions.y];
  };

  Target = (function(_super) {
    __extends(Target, _super);

    function Target(pos) {
      this.pos = pos;
      Target.__super__.constructor.call(this, this.pos, 'target.png');
      this.lifetime = -1;
      this.anchor = V(1 / 2, 1 / 2);
    }

    Target.prototype.collide = function(otherent) {
      if (otherent instanceof BoggleParticle) {
        this.vel = this.vel.vadd(otherent.vel.nmul(1 / 8));
      }
      if ((otherent.attacktimeout != null) && otherent.attacktimeout > 0) {
        return this.gethitby(otherent);
      }
    };

    Target.prototype.gethitby = function(otherent) {
      if (!this.broken) {
        this.broken = true;
        this.src = 'shatteredtarget.png';
        this.vel = otherent.vel.nmul(1 / 2);
        return this.lifetime = 10;
      }
    };

    return Target;

  })(GenericSprite);

  Jelly = (function(_super) {
    __extends(Jelly, _super);

    function Jelly(pos) {
      this.pos = pos;
      Jelly.__super__.constructor.call(this, this.pos, 'jelly.png');
    }

    Jelly.prototype.collide = function(otherent) {
      var timeout;
      if (otherent instanceof Jelly) {
        this.vel.x = (this.vel.x + otherent.vel.x) / 2;
        this.pos.x += mafs.randfloat() * 2;
      }
      if (otherent instanceof BoggleParticle) {
        this.vel = this.vel.vadd(otherent.vel.nmul(1 / 8));
      }
      if (otherent instanceof BugLady && otherent.vel.y > 0) {
        otherent.vel.y *= -2;
      }
      timeout = otherent.attacktimeout;
      if ((timeout != null) && timeout > 0) {
        return this.gethitby(otherent);
      }
    };

    Jelly.prototype.gethitby = function(otherent) {
      var dir;
      this.vel.y += otherent.vel.y;
      dir = otherent.facingleft ? -1 : 1;
      return this.vel.x += dir * 4;
    };

    Jelly.prototype.render = function() {
      var anchor, flip, pos;
      flip = tickno % 10 < 5;
      anchor = V(1 / 2, 1);
      pos = relativetobox(this.gethitbox(), anchor);
      return drawsprite(this, this.src, pos, flip, anchor);
    };

    return Jelly;

  })(GenericSprite);

  Jelly.prototype.size = V(32, 16);

  Jelly.prototype.anchor = V(1 / 2, 1);

  entitycount = function(classtype) {
    var ents;
    ents = WORLD.spritelayer.filter(function(sprite) {
      return sprite instanceof classtype;
    });
    return ents.length;
  };

  GenericSprite.prototype.gravitate = function() {
    if (!this.touchingground()) {
      return this.vel.y++;
    }
  };

  Jelly.prototype.tick = function() {
    this.physmove();
    if (this.touchingground()) {
      this.jiggle();
      return this.pos.y--;
    }
  };

  Jelly.prototype.jiggle = function() {
    this.vel.x *= 9 / 10;
    if (Math.random() * 100 < 50) {
      this.vel.y = -Math.random() * 4;
      return this.vel.x += mafs.randfloat() * 1;
    }
  };

  Fence = (function(_super) {
    __extends(Fence, _super);

    function Fence() {
      Fence.__super__.constructor.call(this);
      this.anchor = V(1 / 2, 1);
    }

    return Fence;

  })(GenericSprite);

  Fence.prototype.render = function() {};

  Pickup = (function(_super) {
    __extends(Pickup, _super);

    function Pickup(pos) {
      this.pos = pos;
      this.vel = V();
      this.src = "energy1.png";
    }

    return Pickup;

  })(Jelly);

  Pickup.prototype.jiggle = function() {};

  Pickup.prototype.collide = function(otherent) {
    if (otherent instanceof BugLady) {
      return this.pickedup(otherent);
    }
  };

  Pickup.prototype.pickedup = function(otherent) {
    playsound('boip.wav');
    return this.KILLME = true;
  };

  Energy = (function(_super) {
    __extends(Energy, _super);

    function Energy(pos) {
      this.pos = pos;
      this.vel = V();
      this.src = "energy1.png";
    }

    return Energy;

  })(Pickup);

  Energy.prototype.getsprite = function() {
    var framelist;
    framelist = [1, 2, 3, 4, 5, 6].map(function(n) {
      return "energy" + n + ".png";
    });
    return this.src = selectframe(framelist, 4);
  };

  Energy.prototype.tick = function() {
    Energy.__super__.tick.call(this);
    return this.getsprite();
  };

  Energy.prototype.pickedup = function(otherent) {
    Energy.__super__.pickedup.call(this);
    return otherent.energy += 1;
  };

  Gold = (function(_super) {
    __extends(Gold, _super);

    function Gold(pos) {
      this.pos = pos;
      this.vel = V();
      this.src = "crown.png";
    }

    return Gold;

  })(Pickup);

  Gold.prototype.getsprite = function() {};

  Gold.prototype.pickedup = function(otherent) {
    Gold.__super__.pickedup.call(this);
    return otherent.score += 1;
  };

  relativetobox = function(box, anchor) {
    var pos, size;
    pos = V(box.x, box.y);
    size = V(box.w, box.h);
    pos = pos.vadd(size.vmul(anchor));
    return pos;
  };

  Thug = (function(_super) {
    __extends(Thug, _super);

    function Thug(pos) {
      this.pos = pos != null ? pos : V();
      this.lifetime = -1;
      this.vel = V();
      this.src = 'bugthug.png';
      this.facingleft = true;
      this.health = 3;
    }

    return Thug;

  })(GenericSprite);

  bottomcenter = V(1 / 2, 1);

  Thug.prototype.size = V(24, 64 + 16);

  Thug.prototype.anchor = bottomcenter;

  Thug.prototype.tick = function() {
    this.physmove();
    return this.getsprite();
  };

  Thug.prototype.getsprite = function() {
    if (this.lifetime <= 0) {
      this.src = 'bugthug.png';
    }
    if (this.health <= 0) {
      this.src = 'thugded.png';
    }
    if (this.lifetime > 0) {
      this.lifetime--;
      return this.src = "bugthugoof.png";
    }
  };

  Thug.prototype.collide = function(otherent) {
    if (otherent instanceof BoggleParticle) {
      this.vel = this.vel.vadd(otherent.vel.nmul(1 / 8));
    }
    if ((otherent.attacktimeout != null) && otherent.attacktimeout > 0 && this.lifetime <= 0) {
      return this.gethitby(otherent);
    }
  };

  Thug.prototype.gethitby = function(otherent) {
    var dir;
    this.vel.y += otherent.vel.y;
    dir = otherent.facingleft ? -1 : 1;
    this.vel.x += dir * 1;
    this.lifetime = 10;
    return this.health -= 1;
  };

  Lila = (function(_super) {
    __extends(Lila, _super);

    function Lila() {
      _ref = Lila.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return Lila;

  })(Thug);

  Robo = (function(_super) {
    __extends(Robo, _super);

    function Robo() {
      _ref1 = Robo.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return Robo;

  })(Thug);

  Lila.prototype.scampersubroutine = Robo.prototype.scampersubroutine = function() {
    if (!this.scampering && Math.random() < 1 / 10) {
      this.scampering = true;
    }
    if (this.scampering && Math.random() < 1 / 10) {
      this.scampering = false;
    }
    if (this.scampering && Math.abs(this.vel.x) < 3) {
      this.vel.x += this.facingleft ? -this.scamperspeed : this.scamperspeed;
    }
    if (!this.scampering && Math.random() < 1 / 20) {
      return this.facingleft = !this.facingleft;
    }
  };

  Lila.prototype.tick = function() {
    if (this.kisstimeout > 0) {
      this.kisstimeout--;
    }
    Lila.__super__.tick.call(this);
    if (this.kisstimeout > 50) {
      return;
    }
    this.scamperspeed = 2;
    return this.scampersubroutine();
  };

  Robo.prototype.visioncheck = function() {
    var CENTER, dim, visionarea;
    CENTER = V(1 / 2, 1 / 2);
    dim = 64 * 4;
    visionarea = makebox(this.pos, V(dim, dim), CENTER);
    return this.angry = visionarea.containspoint(ladybug.pos);
  };

  Robo.prototype.tick = function() {
    var isdead;
    Robo.__super__.tick.call(this);
    isdead = this.health <= 0;
    this.state = this.scampering ? "attacking" : "idle";
    if (isdead) {
      this.scampering = false;
      return;
    }
    this.visioncheck();
    this.scamperspeed = 1;
    if (this.angry) {
      this.scamperspeed = 3;
    }
    return this.scampersubroutine();
  };

  selectframe = function(framelist, framewait) {
    var framechoice, totalframes;
    totalframes = framelist.length;
    framechoice = Math.floor(tickno / framewait) % totalframes;
    return framelist[framechoice];
  };

  Lila.prototype.getsprite = function() {
    var framelist, framewait, idlecycle, n, scampercycle;
    idlecycle = ['lilaidle1.png', 'lilaidle2.png'];
    scampercycle = (function() {
      var _i, _results;
      _results = [];
      for (n = _i = 1; _i <= 4; n = ++_i) {
        _results.push("lilascamper" + n + ".png");
      }
      return _results;
    })();
    framewait = 4;
    framelist = idlecycle;
    if (!this.scampering) {
      framewait = 20;
    }
    if (this.scampering) {
      framelist = scampercycle;
    }
    if (this.kisstimeout > 90) {
      framelist = ["lilakiss.png"];
    }
    return this.src = selectframe(framelist, framewait);
  };

  Robo.prototype.getsprite = function() {
    var framelist, framewait, idlecycle, scampercycle;
    idlecycle = ['roboroll1.png'];
    scampercycle = [1, 2].map(function(n) {
      return "roboroll" + n + ".png";
    });
    if (this.angry) {
      idlecycle = [1, 2].map(function(n) {
        return "roborage" + n + ".png";
      });
      scampercycle = [2, 3, 4].map(function(n) {
        return "roborage" + n + ".png";
      });
    }
    framelist = idlecycle;
    if (this.scampering) {
      framelist = scampercycle;
    }
    if (this.lifetime > 0) {
      this.lifetime--;
      framelist = ["robohurt.png"];
    }
    if (this.health <= 0) {
      framelist = ["robobody.png"];
    }
    if (this.health <= 0 && this.lifetime === 0 && this.touchingground()) {
      framelist = ["roboded.png"];
    }
    framewait = 4;
    return this.src = selectframe(framelist, framewait);
  };

  Robo.prototype.collide = function(otherent) {
    if (otherent instanceof Hero && this.state === "attacking") {
      return otherent.takedamage();
    }
  };

  Lila.prototype.collide = function(otherent) {
    var offs;
    if (otherent instanceof BoggleParticle) {
      if (!(this.kisstimeout > 0)) {
        ladybug.heal();
        WORLD.spritelayer.push(new Smoochie(this.pos));
      }
      this.kisstimeout = 100;
    }
    if (otherent instanceof Fence) {
      this.vel.x = 0;
      offs = otherent.pos.x < this.pos.x ? 1 : -1;
      return this.pos.x += offs;
    }
  };

  Burd = (function(_super) {
    __extends(Burd, _super);

    function Burd(pos) {
      this.pos = pos != null ? pos : V();
      this.vel = V(0, 0);
      this.anchor = V(1 / 2, 1 / 2);
      this.src = 'burd.png';
    }

    return Burd;

  })(GenericSprite);

  Burd.prototype.tick = function() {
    var dir, lpos;
    this.getsprite();
    this.pos = this.pos.vadd(this.vel);
    lpos = ladybug.pos || V();
    dir = lpos.vsub(this.pos).norm();
    this.vel = this.vel.vadd(dir);
    if (this.vel.mag() > 10) {
      return this.vel = this.vel.norm().nmul(10);
    }
  };

  Burd.prototype.render = function() {
    var anchor, flip, pos;
    anchor = this.anchor || V(0, 0);
    flip = false;
    pos = relativetobox(this.gethitbox(), anchor);
    drawsprite(this, this.src, pos, flip, anchor);
    this._pixisprite.scale.x = 1 / 3;
    return this._pixisprite.scale.y = 1 / 3;
  };

  Burd.prototype.getsprite = function() {
    var framelist;
    framelist = ['burd.png', 'burdflap.png'];
    return this.src = mafs.randelem(framelist);
  };

  Burd.prototype.collide = function(otherent) {
    var timeout;
    if (otherent instanceof BoggleParticle) {
      this.vel = this.vel.vadd(otherent.vel.nmul(1 / 8));
    }
    timeout = otherent.attacktimeout;
    if ((timeout != null) && timeout > 0) {
      return this.gethitby(otherent);
    }
  };

  Burd.prototype.gethitby = function(otherent) {
    var dir;
    this.vel.y += otherent.vel.y;
    dir = otherent.facingleft ? -1 : 1;
    this.vel.x += dir * 4;
    return this.lifetime = 10;
  };

  BoggleParticle = (function(_super) {
    __extends(BoggleParticle, _super);

    function BoggleParticle(pos) {
      this.pos = pos != null ? pos : V();
      this.vel = mafs.randvec().norm();
      this.src = 'huh.png';
      this.life = 50;
    }

    BoggleParticle.prototype.tick = function() {
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      this.pos = this.pos.vadd(this.vel);
      return this.vel = this.vel.vadd(mafs.randvec().norm().ndiv(8));
    };

    return BoggleParticle;

  })(GenericSprite);

  BoggleParticle.prototype.render = function() {
    return drawsprite(this, 'huh.png', this.pos, false);
  };

  Smoochie = (function(_super) {
    __extends(Smoochie, _super);

    function Smoochie(pos) {
      this.pos = pos;
      this.anchor = V(1 / 2, 1);
      this.vel = mafs.randvec().norm();
      this.src = 'kissparticle1.png';
      this.life = 50;
    }

    Smoochie.prototype.tick = function() {
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      this.pos = this.pos.vadd(this.vel);
      this.vel = this.vel.vadd(mafs.randvec().norm().ndiv(8));
      return this.vel = this.vel.vadd(V(0, -1 / 8));
    };

    Smoochie.prototype.render = function() {
      Smoochie.__super__.render.call(this);
      this.src = this.getsprite();
      return this._pixisprite.rotation = mafs.degstorads(Math.cos(this.life / 100) * 10);
    };

    return Smoochie;

  })(GenericSprite);

  Smoochie.prototype.getsprite = function() {
    var framelist, framewait;
    framewait = 16;
    framelist = [1, 2, 3].map(function(n) {
      return "kissparticle" + n + ".png";
    });
    return selectframe(framelist, framewait);
  };

  PchooParticle = (function(_super) {
    __extends(PchooParticle, _super);

    function PchooParticle(pos) {
      this.pos = pos != null ? pos : V();
      this.vel = mafs.randvec().norm().ndiv(8);
      this.life = 20;
      this.src = 'bughealth.png';
      this.anchor = V(1 / 2, 1 / 2);
    }

    PchooParticle.prototype.tick = function() {
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      this.pos = this.pos.vadd(this.vel);
      return this.vel = this.vel.vadd(mafs.randvec().norm().ndiv(64));
    };

    PchooParticle.prototype.render = function() {
      drawsprite(this, this.src, this.pos, false, this.anchor);
      return this._pixisprite.alpha = 0.25;
    };

    return PchooParticle;

  })(GenericSprite);

  Bullet = (function(_super) {
    __extends(Bullet, _super);

    function Bullet(pos) {
      this.pos = pos != null ? pos : V();
      this.owner = void 0;
      this.vel = V(8, 0);
      this.life = 20;
      this.src = 'particlepunch.png';
      this.anchor = V(1 / 2, 1 / 2);
    }

    Bullet.prototype.tick = function() {
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      this.pos = this.pos.vadd(this.vel);
      return this.vel = this.vel.vadd(mafs.randvec().norm().ndiv(64));
    };

    Bullet.prototype.render = function() {
      var flip;
      flip = this.vel.x < 0;
      drawsprite(this, this.src, this.pos, flip, this.anchor);
      return this._pixisprite.alpha = 0.8;
    };

    return Bullet;

  })(GenericSprite);

  Bullet.prototype.collide = function(otherent) {
    if ((otherent.health != null) && otherent !== this.owner) {
      if (typeof otherent.gethitby === "function") {
        otherent.gethitby(this.owner);
      }
      return this.KILLME = true;
    }
  };

  Target.prototype.tick = function() {
    this.vel = this.vel.nmul(7 / 10);
    this.pos = this.pos.vadd(this.vel);
    if (this.lifetime === 0) {
      this.KILLME = true;
    }
    if (this.lifetime > 0) {
      this.lifetime--;
    }
    if (this.lifetime === 0 && entitycount(Target) === 1) {
      return achieve("target");
    }
  };

  isholdingkey = function(key) {
    key = key.toUpperCase().charCodeAt(0);
    return __indexOf.call(control.heldkeys, key) >= 0;
  };

  isholdingbound = function(name) {
    var keys;
    keys = control.heldkeys.map(function(key) {
      return control.bindingnames[key];
    });
    return __indexOf.call(keys, name) >= 0;
  };

  Hero = (function(_super) {
    __extends(Hero, _super);

    function Hero() {
      Hero.__super__.constructor.call(this);
      this.jumping = false;
      this.attacking = false;
      this.attacktimeout = 0;
      this.stuntimeout = 0;
      this.health = 3;
      this.energy = 0;
      this.score = 0;
      this.facingleft = false;
      this.anchor = V(1 / 2, 1);
    }

    return Hero;

  })(GenericSprite);

  BugLady = (function(_super) {
    __extends(BugLady, _super);

    function BugLady() {
      BugLady.__super__.constructor.call(this);
      this.invincibletimeout = 0;
      this.controls = {};
    }

    return BugLady;

  })(Hero);

  BugLady.prototype.heal = function() {
    return this.health = 3;
  };

  BugLady.prototype.respawn = function() {
    this.pos = V();
    this.vel = V();
    return this.heal();
  };

  BugLady.prototype.flinch = function() {
    this.vel = this.vel.vmul(V(-1, 1));
    return this.invincibletimeout = 20;
  };

  Hero.prototype.gethitby = function(otherent) {
    return this.takedamage();
  };

  BugLady.prototype.takedamage = function() {
    if (this.invincibletimeout > 0) {
      return;
    }
    if (this.stuntimeout <= 0) {
      this.flinch();
    }
    this.health -= 1;
    if (this.health <= 0) {
      return this.kill();
    }
  };

  entcenter = function(ent) {
    var hb;
    hb = ent.gethitbox();
    return V(hb.x + hb.w / 2, hb.y + hb.h / 2);
  };

  BugLady.prototype.dmgvelocity = 20;

  BugLady.prototype.falldamage = function() {
    if (this.vel.y > this.dmgvelocity) {
      this.stuntimeout = 20;
      return this.takedamage();
    }
  };

  GenericSprite.prototype.blockcollisions = function() {
    var box, candidates,
      _this = this;
    box = this.gethitbox();
    candidates = hitboxfilter(box, WORLD.bglayer);
    candidates.forEach(function(candidate) {
      if (_this.gethitbox().bottom() >= candidate.top()) {
        if (typeof _this.falldamage === "function") {
          _this.falldamage();
        }
        _this.pos.y = candidate.y;
        return _this.vel.y = 0;
      }
    });
    if (candidates.length > 0 && this.vel.y < 0) {
      return this.vel.y = 0;
    }
  };

  BugLady.prototype.blockcollisions = function() {
    var box, candidates,
      _this = this;
    box = this.fallbox();
    candidates = hitboxfilter(box, WORLD.bglayer);
    candidates.forEach(function(candidate) {
      if (_this.gethitbox().bottom() <= candidate.top()) {
        _this.pos.y = candidate.y;
        return _this.vel.y = 0;
      }
    });
    if (candidates.length > 0 && this.vel.y < 0) {
      return this.vel.y = 0;
    }
  };

  BugLady.prototype.polygoncollisions = function() {
    var allpolygons,
      _this = this;
    allpolygons = WORLD.spritelayer.filter(function(sprit) {
      return sprit instanceof Poly;
    });
    return allpolygons.forEach(function(candidate) {
      var p;
      p = new V2d(_this.pos.x, _this.pos.y - 1);
      if (geometry.pointInsidePoly(p, candidate.points)) {
        _this.pos.y--;
        return _this.vel.y = 0;
      }
    });
  };

  Hero.prototype.checkcontrols = function() {};

  BugLady.prototype.checkcontrols = function() {
    this.holdingboggle = isholdingbound('boggle');
    this.holdingjump = isholdingbound('up');
    return this.controls.crouch = isholdingbound('down');
  };

  BugLady.prototype.cancelattack = function() {
    this.attacktimeout = 0;
    return this.attacking = false;
  };

  Hero.prototype.outofbounds = function() {
    return this.pos.y > 640;
  };

  $deathmsg = $("<p id=deathmsg></p>").html("<b>YOU'RE DEAD</b> now don't let me catch you doing that again young lady");

  BugLady.prototype.kill = function() {
    if (this.ded) {
      $('#deathmsg').html("<b>WHAT DID I JUST TELL YOU</b>");
    }
    if (!this.ded) {
      body.prepend($deathmsg);
      this.ded = true;
    }
    return this.respawn();
  };

  BugLady.prototype.timeoutcheck = function() {
    if (this.invincibletimeout > 0) {
      this.invincibletimeout--;
    }
    if (this.poweruptimeout > 0) {
      this.poweruptimeout--;
      this.vel = V2d.zero();
    }
    if (this.stuntimeout > 0) {
      this.stuntimeout--;
      achieve("fall");
      return this.vel = V2d.zero();
    }
  };

  BugLady.prototype.attackchecks = function() {
    var heading;
    this.attacking = this.attacktimeout > 0;
    heading = this.facingleft ? -1 : 1;
    if (this.attacking) {
      this.attacktimeout--;
    }
    if (this.attacking && !this.punching) {
      this.vel.y *= 0.7;
      this.vel.x += heading * 0.3;
      WORLD.spritelayer.push(new PchooParticle(entcenter(this)));
    }
    if (this.attacking && this.punching) {
      if (entitycount(Bullet) < 3 && this.energy > 0) {
        this.energy--;
        return firebullet(this);
      }
    }
  };

  firebullet = function(ent) {
    var CENTER, bullet, heading;
    heading = ent.facingleft ? -1 : 1;
    bullet = new Bullet();
    bullet.owner = ent;
    bullet.vel = V(heading * 16, 0);
    CENTER = V(1 / 2, 1 / 2);
    bullet.pos = relativetobox(ent.gethitbox(), CENTER);
    WORLD.spritelayer.push(bullet);
    return bullet;
  };

  BugLady.prototype.tick = function() {
    var boggling, unpowered, vel, walking;
    unpowered = settings.altcostume;
    if (unpowered) {
      this.cancelattack();
    }
    this.checkcontrols();
    if (this.outofbounds()) {
      this.kill();
    }
    vel = Math.abs(this.vel.x);
    walking = vel > 0.2;
    boggling = !walking && this.touchingground() && this.holdingboggle;
    if (boggling && Math.random() < 0.3) {
      this.boggle();
    }
    this.timeoutcheck();
    return this.movetick();
  };

  BugLady.prototype.limitvelocity = function() {
    var vellimit;
    vellimit = 10;
    return this.vel.x = mafs.clamp(this.vel.x, -vellimit, vellimit);
  };

  BugLady.prototype.gravitate = function() {
    if (!this.touchingground()) {
      this.vel.y += 1;
      if (!this.holdingjump && this.vel.y < 0) {
        return this.vel.y /= 2;
      }
    }
  };

  GenericSprite.prototype.physmove = function() {
    this.blockcollisions();
    this.avoidwalls();
    if (this.vel.y > 0 && this.touchingground()) {
      this.vel.y = 0;
    }
    this.pos = this.pos.vadd(this.vel);
    this.gravitate();
    if (this.touchingground()) {
      return this.friction();
    }
  };

  BugLady.prototype.physmove = function() {
    this.limitvelocity();
    this.blockcollisions();
    this.polygoncollisions();
    this.avoidwalls();
    if (this.vel.y > 0 && this.touchingground()) {
      this.vel.y = 0;
    }
    this.pos = this.pos.vadd(this.vel);
    this.gravitate();
    if (this.touchingground()) {
      return this.friction();
    }
  };

  BugLady.prototype.movetick = function() {
    var jumpvel, unpowered;
    unpowered = settings.altcostume;
    this.physmove();
    this.attackchecks();
    jumpvel = unpowered ? 12 : 16;
    this.jumpimpulse(jumpvel);
    this.jumping = false;
    return this.climbing = this.touchingwall();
  };

  BugLady.prototype.jumpimpulse = function(jumpvel) {
    if (this.touchingground() && this.jumping) {
      return this.vel.y = -jumpvel;
    }
  };

  GenericSprite.prototype.friction = function() {
    return this.vel.x = this.vel.x * 0.5;
  };

  BugLady.prototype.boggle = function() {
    var boxes, cand, hit;
    WORLD.spritelayer.push(new BoggleParticle(entcenter(this)));
    hit = ladybug.gethitbox();
    boxes = WORLD.fglayer.map(function(obj) {
      return obj.gethitbox();
    });
    cand = hitboxfilter(hit, boxes);
    if (cand.length > 0) {
      return achieve("boggle");
    }
  };

  BugLady.prototype.getsprite = function() {
    var src, vel, walking;
    if (this.invincibletimeout > 10 && this.touchingground()) {
      return "bugflinch.png";
    }
    if (this.invincibletimeout > 15) {
      return "bugdmg.png";
    }
    if (this.invincibletimeout > 0 && !this.touchingground()) {
      return "bugdmg2.png";
    }
    if (settings.beanmode) {
      return "bugbean.png";
    }
    src = "lovelyshorter.png";
    vel = Math.abs(this.vel.x);
    walking = vel > 0.2;
    if (walking) {
      src = selectframe(['lovelyrun1.png', 'lovelyrun2.png'], 3);
    }
    if (!this.touchingground()) {
      src = this.vel.y < 0 ? 'lovelyjump.png' : 'lovelycrouch.png';
    }
    if (!walking && this.controls.crouch) {
      src = 'lovelycrouch.png';
    }
    if (!walking && this.touchingground() && this.holdingboggle) {
      src = 'boggle.png';
    }
    if (this.attacking) {
      src = 'viewtiful.png';
    }
    if (this.attacking && this.punching) {
      src = 'bugpunch.png';
    }
    if (this.attacking && this.attacktimeout < 2 && this.punching) {
      src = 'lovelyrun2.png';
    }
    if (this.attacking && this.kicking) {
      src = 'bugkick.png';
    }
    if (this.stuntimeout > 0) {
      src = 'lovelycrouch.png';
    }
    if (this.stuntimeout > 4) {
      src = 'lovelyfall.png';
    }
    if (this.poweruptimeout > 0) {
      src = 'viewtiful.png';
    }
    if (this.poweruptimeout > 16) {
      src = 'boggle.png';
      this.facingleft = this.poweruptimeout % 10 < 5;
    }
    if (this.poweruptimeout > 32) {
      src = 'marl/boggle.png';
    }
    if (settings.altcostume) {
      src = "marl/" + src;
    }
    if (this.climbing) {
      src = 'bugclimb1.png';
    }
    if (this.climbing && settings.altcostume) {
      src = 'marl/boggle.png';
    }
    return src;
  };

  BugLady.prototype.render = function() {
    var flip, pos, sprit, src, vel, walking;
    vel = Math.abs(this.vel.x);
    walking = vel > 1;
    src = this.getsprite();
    flip = this.facingleft;
    if (settings.beanmode && walking) {
      flip = tickno % 8 < 4;
    }
    pos = relativetobox(this.gethitbox(), this.anchor);
    sprit = drawsprite(this, src, pos, flip, this.anchor);
    if (src === 'boggle.png') {
      return sprit.rotation = mafs.degstorads(mafs.randfloat() * 4);
    } else {
      return sprit.rotation = 0;
    }
  };

  PlayerBurd = (function(_super) {
    __extends(PlayerBurd, _super);

    function PlayerBurd() {
      PlayerBurd.__super__.constructor.call(this);
      this.src = 'burd.png';
      this.anchor = V(1 / 2, 1);
    }

    return PlayerBurd;

  })(Hero);

  PlayerBurd.prototype.takedamage = BugLady.prototype.takedamage;

  PlayerBurd.prototype.getsprite = function() {
    return 'burd.png';
  };

  PlayerBurd.prototype.render = function() {
    var anchor, flip, pos, sprit, src;
    src = this.src;
    anchor = this.anchor || V(0, 0);
    flip = false;
    pos = this.pos;
    sprit = drawsprite(this, src, pos, flip, anchor);
  };

  PlayerBurd.prototype.tick = function() {
    var heading, vel;
    this.checkcontrols();
    if (this.outofbounds()) {
      this.kill();
    }
    vel = Math.abs(this.vel.x);
    this.blockcollisions();
    this.avoidwalls();
    heading = this.facingleft ? -1 : 1;
    this.pos = this.pos.vadd(this.vel);
    if (!this.touchingground()) {
      return this.gravitate();
    }
  };

  removesprite = function(ent) {
    if (!ent._pixisprite) {
      return;
    }
    stage.removeChild(ent._pixisprite);
    return ent._pixisprite = void 0;
  };

  initsprite = function(ent, tex) {
    var sprit;
    sprit = new PIXI.Sprite(tex);
    ent._pixisprite = sprit;
    stage.addChild(sprit);
    return sprit;
  };

  drawsprite = function(ent, src, pos, flip, anchor) {
    var sprit;
    if (anchor == null) {
      anchor = V();
    }
    tex = PIXI.Texture.fromImage(sourcebaseurl + src);
    if (!ent._pixisprite) {
      initsprite(ent, tex);
    }
    sprit = ent._pixisprite;
    sprit.position = VTOPP(pos);
    sprit.anchor = VTOPP(anchor);
    sprit.setTexture(tex);
    sprit.scale.x = flip ? -1 : 1;
    return sprit;
  };

  Poly = (function(_super) {
    __extends(Poly, _super);

    function Poly(points) {
      this.points = points != null ? points : [];
      this.pos = V();
    }

    return Poly;

  })(Renderable);

  Poly.prototype.initsprite = function() {
    var firstpoint, sprit;
    sprit = new PIXI.Graphics();
    sprit.beginFill(0xcc0000);
    sprit.lineStyle(1, 0x000000);
    firstpoint = this.points[0];
    this.points.forEach(function(point) {
      return sprit.lineTo(point.x, point.y);
    });
    sprit.lineTo(firstpoint.x, firstpoint.y);
    sprit.endFill();
    this._pixisprite = sprit;
    return stage.addChild(sprit);
  };

  Poly.prototype.render = function() {
    if (!this.hassprite()) {
      return this.initsprite();
    }
  };

  Poly.prototype.boundingbox = function() {
    var b, l, max, min, r, t, xs, ys;
    xs = this.points.map(function(pt) {
      return pt.x;
    });
    ys = this.points.map(function(pt) {
      return pt.y;
    });
    min = function(a, b) {
      return Math.min(a, b);
    };
    max = function(a, b) {
      return Math.max(a, b);
    };
    l = Math.round(xs.reduce(min));
    r = Math.round(xs.reduce(max));
    t = Math.round(ys.reduce(min));
    b = Math.round(ys.reduce(max));
    return makebox(V(l, t), V(r - l, b - t), V(0, 0));
  };

  Poly.prototype.gethitbox = function() {
    return this.boundingbox();
  };

  Block = (function(_super) {
    __extends(Block, _super);

    function Block(x, y, w, h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      this.pos = V(this.x, this.y);
    }

    return Block;

  })(Renderable);

  Block.prototype.intersection = function(rectb) {
    var b, h, l, r, recta, t, w;
    recta = this;
    l = Math.max(recta.left(), rectb.left());
    t = Math.max(recta.top(), rectb.top());
    r = Math.min(recta.right(), rectb.right());
    b = Math.min(recta.bottom(), rectb.bottom());
    w = r - l;
    h = b - t;
    return new Block(l, t, w, h);
  };

  Block.prototype.overlaps = function(rectb) {
    var recta;
    recta = this;
    if (recta.left() > rectb.right() || recta.top() > rectb.bottom() || recta.right() < rectb.left() || recta.bottom() < rectb.top()) {
      return false;
    } else {
      return true;
    }
  };

  Block.prototype.tostone = function() {
    this.src = "groundstone.png";
    return this.removesprite();
  };

  Block.prototype.fixnegative = function() {
    if (this.w < 0) {
      this.x += this.w;
      this.w *= -1;
    }
    if (this.h < 0) {
      this.y += this.h;
      this.h *= -1;
    }
    this.pos = V(this.x, this.y);
    return this.removesprite();
  };

  hitboxfilter = function(hitbox, rectarray) {
    return rectarray.filter(function(box) {
      return hitbox.overlaps(box);
    });
  };

  makebox = function(position, dimensions, anchor) {
    var truepos;
    truepos = position.vsub(dimensions.vmul(anchor));
    return new Block(truepos.x, truepos.y, dimensions.x, dimensions.y);
  };

  bottomcenter = V(1 / 2, 1);

  BugLady.prototype.anchor = bottomcenter;

  BugLady.prototype.size = V(16, 32 + 16);

  GenericSprite.prototype.fallbox = function() {
    var box;
    box = this.gethitbox();
    box.y += this.vel.y;
    box.x += this.vel.x;
    return box;
  };

  leftof = function(box) {
    return box.x;
  };

  rightof = function(box) {
    return box.x + box.w;
  };

  bottomof = function(box) {
    return box.y + box.h;
  };

  topof = function(box) {
    return box.y;
  };

  Block.prototype.left = function() {
    return leftof(this);
  };

  Block.prototype.right = function() {
    return rightof(this);
  };

  Block.prototype.bottom = function() {
    return bottomof(this);
  };

  Block.prototype.top = function() {
    return topof(this);
  };

  Block.prototype.containspoint = function(p) {
    return this.x <= p.x && this.y <= p.y && this.x + this.w >= p.x && this.y + this.h >= p.y;
  };

  blocksatpoint = function(blocks, p) {
    return blocks.filter(function(box) {
      return box.containspoint(p);
    });
  };

  boxtouchingwall = function(collidebox) {
    var block, blockcandidates, notontop, _i, _len;
    blockcandidates = hitboxfilter(collidebox, WORLD.bglayer);
    for (_i = 0, _len = blockcandidates.length; _i < _len; _i++) {
      block = blockcandidates[_i];
      notontop = collidebox.bottom() > block.top();
      if (notontop && collidebox.left() < block.left()) {
        return true;
      }
      if (notontop && collidebox.right() > block.right()) {
        return true;
      }
    }
    return false;
  };

  GenericSprite.prototype.touchingwall = function() {
    var collidebox;
    collidebox = this.gethitbox();
    return boxtouchingwall(collidebox);
  };

  GenericSprite.prototype.avoidwalls = function() {
    var actualbox, block, blockcandidates, collidebox, notontop, overlap, _i, _len, _results;
    actualbox = this.gethitbox();
    collidebox = this.fallbox();
    blockcandidates = hitboxfilter(collidebox, WORLD.bglayer);
    _results = [];
    for (_i = 0, _len = blockcandidates.length; _i < _len; _i++) {
      block = blockcandidates[_i];
      overlap = collidebox.intersection(block);
      notontop = actualbox.bottom() > block.top();
      if (boxtouchingwall(collidebox)) {
        this.vel.x = 0;
        _results.push(this.pos.x += 0);
      } else {
        _results.push(void 0);
      }
      /*
      ofs=1
      if notontop and collidebox.left() <= block.left()
        @pos.x-=ofs
      if notontop and rightof(collidebox) >= rightof(block)
        @pos.x+=ofs
      */

    }
    return _results;
  };

  GenericSprite.prototype.touchingground = function() {
    var allpolygons, block, blockcandidates, box, collidebox, touch, _i, _len,
      _this = this;
    touch = false;
    collidebox = this.gethitbox();
    blockcandidates = hitboxfilter(collidebox, WORLD.bglayer);
    for (_i = 0, _len = blockcandidates.length; _i < _len; _i++) {
      block = blockcandidates[_i];
      if (collidebox.bottom() <= block.bottom()) {
        touch = true;
      }
    }
    allpolygons = WORLD.spritelayer.filter(function(sprit) {
      return sprit instanceof Poly;
    });
    box = this.gethitbox();
    box.y += 1;
    allpolygons.forEach(function(candidate) {
      var p;
      p = new V2d(_this.pos.x, _this.pos.y);
      if (geometry.pointInsidePoly(p, candidate.points)) {
        return touch = true;
      }
    });
    return touch;
  };

  PowerSuit = (function(_super) {
    __extends(PowerSuit, _super);

    function PowerSuit(pos) {
      this.pos = pos;
      PowerSuit.__super__.constructor.call(this, this.pos, 'suit.png');
    }

    return PowerSuit;

  })(GenericSprite);

  PowerSuit.prototype.anchor = V(1 / 2, 1);

  PowerSuit.prototype.collide = function(otherent) {
    if (otherent instanceof BugLady) {
      this.KILLME = true;
      otherent.poweruptimeout = 45;
      return settings.altcostume = false;
    }
  };

  ControlObj = (function() {
    function ControlObj() {
      this.bindings = {};
      this.holdbindings = {};
      this.heldkeys = [];
      this.bindingnames = {};
    }

    return ControlObj;

  })();

  control = new ControlObj;

  this.control = control;

  normalizekey = function(key) {
    return key.toUpperCase().charCodeAt(0);
  };

  ControlObj.prototype.keytapbindraw = function(key, func) {
    return this.bindings[key] = func;
  };

  ControlObj.prototype.keytapbind = function(key, func) {
    return this.bindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keytapbind = function(key, func) {
    return this.bindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keytapbindname = function(key, name, func) {
    this.bindingnames[normalizekey(key)] = name;
    return this.keytapbind(key, func);
  };

  ControlObj.prototype.keyBindRawNamed = function(key, name, func) {
    this.bindingnames[key] = name;
    return this.keytapbindraw(key, func);
  };

  ControlObj.prototype.keyholdbind = function(key, func) {
    return this.holdbindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keyholdbindname = function(key, name, func) {
    this.bindingnames[normalizekey(key)] = name;
    return this.holdbindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keyHoldBindRawNamed = function(key, name, func) {
    this.bindingnames[key] = name;
    return this.holdbindings[key] = func;
  };

  control.keytapbindname('9', 'zoom out', function() {
    return scale -= 0.1;
  });

  control.keytapbindname('0', 'zoom in', function() {
    return scale += 0.1;
  });

  control.keytapbindname('c', 'become burd', function() {
    return jame.burdme();
  });

  launchFullScreen = function(elm) {
    if (typeof elm.requestFullScreen === "function") {
      elm.requestFullScreen();
    }
    if (typeof elm.mozRequestFullScreen === "function") {
      elm.mozRequestFullScreen();
    }
    return typeof elm.webkitRequestFullScreen === "function" ? elm.webkitRequestFullScreen() : void 0;
  };

  cancelFullScreen = function() {
    if (typeof document.cancelFullScreen === "function") {
      document.cancelFullScreen();
    }
    if (typeof document.mozCancelFullScreen === "function") {
      document.mozCancelFullScreen();
    }
    return typeof document.webkitCancelFullScreen === "function" ? document.webkitCancelFullScreen() : void 0;
  };

  toggleFullScreen = function(elm) {
    var isfullscreen;
    isfullscreen = document.fullScreen || document.mozFullScreen || document.webkitFullScreen;
    if (isfullscreen) {
      return cancelFullScreen();
    } else {
      return launchFullScreen(elm);
    }
  };

  control.keytapbindname('y', 'toggle fullscreen', function() {
    return toggleFullScreen(renderer.view);
  });

  control.keytapbindname('p', 'pause', function() {
    playsound("pause.wav");
    settings.paused = !settings.paused;
    if (settings.paused) {
      parentstage.addChild(pausescreen);
    }
    if (!settings.paused) {
      return parentstage.removeChild(pausescreen);
    }
  });

  control.keytapbindname('t', 'underclock/slowmo', function() {
    return settings.slowmo = !settings.slowmo;
  });

  control.keytapbindname('g', 'toggle grid', function() {
    return settings.grid = !settings.grid;
  });

  control.keytapbindname('b', 'toggle beanmode', function() {
    return settings.beanmode = !settings.beanmode;
  });

  control.keytapbindname('l', 'WHAM!', function() {
    ladybug.jumping = true;
    ladybug.kicking = false;
    return ladybug.punching = false;
  });

  control.keyholdbind('l', function() {
    return ladybug.attacktimeout = 10;
  });

  punch = function() {
    ladybug.punching = true;
    ladybug.kicking = false;
    ladybug.attacktimeout = 10;
    return playsound("hit.wav");
  };

  kick = function() {
    ladybug.kicking = true;
    ladybug.jumping = true;
    ladybug.punching = false;
    ladybug.attacktimeout = 10;
    return playsound("hit.wav");
  };

  control.keytapbindname('j', 'POW!', punch);

  control.keytapbindname('k', 'BAM!', kick);

  control.keytapbindname('m', 'mute', function() {
    return settings.muted = !settings.muted;
  });

  up = function() {
    if (ladybug.touchingground()) {
      playsound("jump.wav");
    }
    return ladybug.jumping = true;
  };

  down = function() {};

  bugspeed = function() {
    var amt;
    return amt = ladybug.touchingground() ? 6 : 1;
  };

  left = function() {
    ladybug.facingleft = true;
    return ladybug.vel.x -= bugspeed();
  };

  right = function() {
    achieve("start");
    ladybug.facingleft = false;
    return ladybug.vel.x += bugspeed();
  };

  availableactions = [up, down, left, right];

  control.keyholdbindname('w', 'up', up);

  control.keyholdbindname('s', 'down', down);

  control.keyholdbindname('a', 'left', left);

  control.keyholdbindname('d', 'right', right);

  control.keyholdbindname('x', 'boggle', function() {});

  control.keyHoldBindRawNamed(keyCharToCode['Up'], 'up', up);

  control.keyHoldBindRawNamed(keyCharToCode['Down'], 'down', down);

  control.keyHoldBindRawNamed(keyCharToCode['Left'], 'left', left);

  control.keyHoldBindRawNamed(keyCharToCode['Right'], 'right', right);

  save = function() {
    var tmpladybug;
    console.log(ladybug);
    tmpladybug = $.extend({}, ladybug);
    tmpladybug._pixisprite = void 0;
    console.log("saving");
    localStorage["bug"] = JSON.stringify(tmpladybug);
    console.log(localStorage["bug"]);
    return localStorage["settings"] = JSON.stringify(settings);
  };

  load = function() {
    console.log("loading");
    $.extend(ladybug, JSON.parse(localStorage["bug"]));
    ladybug.pos = $.extend(V(), ladybug.pos);
    ladybug.vel = V(ladybug.vel.x, ladybug.vel.y);
    return $.extend(settings, JSON.parse(localStorage["settings"]));
  };

  control.keytapbindname('6', 'save', save);

  control.keytapbindname('7', 'load', load);

  nextlevel = function() {
    WORLD.clear();
    COLLTEST_INIT();
    WORLDINIT();
    return ladybug.respawn();
  };

  restartlevel = function() {
    WORLD.clear();
    WORLD_ONE_INIT();
    WORLDINIT();
    return ladybug.respawn();
  };

  control.keytapbindname('r', 'restart level', restartlevel);

  control.keytapbindname('n', 'change level', nextlevel);

  this.CONTROL = control;

  eventelement = $(document);

  eventelement.bind('keydown', function(e) {
    var key, _base;
    key = e.which;
    if (typeof (_base = control.bindings)[key] === "function") {
      _base[key]();
    }
    if (!(__indexOf.call(control.heldkeys, key) >= 0)) {
      return control.heldkeys.push(key);
    }
  });

  eventelement.bind('keyup', function(e) {
    var key;
    key = e.which;
    return control.heldkeys = _.without(control.heldkeys, key);
  });

  tmpcanvasjq = $("<canvas>");

  tmpcanvas = tmpcanvasjq[0];

  tickno = 0;

  Block.prototype.gethitbox = function() {
    return this;
  };

  Block.prototype.initsprite = function() {
    var sprit, src;
    src = this.src || "groundtile.png";
    tex = PIXI.Texture.fromImage(sourcebaseurl + src);
    sprit = new PIXI.TilingSprite(tex, this.w, this.h);
    this._pixisprite = sprit;
    return stage.addChild(sprit);
  };

  Block.prototype.render = function() {
    var sprit;
    if (!this.hassprite()) {
      this.initsprite();
    }
    sprit = this._pixisprite;
    sprit.tilePosition.x = -this.x;
    sprit.tilePosition.y = -this.y;
    sprit.position.x = this.x;
    return sprit.position.y = this.y;
  };

  ladybug = new BugLady;

  Cloud = (function(_super) {
    __extends(Cloud, _super);

    function Cloud() {
      Cloud.__super__.constructor.call(this);
      this.src = 'cloud.png';
      if (settings.decemberween) {
        this.src = 'snow.png';
      }
    }

    return Cloud;

  })(Renderable);

  Cloud.prototype.spriteinit = function() {
    var sprit;
    tex = PIXI.Texture.fromImage(sourcebaseurl + this.src);
    sprit = new PIXI.TilingSprite(tex, screensize.x, screensize.y);
    this._pixisprite = sprit;
    stage.addChildAt(sprit, 0);
    return sprit;
  };

  Grid = (function(_super) {
    __extends(Grid, _super);

    function Grid() {
      Grid.__super__.constructor.call(this);
      this.src = 'square.png';
    }

    return Grid;

  })(Renderable);

  Grid.prototype.PIXINIT = Cloud.prototype.PIXINIT = function() {
    var sprit;
    if (!this._pixisprite) {
      tex = PIXI.Texture.fromImage(sourcebaseurl + this.src);
      sprit = new PIXI.TilingSprite(tex, screensize.x, screensize.y);
      this._pixisprite = sprit;
      return stage.addChildAt(sprit, 1);
    }
  };

  Grid.prototype.PIXREMOVE = function() {
    if (!settings.grid && this._pixisprite) {
      stage.removeChild(this._pixisprite);
      return this._pixisprite = void 0;
    }
  };

  Cloud.prototype.render = function() {
    var flip, offset, pos, sprit;
    pos = cameraoffset();
    flip = false;
    this.PIXINIT();
    sprit = this._pixisprite;
    offset = V(tickno * -0.2, Math.sin(tickno / 200) * 64);
    sprit.position = VTOPP(pos);
    return sprit.tilePosition = VTOPP(offset);
  };

  Grid.prototype.render = function() {
    var flip, offset, pos, sprit;
    pos = cameraoffset();
    flip = false;
    this.PIXINIT();
    sprit = this._pixisprite;
    sprit.position = VTOPP(pos);
    offset = camera.pos.nmul(-1);
    sprit.tilePosition = new PIXI.Point(offset.x, offset.y);
    return this.PIXREMOVE();
  };

  World = (function() {
    function World() {
      this.entities = [];
      this.bglayer = [];
      this.fglayer = [];
      this.spritelayer = [];
    }

    return World;

  })();

  WORLD = new World;

  randpos = function() {
    return V(640 * 1.5, 64 * 2).vadd(mafs.randvec().vmul(V(640, 100)));
  };

  Shrub = (function(_super) {
    __extends(Shrub, _super);

    function Shrub(pos) {
      this.pos = pos;
      Shrub.__super__.constructor.call(this, this.pos, 'shrub.png');
      this.anchor = V(1 / 2, 1);
    }

    return Shrub;

  })(GenericSprite);

  placeshrub = function(pos) {
    return WORLD.fglayer.push(new Shrub(pos));
  };

  PlaceholderSprite = (function(_super) {
    __extends(PlaceholderSprite, _super);

    function PlaceholderSprite(pos) {
      this.pos = pos;
      PlaceholderSprite.__super__.constructor.call(this, this.pos);
      this.label = 'a thing';
    }

    return PlaceholderSprite;

  })(GenericSprite);

  PlaceholderSprite.prototype.render = function() {
    var box, sprit, txt;
    if (this._pixisprite != null) {
      return;
    }
    txt = new PIXI.Text(this.label, {
      font: "12px Arial",
      fill: "black"
    });
    txt.anchor = PP(this.anchor);
    sprit = new PIXI.Graphics();
    sprit.beginFill(0xFF00FF);
    box = this.gethitbox();
    sprit.position = VTOPP(this.pos);
    sprit.drawRect(0, 0, box.w, box.h);
    sprit.alpha = 0.9;
    sprit.addChild(txt);
    stage.addChild(sprit);
    return this._pixisprite = sprit;
  };

  BugMeter = (function(_super) {
    __extends(BugMeter, _super);

    function BugMeter() {
      BugMeter.__super__.constructor.call(this);
      this.src = 'bughealth.png';
      this.value = 3;
      this.abspos = V(0, 0);
      this.spritesize = V(32, 32);
    }

    return BugMeter;

  })(GenericSprite);

  BugMeter.prototype.spriteinit = function() {
    var sprit;
    tex = PIXI.Texture.fromImage(sourcebaseurl + this.src);
    sprit = new PIXI.TilingSprite(tex, this.spritesize.x * this.value, this.spritesize.y);
    this._pixisprite = sprit;
    stage.addChild(sprit);
    return sprit;
  };

  BugMeter.prototype.render = function() {
    var flip, pos, sprit;
    pos = cameraoffset();
    pos = pos.vadd(this.abspos);
    flip = false;
    if (!this._pixisprite) {
      this.spriteinit();
    }
    sprit = this._pixisprite;
    sprit.width = this.spritesize.x * this.value;
    return sprit.position = VTOPP(pos);
  };

  BugMeter.prototype.tick = function() {
    return this.update(ladybug.health);
  };

  BugMeter.prototype.update = function(value) {
    this.removesprite();
    return this.value = value;
  };

  EnergyMeter = (function(_super) {
    __extends(EnergyMeter, _super);

    function EnergyMeter() {
      EnergyMeter.__super__.constructor.call(this);
      this.src = 'energy1.png';
      this.abspos = V(0, 16);
    }

    return EnergyMeter;

  })(BugMeter);

  EnergyMeter.prototype.tick = function() {
    return this.update(ladybug.energy);
  };

  MoneyMeter = (function(_super) {
    __extends(MoneyMeter, _super);

    function MoneyMeter() {
      MoneyMeter.__super__.constructor.call(this);
      this.src = 'crown.png';
      this.spritesize = V(16, 16);
      this.abspos = V(8, 64 - 16);
    }

    MoneyMeter.prototype.tick = function() {
      return this.update(ladybug.score);
    };

    return MoneyMeter;

  })(BugMeter);

  blockdata = [];

  blockdata.push([-64, 64 * 5 - 4, 64 * 12, 100]);

  blockdata.push([64 * 4, 64 * 2, 32, 32]);

  blockdata.push([64 * 5, 64 * 4, 32, 32]);

  blockdata.push([64 * 6, 64 * 3, 32, 32]);

  blockdata.push([0, 64 * 4, 32, 32]);

  blockdata.push([32, 64 * 4, 64 * 2, 64 * 2]);

  blockdata.push([64 * 12, 64 * 4, 64 * 12, 200]);

  blockdata.push([128 + 8, 64 + 20, 64, 32]);

  blockdata.push([128 + 8 + 64, 64 + 20 + 32, 32, 32]);

  Block.prototype.toJSON = function() {
    return [this.x, this.y, this.w, this.h];
  };

  loadblocks = function(blockdata) {
    return blockdata.forEach(function(blockdatum) {
      var h, w, x, y;
      x = blockdatum[0], y = blockdatum[1], w = blockdatum[2], h = blockdatum[3];
      return WORLD.bglayer.push(new Block(x, y, w, h));
    });
  };

  scatterents = function(classproto, num) {
    var _i, _results;
    return WORLD.spritelayer = WORLD.spritelayer.concat((function() {
      _results = [];
      for (var _i = 0; 0 <= num ? _i < num : _i > num; 0 <= num ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(function() {
      return new classproto(randpos());
    }));
  };

  Goal = (function(_super) {
    __extends(Goal, _super);

    function Goal(pos) {
      this.pos = pos;
      Goal.__super__.constructor.call(this, this.pos);
      this.label = "GOAL";
    }

    return Goal;

  })(PlaceholderSprite);

  Goal.prototype.collide = function(otherent) {
    if (otherent instanceof Hero) {
      return nextlevel();
    }
  };

  HurtWire = (function(_super) {
    __extends(HurtWire, _super);

    function HurtWire() {
      _ref2 = HurtWire.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    return HurtWire;

  })(GenericSprite);

  HurtWire.prototype.size = V(8, 32);

  HurtWire.prototype.anchor = V(1 / 2, 0);

  HurtWire.prototype.getsprite = function() {
    var framelist, framewait;
    framewait = 1;
    framelist = [1, 2, 3, 4].map(function(n) {
      return "wirespark" + n + ".png";
    });
    return selectframe(framelist, framewait);
  };

  HurtWire.prototype.collide = function(otherent) {
    if (otherent instanceof Hero) {
      return otherent.takedamage();
    }
  };

  HurtWire.prototype.render = function() {
    this.src = this.getsprite();
    return HurtWire.__super__.render.call(this);
  };

  spawnables = {
    burd: Burd,
    target: Target,
    jelly: Jelly,
    powersuit: PowerSuit,
    gold: Gold,
    energy: Energy,
    lila: Lila
  };

  Spawner = (function(_super) {
    __extends(Spawner, _super);

    function Spawner(pos) {
      this.pos = pos;
      Spawner.__super__.constructor.call(this, this.pos);
      this.label = "Entity spawner";
      this.entdata = {
        "class": Jelly,
        pos: this.pos
      };
    }

    return Spawner;

  })(PlaceholderSprite);

  Spawner.prototype.tick = function() {
    return this.label = this.entdata["class"];
  };

  Spawner.prototype.spawn = function() {
    return loadents([this.entdata]);
  };

  entdata = [
    {
      "class": "lila",
      pos: {
        x: 64 * 4,
        y: 64 * 4
      }
    }
  ];

  jame = {};

  jame.spawn = function(classname) {
    var ent;
    if (!spawnables[classname]) {
      return;
    }
    ent = typeof spawnables[classname] === "function" ? new spawnables[classname]() : void 0;
    WORLD.spritelayer.push(ent);
    return ent;
  };

  loadent = function(entdatum) {
    var ent;
    ent = jame.spawn(entdatum["class"]);
    return ent.load(entdatum);
  };

  loadents = function(entdata) {
    return entdata.forEach(function(entdatum) {
      return loadent(entdatum);
    });
  };

  WORLD_ONE_INIT = function() {
    var hat, royaljel;
    scatterents(HurtWire, 4);
    scatterents(Target, 10);
    scatterents(Jelly, 10);
    scatterents(Energy, 10);
    scatterents(Gold, 10);
    scatterents(Thug, 3);
    WORLD.spritelayer.push(new PowerSuit(V(128, 32)));
    loadblocks(blockdata);
    loadents(entdata);
    placeshrub(V(64 * 8, 64 * 5 - 4));
    placeshrub(V(64 * 7 - 48, 64 * 5 - 4));
    placeshrub(V(64 * 9, 64 * 5 - 4));
    WORLD.spritelayer.push(new Goal(V(64 * 24, 64 * 4)));
    WORLD.spritelayer.push(royaljel = new Jelly(randpos()));
    WORLD.spritelayer.push(hat = new Hat());
    hat.src = 'crown.png';
    return hat.parent = royaljel;
  };

  WORLDINIT = function() {
    var bugmeter, energymeter;
    WORLD.entities.push(new Cloud());
    WORLD.entities.push(new Grid());
    bugmeter = new BugMeter;
    WORLD.entities.push(bugmeter);
    energymeter = new EnergyMeter;
    WORLD.entities.push(energymeter);
    WORLD.entities.push(new MoneyMeter);
    this.bugmeter = bugmeter;
    if (settings.hat) {
      WORLD.entities.push(new Hat());
    }
    return WORLD.bglayer.forEach(function(block) {
      var fence;
      fence = new Fence;
      fence.pos = relativetobox(block, V(0, 0));
      WORLD.spritelayer.push(fence);
      fence = new Fence;
      fence.pos = relativetobox(block, V(1, 0));
      return WORLD.spritelayer.push(fence);
    });
  };

  randtri = function() {
    return new Poly([randpos(), randpos(), randpos()]);
  };

  WORLD.getallents = function() {
    return [].concat(WORLD.entities, WORLD.spritelayer, WORLD.bglayer, WORLD.fglayer);
  };

  WORLD.clear = function() {
    var ALLENTS;
    ALLENTS = WORLD.getallents();
    ALLENTS.forEach(function(ent) {
      return removesprite(ent);
    });
    WORLD.entities = [];
    WORLD.spritelayer = [];
    WORLD.bglayer = [];
    return WORLD.fglayer = [];
  };

  roboblockdata = [];

  roboblockdata.push([-64, 64 * 4, 64 * 12, 100]);

  roboblockdata.push([64 * 12, 64 * 5, 64 * 12, 100]);

  ROBOWORLD_INIT = function() {
    scatterents(Burd, 8);
    loadblocks(roboblockdata);
    WORLD.spritelayer = WORLD.spritelayer.concat([0, 1, 2, 3].map(function() {
      return new Robo(randpos());
    }));
    return WORLD.spritelayer.push(randtri());
  };

  COLLTEST_INIT = function() {
    scatterents(Jelly, 8);
    loadblocks(roboblockdata);
    return WORLD.spritelayer.push(randtri());
  };

  WORLD_ONE_INIT();

  WORLDINIT();

  camera = {};

  jame.camera = camera;

  camera.offset = V();

  camera.pos = V();

  camera.trackingent = ladybug;

  cameraoffset = function() {
    var tmppos;
    tmppos = camera.trackingent.pos.nadd(0);
    tmppos.y -= 64;
    tmppos = tmppos.vsub(camera.offset.ndiv(scale));
    tmppos = tmppos.vsub(screensize.ndiv(2 * scale));
    return tmppos;
  };

  camera.tick = function() {
    return camera.pos = cameraoffset();
  };

  render = function() {
    var highlighted, renderables;
    camera.tick();
    renderables = [].concat(WORLD.bglayer, WORLD.spritelayer, [ladybug], WORLD.fglayer, WORLD.entities);
    renderables.forEach(function(ent) {
      return typeof ent.render === "function" ? ent.render() : void 0;
    });
    highlighted = renderables.filter(function(ent) {
      return ent.HIGHLIGHT != null;
    });
    if (settings.grid) {
      highlighted = renderables;
    }
    return drawhitboxes(highlighted);
  };

  drawhitboxes = function(ents) {
    var graf;
    stage.removeChild(hitboxlayer);
    hitboxlayer = new PIXI.DisplayObjectContainer;
    stage.addChild(hitboxlayer);
    graf = new PIXI.Graphics();
    graf.lineStyle(1, 0x00ff00, 1);
    graf.beginFill(0xff0000, 1 / 8);
    ents.forEach(function(ent) {
      var box, velbox;
      graf.lineStyle(1, 0x00ff00, 1);
      graf.drawCircle(ent.pos.x, ent.pos.y, 4);
      box = typeof ent.gethitbox === "function" ? ent.gethitbox() : void 0;
      if (!box) {
        return;
      }
      graf.drawRect(box.x, box.y, box.w, box.h);
      velbox = typeof ent.fallbox === "function" ? ent.fallbox() : void 0;
      if (!velbox) {
        return;
      }
      graf.lineStyle(1, 0x0000ff, 1);
      return graf.drawRect(velbox.x, velbox.y, velbox.w, velbox.h);
    });
    return hitboxlayer.addChild(graf);
  };

  timecall = function(func) {
    var starttime;
    starttime = Date.now();
    func();
    return Date.now() - starttime;
  };

  tickwaitms = 20;

  skipframes = 0;

  ticktimes = [];

  WORLD.resethitboxcache = function() {};

  WORLD.gethitbox = function(sprite) {
    return sprite.gethitbox();
  };

  checkcolls = function(ent, otherents) {
    var bawks;
    bawks = WORLD.gethitbox(ent);
    return otherents.forEach(function(target) {
      var targethitbox;
      if (target === ent) {
        return;
      }
      targethitbox = WORLD.gethitbox(target);
      if (bawks.overlaps(targethitbox)) {
        return typeof target.collide === "function" ? target.collide(ent) : void 0;
      }
    });
  };

  WORLD.euthanasia = function() {
    var doomedsprites;
    doomedsprites = WORLD.spritelayer.filter(function(sprite) {
      return sprite.KILLME != null;
    });
    doomedsprites.forEach(function(sprite) {
      return typeof sprite.cleanup === "function" ? sprite.cleanup() : void 0;
    });
    return WORLD.spritelayer = _.difference(WORLD.spritelayer, doomedsprites);
  };

  WORLD.tick = function() {
    var ACTIVEENTS, key, _base, _i, _len, _ref3;
    WORLD.resethitboxcache();
    _ref3 = control.heldkeys;
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      key = _ref3[_i];
      if (typeof (_base = control.holdbindings)[key] === "function") {
        _base[key]();
      }
    }
    checkcolls(ladybug, WORLD.spritelayer);
    WORLD.spritelayer.forEach(function(sprite) {
      return checkcolls(sprite, _.without(WORLD.spritelayer, sprite));
    });
    WORLD.euthanasia();
    ACTIVEENTS = [].concat(WORLD.spritelayer, [ladybug], WORLD.entities);
    ACTIVEENTS.forEach(function(ent) {
      return typeof ent.updatehitbox === "function" ? ent.updatehitbox() : void 0;
    });
    ACTIVEENTS.forEach(function(ent) {
      return typeof ent.tick === "function" ? ent.tick() : void 0;
    });
    render();
    return tickno++;
  };

  fpscounter = $(xmltag());

  tt = 0;

  updateinfobox = function() {
    text = control.heldkeys.map(function(key) {
      return "<span>" + key + "</span>";
    });
    return $(infobox).html(text.join(" "));
  };

  mainloop = function() {
    var fps, fpsgoal, idealfps, ticktime;
    updatesettingstable();
    updateinfobox();
    if (!settings.paused) {
      ticktime = timecall(WORLD.tick);
      tt = ticktime;
      fps = Math.round(1000 / Math.max(tickwaitms, ticktime));
      idealfps = Math.round(1000 / tickwaitms);
      fpscounter.html("tick time: " + tt + "ms, running at approx " + fps + " fps (aiming for " + idealfps + " fps)");
    }
    fpsgoal = settings.slowmo ? 1 : 60;
    tickwaitms = 1000 / fpsgoal;
    setTimeout(mainloop, Math.max(tickwaitms - ticktime, 1));
    return requestAnimFrame(animate);
  };

  xmlwrap = function(tagname, body) {
    return xmltag(tagname, void 0, body);
  };

  maketablerow = function(values) {
    var tds;
    tds = values.map(function(v) {
      return xmlwrap("td", v);
    });
    return xmlwrap("tr", tds);
  };

  jame.maketable = function(arrofarr) {
    var domelm, k, v;
    domelm = $('<table>');
    for (k in arrofarr) {
      v = arrofarr[k];
      domelm.append(maketablerow(v));
    }
    return domelm;
  };

  selectall = function(classname) {
    return jame.WORLD.spritelayer.filter(function(obj) {
      return obj.constructor.name === classname;
    });
  };

  jame.listents = function() {
    var ents;
    ents = _.pairs(_.countBy(jame.WORLD.spritelayer, function(obj) {
      return obj.constructor.name;
    }));
    return body.append(jame.maketable(ents));
  };

  infobox = $("<div>");

  infobox.css({
    float: "right",
    border: "1px solid black"
  });

  body.append(infobox);

  bindingsDOM = $("<table>");

  _ref3 = control.bindingnames;
  for (k in _ref3) {
    v = _ref3[k];
    bindingsDOM.append(maketablerow([keyCodeToChar[k], v || "??"]));
  }

  settingsDOM = $("<table>");

  updatesettingstable = function() {
    var _results;
    settingsDOM.html("");
    _results = [];
    for (k in settings) {
      v = settings[k];
      _results.push(settingsDOM.append(maketablerow([k, v])));
    }
    return _results;
  };

  INIT = function() {
    body.append(fpscounter);
    body.append("<b>bindings:</b>");
    body.append(bindingsDOM);
    body.append("<b>settings:</b>");
    body.append(settingsDOM);
    mainloop();
    return requestAnimFrame(animate);
  };

  INIT();

  adjustmouseevent = function(e) {
    var adjusted, coffs;
    coffs = $(renderer.view).offset();
    adjusted = V(e.pageX - coffs.left, e.pageY - coffs.top);
    adjusted = adjusted.ndiv(scale);
    adjusted = adjusted.vadd(camera.pos);
    adjusted = adjusted.op(Math.round);
    return adjusted;
  };

  Tool = (function() {
    function Tool() {}

    return Tool;

  })();

  NOOPTOOL = {
    name: 'noop',
    mousedown: (function() {}),
    mouseup: (function() {}),
    mousemove: (function() {})
  };

  BLOCKCREATIONTOOL = _.extend({}, NOOPTOOL, {
    name: 'create block',
    creatingblock: false,
    mousedown: function(e) {
      var adjusted;
      if (e.button !== 0) {
        return;
      }
      adjusted = adjustmouseevent(e);
      adjusted = snapmouseadjust(adjusted);
      BLOCKCREATIONTOOL.creatingblock = new Block(adjusted.x, adjusted.y, 32, 32);
      return WORLD.bglayer.push(BLOCKCREATIONTOOL.creatingblock);
    },
    mouseup: function(e) {
      if (e.button !== 0) {
        return;
      }
      BLOCKCREATIONTOOL.creatingblock.fixnegative();
      return BLOCKCREATIONTOOL.creatingblock = false;
    }
  });

  snapmouseadjust = function(mpos) {
    var gridsize, snaptogrid;
    snaptogrid = isholdingkey('z');
    if (snaptogrid) {
      gridsize = 32;
      mpos = mpos.ndiv(gridsize).op(Math.floor).nmul(gridsize);
    }
    return mpos;
  };

  MoveTool = (function(_super) {
    __extends(MoveTool, _super);

    function MoveTool() {
      _ref4 = MoveTool.__super__.constructor.apply(this, arguments);
      return _ref4;
    }

    return MoveTool;

  })(Tool);

  MoveTool.prototype.name = 'move entities';

  MoveTool.prototype.constructor = function() {
    return this.selected = [];
  };

  MoveTool.prototype.mouseup = function(e) {
    this.selected = [];
    return setcursor('auto');
  };

  MoveTool.prototype.mousemove = function(e) {
    var entsundercursor, isSelecting, p;
    this.selected = this.selected || [];
    isSelecting = this.selected.length > 0;
    p = adjustmouseevent(e);
    entsundercursor = getentsunderpoint(p);
    if (isSelecting) {
      setcursor('-moz-grabbing');
    } else {
      setcursor('auto');
    }
    if (entsundercursor.length > 0) {
      setcursor('-moz-grab');
    }
    p = snapmouseadjust(p);
    return this.selected.forEach(function(ent) {
      ent.pos = p;
      return ent.vel = V();
    });
  };

  getentsunderpoint = function(p) {
    return WORLD.spritelayer.filter(function(ent) {
      var box;
      box = typeof ent.gethitbox === "function" ? ent.gethitbox() : void 0;
      return box && box.containspoint(p);
    });
  };

  MoveTool.prototype.mousedown = function(e) {
    var entsundercursor, p;
    p = adjustmouseevent(e);
    entsundercursor = getentsunderpoint(p);
    console.log(entsundercursor);
    return this.selected = entsundercursor;
  };

  setcursor = function(cursorname) {
    return $(renderer.view).css('cursor', cursorname);
  };

  MOVETOOL = new MoveTool();

  MOVETOOL.selected = [];

  tool = MOVETOOL;

  $(renderer.view).mousedown(function(e) {
    return typeof tool.mousedown === "function" ? tool.mousedown(e) : void 0;
  });

  $(renderer.view).mouseup(function(e) {
    return typeof tool.mouseup === "function" ? tool.mouseup(e) : void 0;
  });

  $(renderer.view).mousemove(function(e) {
    return typeof tool.mousemove === "function" ? tool.mousemove(e) : void 0;
  });

  randposrel = function(p) {
    if (p == null) {
      p = V();
    }
    return p.vadd(mafs.randvec().vmul(V(32, 32)));
  };

  TRIANGLETOOL = _.extend({}, NOOPTOOL, {
    name: "add triangle",
    mousedown: function(e) {
      var p, triangle;
      p = adjustmouseevent(e);
      triangle = new Poly([randposrel(p), randposrel(p), randposrel(p)]);
      return WORLD.spritelayer.push(triangle);
    },
    mouseup: function(e) {},
    mousemove: function(e) {}
  });

  SPAWNTOOL = {
    name: 'Spawn entity'
  };

  SPAWNTOOL.classname = 'burd';

  SPAWNTOOL.mousedown = function(e) {
    var ent, p;
    p = adjustmouseevent(e);
    ent = jame.spawn(SPAWNTOOL.classname);
    return ent.pos = p;
  };

  SPAWNTOOL.mouseup = function(e) {};

  SPAWNTOOL.mousemove = function(e) {};

  SPAWNERTOOL = _.extend({}, NOOPTOOL, {
    name: 'Spawn entity',
    classname: 'burd',
    mousedown: function(e) {
      var ent, p;
      p = adjustmouseevent(e);
      WORLD.spritelayer.push(ent = new Spawner);
      ent.pos = p;
      ent.entdata["class"] = SPAWNTOOL.classname;
      return ent.spawn();
    }
  });

  alltools = [BLOCKCREATIONTOOL, MOVETOOL, TRIANGLETOOL, SPAWNERTOOL];

  toolbar = $(xmltag());

  toolbar.append($(xmltag('em', void 0, 'tools:')));

  toolbar.insertAfter($(renderer.view));

  alltools.forEach(function(t) {
    var but;
    but = $(xmltag('button', void 0, t.name));
    but.click(function() {
      return tool = t;
    });
    return toolbar.append(but);
  });

  allactions = {};

  readablebindings = function() {
    var ks, vs;
    ks = _.keys(control.bindingnames);
    vs = _.values(control.bindingnames);
    ks = ks.map(function(k) {
      return keyCodeToChar[Number(k)];
    });
    return _.zip(ks, vs);
  };

  allactions['export keybindings'] = function() {
    var data;
    data = JSON.stringify(readablebindings());
    window.open().document.write(data);
    return console.log(data);
  };

  allactions['export level'] = function() {
    var data;
    console.log(WORLD.bglayer);
    data = JSON.stringify(WORLD.bglayer);
    window.open().document.write(data);
    return console.log(data);
  };

  allactions['import level'] = function() {
    var data, rawdata;
    rawdata = prompt('paste data here');
    data = JSON.parse(rawdata);
    WORLD.clear();
    loadblocks(data);
    WORLDINIT();
    return ladybug.respawn();
  };

  allactions['load .json test level'] = function() {
    var levelfilename;
    levelfilename = "levels/2.json";
    return $.ajax(levelfilename, {
      success: function(data, status, xhr) {
        var jsondata;
        jsondata = JSON.parse(data);
        WORLD.clear();
        loadblocks(jsondata);
        WORLDINIT();
        return ladybug.respawn();
      }
    });
  };

  allactions['become queen of the slimes'] = function() {
    var hat;
    WORLD.spritelayer.push(hat = new Hat());
    hat.src = 'crown.png';
    return hat.parent = royaljel;
  };

  highlightoverlaps = function() {
    var alloverlaps, blox, flatlaps;
    blox = WORLD.bglayer;
    alloverlaps = blox.map(function(b) {
      return b.alloverlaps();
    });
    alloverlaps = alloverlaps.filter(function(i) {
      return i.length > 1;
    });
    flatlaps = _.flatten(alloverlaps);
    blox.forEach(function(b) {
      return b.HIGHLIGHT = void 0;
    });
    return flatlaps.forEach(function(b) {
      return b.HIGHLIGHT = true;
    });
  };

  allactions['highlight overlapping blocks'] = highlightoverlaps;

  toolbar.append($(xmltag('em', void 0, 'actions: ')));

  for (k in allactions) {
    v = allactions[k];
    but = $(xmltag('button', void 0, k));
    but.click(v);
    toolbar.append(but);
  }

  ORIGCLICKPOS = false;

  mousemiddledownhandler = function(e) {
    if (e.button !== 1) {
      return;
    }
    e.preventDefault();
    console.log("MIDDLE");
    return ORIGCLICKPOS = V(e.pageX, e.pageY);
  };

  mousemiddleuphandler = function(e) {
    if (e.button !== 1) {
      return;
    }
    e.preventDefault();
    ORIGCLICKPOS = false;
    return camera.offset = V();
  };

  mousemovehandler = function(e) {
    var creatingblock, currclickpos, mpos, offset;
    mpos = snapmouseadjust(adjustmouseevent(e));
    creatingblock = BLOCKCREATIONTOOL.creatingblock;
    if (creatingblock) {
      creatingblock.w = mpos.x - creatingblock.x;
      creatingblock.h = mpos.y - creatingblock.y;
      creatingblock.removesprite();
      creatingblock.tostone();
    }
    if (ORIGCLICKPOS) {
      currclickpos = V(e.pageX, e.pageY);
      offset = currclickpos.vsub(ORIGCLICKPOS);
      camera.offset = offset;
      return console.log(offset);
    }
  };

  $(renderer.view).mousemove(mousemovehandler);

  $(renderer.view).mousedown(mousemiddledownhandler);

  $(renderer.view).mouseup(mousemiddleuphandler);

  mouserightdownhandler = function(e) {
    var adjusted, blox, ent;
    if (e.button !== 2) {
      return;
    }
    e.preventDefault();
    adjusted = adjustmouseevent(e);
    blox = blocksatpoint(WORLD.bglayer, adjusted);
    console.log(blox);
    if (blox.length > 0) {
      ent = blox[0];
      WORLD.bglayer = _.without(WORLD.bglayer, ent);
      return removesprite(ent);
    }
  };

  $(renderer.view).mousedown(mouserightdownhandler);

  $(renderer.view).contextmenu(function() {
    return false;
  });

  $(renderer.view).bind('wheel', function(e) {
    var delta;
    e.preventDefault();
    delta = e.originalEvent.deltaY;
    up = delta > 0;
    console.log(delta);
    if (up) {
      scale -= 0.1;
    }
    if (!up) {
      return scale += 0.1;
    }
  });

  lastmodified = function(date) {
    return body.prepend("<p>last modified " + (jQuery.timeago(new Date(date))) + ", " + date + "</p>");
  };

  $.ajax(THISFILE, {
    type: "HEAD",
    success: function(data, satus, xhr) {
      return lastmodified(xhr.getResponseHeader("Last-Modified"));
    }
  });

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  spawnselection = $(xmltag('select'));

  for (classname in spawnables) {
    spawnselection.append($(xmltag('option', {
      value: classname
    }, classname)));
  }

  toolbar.append($(xmltag('em', void 0, "entity class:")));

  toolbar.append(spawnselection);

  spawnselection.change(function(e) {
    return SPAWNTOOL.classname = $(this).val();
  });

  jame.burdme = function() {
    ladybug = new PlayerBurd();
    WORLD.entities.push(ladybug);
    return console.log(ladybug);
  };

  jame.WORLD = WORLD;

  jame.control = control;

  root.jame = jame;

  root.stage = stage;

  Block.prototype.alloverlaps = function() {
    var blox,
      _this = this;
    blox = WORLD.bglayer;
    return blox.filter(function(otherblock) {
      return _this.overlaps(otherblock);
    });
  };

  Block.prototype.equals = function(b) {
    return this.x = b.x && (this.y = b.y && (this.w = b.w && (this.h = b.h)));
  };

  jame.cleanobj = function(obj) {
    var arr, key, val;
    arr = (function() {
      var _results;
      _results = [];
      for (key in obj) {
        if (!__hasProp.call(obj, key)) continue;
        val = obj[key];
        _results.push([key, val]);
      }
      return _results;
    })();
    return _.object(arr);
  };

}).call(this);
