// Generated by CoffeeScript 1.6.3
(function() {
  var BASETOOL, BLOCKCREATIONTOOL, BLOCKPAINT, B_MASKING, Block, BoggleParticle, BugLady, BugMeter, Bullet, Burd, CARVER, COLLTEST_INIT, Claire, Cloud, ControlObj, Energy, EnergyMeter, Fence, GenericSprite, Goal, Gold, Grid, HUDLAYER, Hat, Hero, HitboxRayIntersect, HurtWire, INIT, Jelly, Lila, Line2d, MOVEBLOCKTOOL, MOVETOOL, MoneyMeter, MoveBlockTool, MoveTool, NOOPTOOL, ORIGCLICKPOS, OnewayBlock, PP, PchooParticle, Pickup, PlaceholderSprite, Platform, Poly, PowerSuit, ROBOWORLD_INIT, Renderable, Robo, SCREENS, SPAWNERTOOL, SPAWNTOOL, Shrub, Smoochie, Spawner, Subscreen, TELEPORTTOOL, THISFILE, TRIANGLETOOL, Target, Thug, Tool, UNIONTOOL, V, VTOPP, WATERTOOL, WORLD, WORLDINIT, WORLD_ONE_INIT, Water, World, absurdboundbox, achieve, adjustedscreensize, adjustmouseevent, allactions, alltools, animate, audiobaseurl, availableactions, bglayerQuads, bglayer_remove_block, bindaction, bindingsDOM, blockcarve, blocksatpoint, body, bogglescreen, bogimg, bogsprite, bottomcenter, bottomof, boxesbounding, boxtouchingwall, bugspeed, but, camera, cameraoffset, cancelFullScreen, carveoutblock, cheatcodecheck, checkcolls, chievs, classname, closestpoint, control, down, drawhitboxes, drawsprite, entcenter, entdata, entitycount, eventelement, firebullet, fixbox, fpscounter, get_sprites_of_class, getentsunderpoint, getotherhero, highlightoverlaps, hitboxfilter, hitboxfilter_OLD, hitboxlayer, infobox, initsprite, isholdingbound, isholdingkey, jame, jump, k, keypushcache, kick, ladybug, lastmodified, launchFullScreen, left, leftof, load, loadblocks, loadent, loadents, loadlevel, loadlevelfile, loadspawners, mainloop, makebox, makechievbox, maketablerow, mousemiddledownhandler, mousemiddleuphandler, mouserightdownhandler, nextlevel, normalizekey, objnames, parentstage, pausefunc, pausescreen, pausetext, placeshrub, playsound, pointlisttoedges, punch, quadunwrap, quadwrap, randpos, randposrel, randtri, readablebindings, rejigCols, relativetobox, removesprite, render, renderer, resetstage, restartlevel, right, rightof, roboblockdata, root, save, scale, scatterents, screensize, selectall, selectframe, setcursor, settings, settingsDOM, skipframes, snapmouseadjust, snapmouseadjust_always, snapmouseadjust_down, sourcebaseurl, spawnables, spawnselection, stage, stageremovesprite, tex, text, tickno, ticktimes, tickwaitms, timecall, titlescreen, tmpcanvas, tmpcanvasjq, tmpinnerstage, tmpstage, toggleFullScreen, tool, toolbar, topof, tt, unzip, up, updateinfobox, updatesettingstable, v, xmlwrap, _CHARbindingnames, _DEFAULTHITBOXSIZE, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  THISFILE = "src/platformindev.coffee";

  settings = {
    fps: 30,
    drawsprites: true,
    slowmo: false,
    altcostume: true,
    beanmode: false,
    muted: true,
    paused: false,
    volume: 0.2,
    decemberween: false,
    hat: false
  };

  settings.scale = 1;

  screensize = new V2d(960, 540);

  sourcebaseurl = "./sprites/";

  audiobaseurl = "./audio/";

  mafs.randfloat = function() {
    return -1 + Math.random() * 2;
  };

  mafs.randvec = function() {
    return V(mafs.randfloat(), mafs.randfloat());
  };

  mafs.randint = function(max) {
    return Math.floor(Math.random() * max);
  };

  mafs.randelem = function(arr) {
    return arr[mafs.randint(arr.length)];
  };

  mafs.degstorads = function(degs) {
    return degs * Math.PI / 180;
  };

  Line2d = (function() {
    function Line2d(p1, p2) {
      this.p1 = p1;
      this.p2 = p2;
    }

    return Line2d;

  })();

  Line2d.prototype.lineintersect = function(lineb) {
    var linea, p, q, r, s, t, u;
    linea = this;
    p = linea.p1;
    r = linea.p2.vsub(p);
    q = lineb.p1;
    s = lineb.p2.vsub(q);
    t = q.vsub(p).cross2d(s) / r.cross2d(s);
    u = q.vsub(p).cross2d(r) / r.cross2d(s);
    if (t <= 1 && t >= 0 && u <= 1 && u >= 0) {
      return p.vadd(r.nmul(t));
    }
    return null;
  };

  HitboxRayIntersect = function(rect, line) {
    var a, b, dx, maxx, maxy, minx, miny, tmp;
    minx = line.p1.x;
    maxx = line.p2.x;
    if (line.p1.x > line.p2.x) {
      minx = line.p2.x;
      maxx = line.p1.x;
    }
    maxx = Math.min(maxx, rect.bottomright.x);
    minx = Math.max(minx, rect.topleft.x);
    if (minx > maxx) {
      return false;
    }
    miny = line.p1.y;
    maxy = line.p2.y;
    dx = line.p2.x - line.p1.x;
    if (Math.abs(dx) > 0.0000001) {
      a = (line.p2.y - line.p1.y) / dx;
      b = line.p1.y - a * line.p1.x;
    }
    miny = a * minx + b;
    maxy = a * maxx + b;
    if (miny > maxy) {
      tmp = maxy;
      maxy = miny;
      miny = tmp;
    }
    maxy = Math.min(maxy, rect.bottomright.y);
    miny = Math.max(miny, rect.topleft.y);
    if (miny > maxy) {
      return false;
    }
    return true;
  };

  pointlisttoedges = function(parr) {
    var curr, edges, i, prev, _i, _len;
    edges = [];
    prev = parr[parr.length - 1];
    for (i = _i = 0, _len = parr.length; _i < _len; i = ++_i) {
      curr = parr[i];
      edges.push(new Line2d(prev, curr));
      prev = curr;
    }
    return edges;
  };

  body = $("body");

  V = function(x, y) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    return new V2d(x, y);
  };

  PP = function(x, y) {
    return new PIXI.Point(x, y);
  };

  VTOPP = function(v) {
    return PP(v.x, v.y);
  };

  playsound = function(src) {
    var snd;
    if (settings.muted) {
      return;
    }
    snd = new Audio(audiobaseurl + src);
    snd.volume = settings.volume;
    return snd.play();
  };

  parentstage = new PIXI.Stage(0x66FF99);

  stage = new PIXI.DisplayObjectContainer;

  parentstage.addChild(stage);

  resetstage = function() {
    parentstage.removeChild(stage);
    stage = new PIXI.DisplayObjectContainer;
    return parentstage.addChild(stage);
  };

  HUDLAYER = new PIXI.DisplayObjectContainer;

  parentstage.addChild(HUDLAYER);

  hitboxlayer = new PIXI.DisplayObjectContainer;

  stage.addChild(hitboxlayer);

  renderer = PIXI.autoDetectRenderer(screensize.x, screensize.y);

  pausescreen = new PIXI.Graphics();

  pausescreen.beginFill(0x000000);

  pausescreen.drawRect(0, 0, screensize.x, screensize.y);

  pausescreen.alpha = 0.5;

  pausetext = new PIXI.Text("PAUSED", {
    font: "32px Arial",
    fill: "white",
    strokeThickness: 8,
    stroke: 'red'
  });

  pausetext.position = VTOPP(screensize.ndiv(2));

  pausetext.anchor = PP(1 / 2, 1);

  pausescreen.addChild(pausetext);

  pausetext = new PIXI.Text("GO GET SOME SNACKS\nPERHAPS A CARBONATED SODA", {
    font: "16px Arial",
    fill: "white"
  });

  pausetext.position = VTOPP(screensize.ndiv(2).vadd(V(0, 64)));

  pausetext.anchor = PP(1 / 2, 0);

  pausescreen.addChild(pausetext);

  bogglescreen = new PIXI.Graphics();

  bogglescreen.beginFill(0xFF00FF);

  bogglescreen.drawRect(0, 0, screensize.x, screensize.y);

  bogglescreen.alpha = 0.5;

  tex = PIXI.Texture.fromImage(sourcebaseurl + 'smooch.png');

  bogsprite = new PIXI.Sprite(tex);

  bogsprite.anchor = PP(1 / 2, 1 / 2);

  bogsprite.position = VTOPP(screensize.ndiv(2));

  bogsprite.scale = PP(2, 2);

  text = new PIXI.Text("wow a secret\nwarning, the following sprite is EXTREMELY CANON and EXTREMELY SEXY,\nchildrens avert your eyes", {
    font: "16px Arial",
    fill: "white"
  });

  text.position = VTOPP(screensize.ndiv(2).vadd(V(0, -128)));

  text.anchor = PP(1 / 2, 0);

  bogglescreen.addChild(text);

  bogglescreen.addChild(bogsprite);

  tex = PIXI.Texture.fromImage(sourcebaseurl + 'titleplaceholder.png');

  titlescreen = new PIXI.Sprite(tex);

  body.append(renderer.view);

  B_MASKING = false;

  Subscreen = (function() {
    function Subscreen() {
      this.size = screensize.ndiv(4);
      this.screenpos = V(640 * Math.random(), 640 * Math.random());
      this.subscreen = new PIXI.RenderTexture(this.size.x, this.size.y);
      this.subsprite = new PIXI.Sprite(this.subscreen);
      parentstage.addChild(this.subsprite);
      if (B_MASKING) {
        this.mask = new PIXI.Graphics();
        parentstage.addChild(this.mask);
      }
    }

    return Subscreen;

  })();

  Subscreen.prototype.subscreenadjust = function() {
    var hero, maxpos, newpos, oldpos, p1, p2, subscreencentercam, tmpdirection, tmpv;
    maxpos = screensize.vsub(this.size);
    hero = getotherhero();
    p1 = ladybug.pos;
    p2 = hero.pos;
    tmpdirection = p2.vsub(p1).norm();
    tmpv = tmpdirection.nadd(1);
    tmpv = tmpv.ndiv(2);
    newpos = maxpos.vmul(tmpv);
    this.screenpos = newpos;
    this.subsprite.position = VTOPP(this.screenpos);
    subscreencentercam = hero.pos.nmul(-scale);
    subscreencentercam = subscreencentercam.vadd(this.size.ndiv(2));
    parentstage.removeChild(this.subsprite);
    oldpos = stage.position;
    stage.position = VTOPP(subscreencentercam);
    this.subscreen.render(parentstage);
    stage.position = oldpos;
    parentstage.addChild(this.subsprite);
    if (B_MASKING) {
      this.maskupdate();
      return this.subsprite.mask = this.mask;
    }
  };

  Subscreen.prototype.maskupdate = function() {
    this.mask.clear();
    this.mask.beginFill(0x000000, 0.9);
    this.mask.moveTo(this.screenpos.x, this.screenpos.y + 32);
    this.mask.lineTo(this.screenpos.x + this.size.x, this.screenpos.y);
    this.mask.lineTo(this.screenpos.x + this.size.x, this.screenpos.y + this.size.y - 32);
    this.mask.lineTo(this.screenpos.x, this.screenpos.y + this.size.y);
    return this.mask.endFill();
  };

  SCREENS = {
    list: []
  };

  SCREENS.add = function() {
    return SCREENS.list.push(new Subscreen());
  };

  SCREENS.adjust = function() {
    return this.list.forEach(function(screen) {
      return screen.subscreenadjust();
    });
  };

  SCREENS.add();

  scale = 1;

  tmpstage = new PIXI.DisplayObjectContainer();

  tmpinnerstage = new PIXI.DisplayObjectContainer();

  tmpstage.addChild(tmpinnerstage);

  animate = function() {
    var cam;
    cam = cameraoffset().nmul(-scale);
    stage.position = VTOPP(cam);
    stage.scale = PP(scale, scale);
    renderer.render(parentstage);
    return SCREENS.adjust();
  };

  chievs = {};

  achieve = function(title) {
    if (chievs[title].gotten != null) {
      return;
    }
    chievs[title].gotten = true;
    return makechievbox(chievs[title].pic, mafs.randelem(chievs[title].text));
  };

  bogimg = xmltag('img', {
    src: sourcebaseurl + 'boggle.png'
  });

  chievs.fall = {
    pic: "lovelyfall.png",
    text: ["Fractured spine", "Faceplant", "Dats gotta hoit", "OW FUCK", "pomf =3", "Broken legs", "Have a nice trip", "Ow my organs", "Shattered pelvis", "Bugsplat"]
  };

  chievs.kick = {
    pic: "jelly.png",
    text: ["3 points field goal", "Into the dunklesphere", "Blasting off again", "pow zoom straight to the moon"]
  };

  chievs.boggle = {
    pic: "boggle.png",
    text: ["Buggy the boggle champ", "Bushboggler 2013", "Boggle that bush", "Collosal waste of time", "Boggle 2: Electric boggleoo", "Buggy bushboggle", "excuse me wtf are you doing", "Bush it, bush it real good", "Fondly regard flora", "&lt;chievo title unavailable due to trademark infringement&gt;", "Returning a bug to its natural habitat", "Bush it to the limit", "Live Free or Boggle Hard", "Identifying bushes, accurate results with simple tools", "Bugtester", "A proper lady (bug)", "Stupid achievement title", "The daily boggle", bogimg + bogimg + bogimg]
  };

  chievs.murder = {
    pic: "lovelyshorter.png",
    text: ["This isn't brave, it's murder", "Jellycide"]
  };

  chievs.target = {
    pic: "target.png",
    text: ["there's no achievement for this", "\"Pow, motherfucker, pow\" -socrates", "Expect more. Pay less.", "You're supposed to use arrows you dingus"]
  };

  chievs.start = {
    pic: "crown.png",
    text: ["wow u started playin the game, congrats", "walking to the right", "chievo modern gaming edition", "baby's first achievement"]
  };

  makechievbox = function(src, text) {
    var chievbox, pic, style;
    style = "style='display: inline-block; margin-left: 16px'";
    body.append(chievbox = $("<div class=chievbox><span " + style + "><b>ACHIEVEMENT UNLOCKED</b><br/>" + text + "</span></div>"));
    chievbox.prepend(pic = $(xmltag('img', {
      src: sourcebaseurl + src
    })));
    chievbox.animate({
      top: '32px'
    }).delay(4000);
    return chievbox.animate({
      top: '-100px'
    }, {
      queue: true
    }).delay(2000);
  };

  Renderable = (function() {
    function Renderable() {
      this.pos = V();
    }

    return Renderable;

  })();

  Renderable.prototype.hassprite = function() {
    return typeof this._pixisprite !== "undefined";
  };

  Renderable.prototype.removesprite = function() {
    return removesprite(this);
  };

  GenericSprite = (function(_super) {
    __extends(GenericSprite, _super);

    function GenericSprite(pos, src) {
      this.pos = pos != null ? pos : V();
      this.src = src;
      this.vel = V();
    }

    GenericSprite.prototype.render = function() {
      var anchor, box, flip, pos;
      anchor = this.anchor || V(0, 0);
      flip = !this.facingleft;
      box = this.gethitbox();
      pos = relativetobox(box, anchor);
      return drawsprite(this, this.src, pos, flip, anchor);
    };

    return GenericSprite;

  })(Renderable);

  GenericSprite.prototype.cleanup = function() {
    return removesprite(this);
  };

  GenericSprite.prototype.load = function(obj) {
    if (obj.pos != null) {
      return _.extend(this.pos, obj.pos);
    }
  };

  Hat = (function(_super) {
    __extends(Hat, _super);

    function Hat() {
      Hat.__super__.constructor.call(this);
      this.src = "hat.png";
      this.anchor = V(1 / 2, 1);
      this.parent = ladybug;
    }

    return Hat;

  })(GenericSprite);

  Hat.prototype.tick = function() {
    this.vel = this.parent.vel;
    this.pos = relativetobox(this.parent.gethitbox(), V(1 / 2, 0));
    return this.pos = this.pos.vadd(this.vel);
  };

  _DEFAULTHITBOXSIZE = V(32, 32);

  GenericSprite.prototype.gethitbox = function() {
    var anchor, size;
    size = this.size || _DEFAULTHITBOXSIZE;
    anchor = this.anchor || V(1 / 2, 1 / 2);
    this.hitboxcache = makebox(this.pos, size, anchor);
    return this.hitboxcache;
  };

  GenericSprite.prototype.updatehitbox = function() {
    var anchor, h, size, w, x, y, _ref;
    size = this.size || _DEFAULTHITBOXSIZE;
    anchor = this.anchor || V(1 / 2, 1 / 2);
    if (this.hitboxcache != null) {
      _ref = fixbox(this.pos, size, anchor), x = _ref[0], y = _ref[1], w = _ref[2], h = _ref[3];
      this.hitboxcache.x = x;
      this.hitboxcache.y = y;
      this.hitboxcache.w = w;
      this.hitboxcache.h = h;
    }
    return this.hitboxcache;
  };

  fixbox = function(position, dimensions, anchor) {
    var truepos;
    truepos = position.vsub(dimensions.vmul(anchor));
    return [truepos.x, truepos.y, dimensions.x, dimensions.y];
  };

  Target = (function(_super) {
    __extends(Target, _super);

    function Target(pos) {
      this.pos = pos;
      Target.__super__.constructor.call(this, this.pos, 'target.png');
      this.lifetime = -1;
      this.anchor = V(1 / 2, 1 / 2);
    }

    Target.prototype.collide = function(otherent) {
      if (otherent instanceof BoggleParticle) {
        this.vel = this.vel.vadd(otherent.vel.nmul(1 / 8));
      }
      if ((otherent.attacktimeout != null) && otherent.attacktimeout > 0) {
        return this.gethitby(otherent);
      }
    };

    Target.prototype.gethitby = function(otherent) {
      if (!this.broken) {
        this.broken = true;
        this.src = 'shatteredtarget.png';
        this.vel = otherent.vel.nmul(1 / 2);
        return this.lifetime = 10;
      }
    };

    return Target;

  })(GenericSprite);

  Jelly = (function(_super) {
    __extends(Jelly, _super);

    function Jelly(pos) {
      this.pos = pos;
      Jelly.__super__.constructor.call(this, this.pos, 'jelly.png');
    }

    Jelly.prototype.collide = function(otherent) {
      var timeout;
      if (otherent instanceof Jelly) {
        this.vel.x = (this.vel.x + otherent.vel.x) / 2;
        this.pos.x += mafs.randfloat() * 2;
      }
      if (otherent instanceof BoggleParticle) {
        this.vel = this.vel.vadd(otherent.vel.nmul(1 / 8));
      }
      if (otherent instanceof BugLady && otherent.vel.y > 0) {
        otherent.vel.y *= -2;
      }
      timeout = otherent.attacktimeout;
      if ((timeout != null) && timeout > 0) {
        return this.gethitby(otherent);
      }
    };

    Jelly.prototype.gethitby = function(otherent) {
      var dir;
      this.vel.y += otherent.vel.y;
      dir = otherent.facingleft ? -1 : 1;
      return this.vel.x += dir * 4;
    };

    Jelly.prototype.render = function() {
      var anchor, flip, pos;
      flip = tickno % 10 < 5;
      anchor = V(1 / 2, 1);
      pos = relativetobox(this.gethitbox(), anchor);
      return drawsprite(this, this.src, pos, flip, anchor);
    };

    return Jelly;

  })(GenericSprite);

  Jelly.prototype.size = V(32, 16);

  Jelly.prototype.anchor = V(1 / 2, 1);

  entitycount = function(classtype) {
    var ents;
    ents = WORLD.spritelayer.filter(function(sprite) {
      return sprite instanceof classtype;
    });
    return ents.length;
  };

  GenericSprite.prototype.gravitate = function() {
    if (!this.touchingground()) {
      return this.vel.y++;
    }
  };

  Jelly.prototype.tick = function() {
    this.physmove();
    if (this.touchingground()) {
      this.jiggle();
      return this.pos.y--;
    }
  };

  Jelly.prototype.jiggle = function() {
    this.vel.x *= 9 / 10;
    if (Math.random() * 100 < 50) {
      this.vel.y = -Math.random() * 4;
      return this.vel.x += mafs.randfloat() * 1;
    }
  };

  Fence = (function(_super) {
    __extends(Fence, _super);

    function Fence() {
      Fence.__super__.constructor.call(this);
      this.anchor = V(1 / 2, 1);
    }

    return Fence;

  })(GenericSprite);

  Fence.prototype.render = function() {};

  Pickup = (function(_super) {
    __extends(Pickup, _super);

    function Pickup(pos) {
      this.pos = pos;
      this.vel = V();
      this.src = "energy1.png";
    }

    return Pickup;

  })(Jelly);

  Pickup.prototype.jiggle = function() {};

  Pickup.prototype.collide = function(otherent) {
    if (otherent instanceof BugLady) {
      return this.pickedup(otherent);
    }
  };

  Pickup.prototype.pickedup = function(otherent) {
    playsound('boip.wav');
    return this.KILLME = true;
  };

  Energy = (function(_super) {
    __extends(Energy, _super);

    function Energy(pos) {
      this.pos = pos;
      this.vel = V();
      this.src = "energy1.png";
    }

    return Energy;

  })(Pickup);

  Energy.prototype.getsprite = function() {
    var framelist;
    framelist = [1, 2, 3, 4, 5, 6].map(function(n) {
      return "energy" + n + ".png";
    });
    return this.src = selectframe(framelist, 4);
  };

  Energy.prototype.tick = function() {
    Energy.__super__.tick.call(this);
    return this.getsprite();
  };

  Energy.prototype.pickedup = function(otherent) {
    Energy.__super__.pickedup.call(this);
    return otherent.energy += 1;
  };

  Gold = (function(_super) {
    __extends(Gold, _super);

    function Gold(pos) {
      this.pos = pos;
      this.vel = V();
      this.src = "crown.png";
    }

    return Gold;

  })(Pickup);

  Gold.prototype.getsprite = function() {};

  Gold.prototype.pickedup = function(otherent) {
    Gold.__super__.pickedup.call(this);
    return otherent.score += 1;
  };

  relativetobox = function(box, anchor) {
    var pos, size;
    pos = V(box.x, box.y);
    size = V(box.w, box.h);
    pos = pos.vadd(size.vmul(anchor));
    return pos;
  };

  Thug = (function(_super) {
    __extends(Thug, _super);

    function Thug(pos) {
      this.pos = pos != null ? pos : V();
      this.lifetime = -1;
      this.vel = V();
      this.src = 'bugthug.png';
      this.facingleft = true;
      this.health = 3;
    }

    return Thug;

  })(GenericSprite);

  bottomcenter = V(1 / 2, 1);

  Thug.prototype.size = V(24, 64 + 16);

  Thug.prototype.anchor = bottomcenter;

  Thug.prototype.tick = function() {
    this.physmove();
    return this.getsprite();
  };

  Thug.prototype.getsprite = function() {
    if (this.lifetime <= 0) {
      this.src = 'bugthug.png';
    }
    if (this.health <= 0) {
      this.src = 'thugded.png';
    }
    if (this.lifetime > 0) {
      this.lifetime--;
      return this.src = "bugthugoof.png";
    }
  };

  Thug.prototype.collide = function(otherent) {
    if (otherent instanceof BoggleParticle) {
      this.vel = this.vel.vadd(otherent.vel.nmul(1 / 8));
    }
    if ((otherent.attacktimeout != null) && otherent.attacktimeout > 0 && this.lifetime <= 0) {
      return this.gethitby(otherent);
    }
  };

  Thug.prototype.gethitby = function(otherent) {
    var dir;
    this.vel.y += otherent.vel.y;
    dir = otherent.facingleft ? -1 : 1;
    this.vel.x += dir * 1;
    this.lifetime = 10;
    return this.health -= 1;
  };

  Lila = (function(_super) {
    __extends(Lila, _super);

    function Lila() {
      _ref = Lila.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return Lila;

  })(Thug);

  Robo = (function(_super) {
    __extends(Robo, _super);

    function Robo() {
      _ref1 = Robo.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return Robo;

  })(Thug);

  Lila.prototype.scampersubroutine = Robo.prototype.scampersubroutine = function() {
    if (!this.scampering && Math.random() < 1 / 10) {
      this.scampering = true;
    }
    if (this.scampering && Math.random() < 1 / 10) {
      this.scampering = false;
    }
    if (this.scampering && Math.abs(this.vel.x) < 3) {
      this.vel.x += this.facingleft ? -this.scamperspeed : this.scamperspeed;
    }
    if (!this.scampering && Math.random() < 1 / 20) {
      return this.facingleft = !this.facingleft;
    }
  };

  Lila.prototype.tick = function() {
    if (this.kisstimeout > 0) {
      this.kisstimeout--;
    }
    Lila.__super__.tick.call(this);
    if (this.kisstimeout > 50) {
      return;
    }
    this.scamperspeed = 2;
    return this.scampersubroutine();
  };

  Robo.prototype.visioncheck = function() {
    var CENTER, dim, visionarea;
    CENTER = V(1 / 2, 1 / 2);
    dim = 64 * 4;
    visionarea = makebox(this.pos, V(dim, dim), CENTER);
    return this.angry = visionarea.containspoint(ladybug.pos);
  };

  Robo.prototype.tick = function() {
    var isdead;
    Robo.__super__.tick.call(this);
    isdead = this.health <= 0;
    this.state = this.scampering ? "attacking" : "idle";
    if (isdead) {
      this.scampering = false;
      return;
    }
    this.visioncheck();
    this.scamperspeed = 1;
    if (this.angry) {
      this.scamperspeed = 3;
    }
    return this.scampersubroutine();
  };

  selectframe = function(framelist, framewait) {
    var framechoice, totalframes;
    totalframes = framelist.length;
    framechoice = Math.floor(tickno / framewait) % totalframes;
    return framelist[framechoice];
  };

  Lila.prototype.getsprite = function() {
    var framelist, framewait, idlecycle, n, scampercycle;
    idlecycle = ['lilaidle1.png', 'lilaidle2.png'];
    scampercycle = (function() {
      var _i, _results;
      _results = [];
      for (n = _i = 1; _i <= 4; n = ++_i) {
        _results.push("lilascamper" + n + ".png");
      }
      return _results;
    })();
    framewait = 4;
    framelist = idlecycle;
    if (!this.scampering) {
      framewait = 20;
    }
    if (this.scampering) {
      framelist = scampercycle;
    }
    if (this.kisstimeout > 90) {
      framelist = ["lilakiss.png"];
    }
    return this.src = selectframe(framelist, framewait);
  };

  Robo.prototype.getsprite = function() {
    var framelist, framewait, idlecycle, scampercycle;
    idlecycle = ['roboroll1.png'];
    scampercycle = [1, 2].map(function(n) {
      return "roboroll" + n + ".png";
    });
    if (this.angry) {
      idlecycle = [1, 2].map(function(n) {
        return "roborage" + n + ".png";
      });
      scampercycle = [2, 3, 4].map(function(n) {
        return "roborage" + n + ".png";
      });
    }
    framelist = idlecycle;
    if (this.scampering) {
      framelist = scampercycle;
    }
    if (this.lifetime > 0) {
      this.lifetime--;
      framelist = ["robohurt.png"];
    }
    if (this.health <= 0) {
      framelist = ["robobody.png"];
    }
    if (this.health <= 0 && this.lifetime === 0 && this.touchingground()) {
      framelist = ["roboded.png"];
    }
    framewait = 4;
    return this.src = selectframe(framelist, framewait);
  };

  Robo.prototype.collide = function(otherent) {
    if (otherent instanceof Hero && this.state === "attacking") {
      return otherent.takedamage();
    }
  };

  Lila.prototype.collide = function(otherent) {
    var offs;
    if (otherent instanceof BoggleParticle) {
      if (!(this.kisstimeout > 0)) {
        ladybug.heal();
        WORLD.spritelayer.push(new Smoochie(this.pos));
      }
      this.kisstimeout = 100;
    }
    if (otherent instanceof Fence) {
      this.vel.x = 0;
      offs = otherent.pos.x < this.pos.x ? 1 : -1;
      return this.pos.x += offs;
    }
  };

  Burd = (function(_super) {
    __extends(Burd, _super);

    function Burd(pos) {
      this.pos = pos != null ? pos : V();
      this.vel = V(0, 0);
      this.anchor = V(1 / 2, 1 / 2);
      this.src = 'burd.png';
    }

    return Burd;

  })(GenericSprite);

  Burd.prototype.tick = function() {
    var dir, lpos;
    this.getsprite();
    this.pos = this.pos.vadd(this.vel);
    lpos = ladybug.pos || V();
    dir = lpos.vsub(this.pos).norm();
    this.vel = this.vel.vadd(dir);
    if (this.vel.mag() > 10) {
      return this.vel = this.vel.norm().nmul(10);
    }
  };

  Burd.prototype.render = function() {
    var anchor, flip, pos;
    anchor = this.anchor || V(0, 0);
    flip = false;
    pos = relativetobox(this.gethitbox(), anchor);
    drawsprite(this, this.src, pos, flip, anchor);
    this._pixisprite.scale.x = 1 / 3;
    return this._pixisprite.scale.y = 1 / 3;
  };

  Burd.prototype.getsprite = function() {
    var framelist;
    framelist = ['burd.png', 'burdflap.png'];
    return this.src = mafs.randelem(framelist);
  };

  Burd.prototype.collide = function(otherent) {
    var timeout;
    if (otherent instanceof BoggleParticle) {
      this.vel = this.vel.vadd(otherent.vel.nmul(1 / 8));
    }
    timeout = otherent.attacktimeout;
    if ((timeout != null) && timeout > 0) {
      return this.gethitby(otherent);
    }
  };

  Burd.prototype.gethitby = function(otherent) {
    var dir;
    this.vel.y += otherent.vel.y;
    dir = otherent.facingleft ? -1 : 1;
    this.vel.x += dir * 4;
    return this.lifetime = 10;
  };

  BoggleParticle = (function(_super) {
    __extends(BoggleParticle, _super);

    function BoggleParticle(pos) {
      this.pos = pos != null ? pos : V();
      this.vel = mafs.randvec().norm();
      this.src = 'huh.png';
      this.life = 50;
    }

    BoggleParticle.prototype.tick = function() {
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      this.pos = this.pos.vadd(this.vel);
      return this.vel = this.vel.vadd(mafs.randvec().norm().ndiv(8));
    };

    return BoggleParticle;

  })(GenericSprite);

  BoggleParticle.prototype.render = function() {
    return drawsprite(this, 'huh.png', this.pos, false);
  };

  Smoochie = (function(_super) {
    __extends(Smoochie, _super);

    function Smoochie(pos) {
      this.pos = pos;
      this.anchor = V(1 / 2, 1);
      this.vel = mafs.randvec().norm();
      this.src = 'kissparticle1.png';
      this.life = 50;
    }

    Smoochie.prototype.tick = function() {
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      this.pos = this.pos.vadd(this.vel);
      this.vel = this.vel.vadd(mafs.randvec().norm().ndiv(8));
      return this.vel = this.vel.vadd(V(0, -1 / 8));
    };

    Smoochie.prototype.render = function() {
      Smoochie.__super__.render.call(this);
      this.src = this.getsprite();
      return this._pixisprite.rotation = mafs.degstorads(Math.cos(this.life / 100) * 10);
    };

    return Smoochie;

  })(GenericSprite);

  Smoochie.prototype.getsprite = function() {
    var framelist, framewait;
    framewait = 16;
    framelist = [1, 2, 3].map(function(n) {
      return "kissparticle" + n + ".png";
    });
    return selectframe(framelist, framewait);
  };

  PchooParticle = (function(_super) {
    __extends(PchooParticle, _super);

    function PchooParticle(pos) {
      this.pos = pos != null ? pos : V();
      this.vel = mafs.randvec().norm().ndiv(8);
      this.life = 20;
      this.src = 'bughealth.png';
      this.anchor = V(1 / 2, 1 / 2);
    }

    PchooParticle.prototype.tick = function() {
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      this.pos = this.pos.vadd(this.vel);
      return this.vel = this.vel.vadd(mafs.randvec().norm().ndiv(64));
    };

    PchooParticle.prototype.render = function() {
      drawsprite(this, this.src, this.pos, false, this.anchor);
      return this._pixisprite.alpha = 0.25;
    };

    return PchooParticle;

  })(GenericSprite);

  Bullet = (function(_super) {
    __extends(Bullet, _super);

    function Bullet(pos) {
      this.pos = pos != null ? pos : V();
      this.owner = void 0;
      this.vel = V(8, 0);
      this.life = 20;
      this.src = 'particlepunch.png';
      this.anchor = V(1 / 2, 1 / 2);
    }

    Bullet.prototype.tick = function() {
      this.life--;
      if (this.life <= 0) {
        this.KILLME = true;
      }
      this.pos = this.pos.vadd(this.vel);
      return this.vel = this.vel.vadd(mafs.randvec().norm().ndiv(64));
    };

    Bullet.prototype.render = function() {
      var flip;
      flip = this.vel.x < 0;
      drawsprite(this, this.src, this.pos, flip, this.anchor);
      return this._pixisprite.alpha = 0.8;
    };

    return Bullet;

  })(GenericSprite);

  Bullet.prototype.collide = function(otherent) {
    if ((otherent.health != null) && otherent !== this.owner) {
      if (typeof otherent.gethitby === "function") {
        otherent.gethitby(this.owner);
      }
      return this.KILLME = true;
    }
  };

  Target.prototype.tick = function() {
    this.vel = this.vel.nmul(7 / 10);
    this.pos = this.pos.vadd(this.vel);
    if (this.lifetime === 0) {
      this.KILLME = true;
    }
    if (this.lifetime > 0) {
      this.lifetime--;
    }
    if (this.lifetime === 0 && entitycount(Target) === 1) {
      return achieve("target");
    }
  };

  isholdingkey = function(key) {
    key = key.toUpperCase().charCodeAt(0);
    return __indexOf.call(control.heldkeys, key) >= 0;
  };

  isholdingbound = function(name) {
    var keys;
    keys = control.heldkeys.map(function(key) {
      return control.bindingnames[key];
    });
    return __indexOf.call(keys, name) >= 0;
  };

  Hero = (function(_super) {
    __extends(Hero, _super);

    function Hero() {
      Hero.__super__.constructor.call(this);
      this.jumping = false;
      this.attacking = false;
      this.attacktimeout = 0;
      this.stuntimeout = 0;
      this.health = 3;
      this.energy = 0;
      this.score = 0;
      this.facingleft = false;
      this.anchor = V(1 / 2, 1);
    }

    return Hero;

  })(GenericSprite);

  BugLady = (function(_super) {
    __extends(BugLady, _super);

    function BugLady() {
      BugLady.__super__.constructor.call(this);
      this.invincibletimeout = 0;
      this.controls = {};
    }

    return BugLady;

  })(Hero);

  BugLady.prototype.heal = function() {
    return this.health = 3;
  };

  BugLady.prototype.respawn = function() {
    this.pos = V();
    this.vel = V();
    return this.heal();
  };

  BugLady.prototype.flinch = function() {
    this.vel = this.vel.vmul(V(-1, 1));
    return this.invincibletimeout = 20;
  };

  Hero.prototype.gethitby = function(otherent) {
    return this.takedamage();
  };

  BugLady.prototype.takedamage = function() {
    if (this.invincibletimeout > 0) {
      return;
    }
    if (this.stuntimeout <= 0) {
      this.flinch();
    }
    this.health -= 1;
    if (this.health <= 0) {
      return this.kill();
    }
  };

  entcenter = function(ent) {
    var hb;
    hb = ent.gethitbox();
    return V(hb.x + hb.w / 2, hb.y + hb.h / 2);
  };

  BugLady.prototype.dmgvelocity = 20;

  BugLady.prototype.falldamage = function() {
    if (this.vel.y > this.dmgvelocity) {
      this.stuntimeout = 20;
      return this.takedamage();
    }
  };

  GenericSprite.prototype.blockcollisions = function() {
    var box, candidates,
      _this = this;
    box = this.gethitbox();
    candidates = hitboxfilter(box, WORLD.bglayer);
    candidates.forEach(function(candidate) {
      if (_this.gethitbox().bottom() >= candidate.top()) {
        if (typeof _this.falldamage === "function") {
          _this.falldamage();
        }
        _this.pos.y = candidate.y;
        return _this.vel.y = 0;
      }
    });
    if (candidates.length > 0 && this.vel.y < 0) {
      return this.vel.y = 0;
    }
  };

  BugLady.prototype.blockcollisions = function() {
    var box, candidates,
      _this = this;
    box = this.fallbox();
    candidates = hitboxfilter(box, WORLD.bglayer);
    return candidates.forEach(function(candidate) {
      var jumpthroughable;
      if (_this.gethitbox().bottom() <= candidate.top()) {
        _this.pos.y = candidate.y;
        _this.vel.y = 0;
      }
      jumpthroughable = candidate instanceof OnewayBlock;
      if (_this.vel.y < 0 && !jumpthroughable && box.top() > candidate.top()) {
        return _this.vel.y = 0;
      }
    });
  };

  closestpoint = function(p, pointarr) {
    var closest, point, _i, _len;
    closest = pointarr[0];
    for (_i = 0, _len = pointarr.length; _i < _len; _i++) {
      point = pointarr[_i];
      if (closest.dist(p) > point.dist(p)) {
        closest = point;
      }
    }
    return closest;
  };

  BugLady.prototype.polygoncollisions = function() {
    var allpolygons,
      _this = this;
    allpolygons = WORLD.spritelayer.filter(function(sprit) {
      return sprit instanceof Poly;
    });
    return allpolygons.forEach(function(candidate) {
      var closest, edges, hits, p, trajectory;
      p = new V2d(_this.pos.x, _this.pos.y);
      trajectory = new Line2d(_this.pos, _this.pos.vadd(_this.vel));
      edges = pointlisttoedges(candidate.points);
      hits = edges.map(function(edg) {
        return trajectory.lineintersect(edg);
      });
      hits = _.compact(hits);
      if (hits.length > 0) {
        closest = closestpoint(p, hits);
        _this.pos = closest.vsub(_this.vel.norm());
        _this.vel.y = 0;
      }
      if (geometry.pointInsidePoly(p, candidate.points)) {
        return _this.vel.y--;
      }
    });
  };

  Hero.prototype.checkcontrols = function() {};

  BugLady.prototype.checkcontrols = function() {
    this.holdingboggle = isholdingbound('boggle');
    this.holdingjump = isholdingbound('jump');
    return this.controls.crouch = isholdingbound('down');
  };

  BugLady.prototype.cancelattack = function() {
    this.attacktimeout = 0;
    return this.attacking = false;
  };

  Hero.prototype.outofbounds = function() {
    return this.pos.y > 6400;
  };

  BugLady.prototype.kill = function() {
    return this.respawn();
  };

  BugLady.prototype.timeoutcheck = function() {
    if (this.invincibletimeout > 0) {
      this.invincibletimeout--;
    }
    if (this.poweruptimeout > 0) {
      this.poweruptimeout--;
      this.vel = V2d.zero();
    }
    if (this.stuntimeout > 0) {
      this.stuntimeout--;
      achieve("fall");
      return this.vel = V2d.zero();
    }
  };

  BugLady.prototype.attackchecks = function() {
    var heading;
    this.attacking = this.attacktimeout > 0;
    heading = this.facingleft ? -1 : 1;
    if (this.attacking) {
      this.attacktimeout--;
    }
    if (this.attacking && !this.punching) {
      this.vel.y *= 0.7;
      this.vel.x += heading * 0.3;
      WORLD.spritelayer.push(new PchooParticle(entcenter(this)));
    }
    if (this.attacking && this.punching) {
      if (entitycount(Bullet) < 3 && this.energy > 0) {
        this.energy--;
        return firebullet(this);
      }
    }
  };

  firebullet = function(ent) {
    var CENTER, bullet, heading;
    heading = ent.facingleft ? -1 : 1;
    bullet = new Bullet();
    bullet.owner = ent;
    bullet.vel = V(heading * 16, 0);
    CENTER = V(1 / 2, 1 / 2);
    bullet.pos = relativetobox(ent.gethitbox(), CENTER);
    WORLD.spritelayer.push(bullet);
    return bullet;
  };

  get_sprites_of_class = function(classtype) {
    var ents;
    return ents = WORLD.spritelayer.filter(function(sprite) {
      return sprite instanceof classtype;
    });
  };

  BugLady.prototype.submerged = function() {
    var blockcandidates, collidebox, waterblocks;
    waterblocks = get_sprites_of_class(Water);
    collidebox = this.gethitbox();
    blockcandidates = hitboxfilter(collidebox, waterblocks);
    if (blockcandidates.length > 0) {
      return true;
    }
    return false;
  };

  BugLady.prototype.waterdrag = function() {
    this.vel.y = this.vel.y * 0.8;
    return this.vel.x = this.vel.x * 0.95;
  };

  BugLady.prototype.tick = function() {
    var boggling, unpowered, vel, walking;
    if (this.submerged()) {
      this.waterdrag();
    }
    unpowered = settings.altcostume;
    if (unpowered) {
      this.cancelattack();
    }
    this.checkcontrols();
    if (this.outofbounds()) {
      this.kill();
    }
    vel = Math.abs(this.vel.x);
    walking = vel > 0.2;
    boggling = !walking && this.touchingground() && this.holdingboggle;
    if (boggling && Math.random() < 0.3) {
      this.boggle();
    }
    this.timeoutcheck();
    return this.movetick();
  };

  BugLady.prototype.limitvelocity = function() {
    var vellimit;
    vellimit = 8;
    return this.vel.x = mafs.clamp(this.vel.x, -vellimit, vellimit);
  };

  BugLady.prototype.gravitate = function() {
    if (!this.touchingground() && !this.touchingwall()) {
      this.vel.y += 1;
      if (!this.holdingjump && this.vel.y < 0) {
        return this.vel.y /= 2;
      }
    }
  };

  GenericSprite.prototype.physmove = function() {
    this.blockcollisions();
    this.avoidwalls();
    if (this.vel.y > 0 && this.touchingground()) {
      this.vel.y = 0;
    }
    this.pos = this.pos.vadd(this.vel);
    this.gravitate();
    if (this.touchingground()) {
      return this.friction();
    }
  };

  BugLady.prototype.physmove = function() {
    this.limitvelocity();
    this.blockcollisions();
    this.polygoncollisions();
    this.avoidwalls();
    if (this.vel.y > 0 && this.touchingground()) {
      this.vel.y = 0;
    }
    this.pos = this.pos.vadd(this.vel);
    this.gravitate();
    if (this.touchingground()) {
      return this.friction();
    }
  };

  BugLady.prototype.movetick = function() {
    var jumpvel, unpowered;
    unpowered = settings.altcostume;
    this.physmove();
    this.attackchecks();
    jumpvel = unpowered ? 12 : 16;
    this.jumpimpulse(jumpvel);
    if (this.vel.y > 1 && this.controls.crouch) {
      this.state = 'headfirst';
      this.vel.y += 0.1;
    }
    if (this.touchingground() && this.state === 'headfirst') {
      this.state = '';
      this.stuntimeout = 20;
    }
    this.jumping = false;
    return this.climbing = this.touchingwall();
  };

  BugLady.prototype.jumpimpulse = function(jumpvel) {
    var doublejumplegal, jumplegal;
    if (this.touchingground()) {
      this.spentdoublejump = false;
    }
    jumplegal = this.touchingground() || this.submerged();
    doublejumplegal = this.vel.y >= 0;
    if (this.spentdoublejump) {
      doublejumplegal = false;
    }
    if (this.jumping && doublejumplegal && !jumplegal) {
      this.spentdoublejump = true;
    }
    if (this.jumping && (jumplegal || doublejumplegal)) {
      this.vel.y = -jumpvel;
    }
    if (this.spentdoublejump) {
      return WORLD.spritelayer.push(new PchooParticle(entcenter(this)));
    }
  };

  GenericSprite.prototype.friction = function() {
    return this.vel.x = this.vel.x * 0.5;
  };

  BugLady.prototype.boggle = function() {
    var boxes, cand, hit;
    WORLD.spritelayer.push(new BoggleParticle(entcenter(this)));
    hit = ladybug.gethitbox();
    boxes = WORLD.fglayer.map(function(obj) {
      return obj.gethitbox();
    });
    cand = hitboxfilter(hit, boxes);
    if (cand.length > 0) {
      return achieve("boggle");
    }
  };

  BugLady.prototype.getsprite = function() {
    var src, vel, walking;
    if (this.invincibletimeout > 10 && this.touchingground()) {
      return "bugflinch.png";
    }
    if (this.invincibletimeout > 15) {
      return "bugdmg.png";
    }
    if (this.invincibletimeout > 0 && !this.touchingground()) {
      return "bugdmg2.png";
    }
    if (settings.beanmode) {
      return "bugbean.png";
    }
    src = "lovelyshorter.png";
    vel = Math.abs(this.vel.x);
    walking = vel > 0.2;
    if (walking) {
      src = selectframe(['lovelyrun1.png', 'lovelyrun2.png'], 3);
    }
    if (!this.touchingground()) {
      src = this.vel.y < 0 ? 'lovelyjump.png' : 'lovelycrouch.png';
    }
    if (!walking && this.controls.crouch) {
      src = 'lovelycrouch.png';
    }
    if (!walking && isholdingbound('up')) {
      src = 'lovelyjump.png';
    }
    if (!walking && this.touchingground() && this.holdingboggle) {
      src = 'boggle.png';
    }
    if (this.attacking) {
      src = 'viewtiful.png';
    }
    if (this.attacking && this.punching) {
      src = 'bugpunch.png';
    }
    if (this.attacking && this.attacktimeout < 2 && this.punching) {
      src = 'lovelyrun2.png';
    }
    if (this.attacking && this.kicking) {
      src = 'bugkick.png';
    }
    if (this.stuntimeout > 0) {
      src = 'lovelycrouch.png';
    }
    if (this.stuntimeout > 4) {
      src = 'lovelyfall.png';
    }
    if (this.poweruptimeout > 0) {
      src = 'viewtiful.png';
    }
    if (this.poweruptimeout > 16) {
      src = 'boggle.png';
      this.facingleft = this.poweruptimeout % 10 < 5;
    }
    if (this.poweruptimeout > 32) {
      src = 'marl/boggle.png';
    }
    if (settings.altcostume) {
      src = "marl/" + src;
    }
    if (this.climbing) {
      src = 'bugclimb1.png';
    }
    if (this.climbing && settings.altcostume) {
      src = 'marl/boggle.png';
    }
    if (this.state === 'headfirst') {
      src = 'bugheadfirst.png';
    }
    return src;
  };

  Claire = (function(_super) {
    __extends(Claire, _super);

    function Claire() {
      _ref2 = Claire.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    return Claire;

  })(BugLady);

  Claire.prototype.getsprite = function() {
    return "orcbabb.png";
  };

  BugLady.prototype.render = function() {
    var flip, pos, sprit, src, vel, walking;
    vel = Math.abs(this.vel.x);
    walking = vel > 1;
    src = this.getsprite();
    flip = this.facingleft;
    if (settings.beanmode && walking) {
      flip = tickno % 8 < 4;
    }
    pos = relativetobox(this.gethitbox(), this.anchor);
    sprit = drawsprite(this, src, pos, flip, this.anchor);
    if (src === 'boggle.png') {
      return sprit.rotation = mafs.degstorads(mafs.randfloat() * 4);
    } else {
      return sprit.rotation = 0;
    }
  };

  removesprite = function(ent) {
    if (ent._pixisprite == null) {
      return;
    }
    stage.removeChild(ent._pixisprite);
    return ent._pixisprite = void 0;
  };

  stageremovesprite = function(stage, ent) {
    if (ent._pixisprite == null) {
      return;
    }
    stage.removeChild(ent._pixisprite);
    return ent._pixisprite = void 0;
  };

  initsprite = function(ent, tex) {
    var sprit;
    sprit = new PIXI.Sprite(tex);
    ent._pixisprite = sprit;
    stage.addChild(sprit);
    return sprit;
  };

  drawsprite = function(ent, src, pos, flip, anchor) {
    var sprit;
    if (anchor == null) {
      anchor = V();
    }
    tex = PIXI.Texture.fromImage(sourcebaseurl + src);
    if (!ent._pixisprite) {
      initsprite(ent, tex);
    }
    sprit = ent._pixisprite;
    sprit.position = VTOPP(pos);
    sprit.anchor = VTOPP(anchor);
    sprit.setTexture(tex);
    sprit.scale.x = flip ? -1 : 1;
    return sprit;
  };

  Poly = (function(_super) {
    __extends(Poly, _super);

    function Poly(points) {
      this.points = points != null ? points : [];
      this.pos = V();
    }

    return Poly;

  })(Renderable);

  Poly.prototype.initsprite = function() {
    var firstpoint, sprit;
    sprit = new PIXI.Graphics();
    sprit.beginFill(0xcc0000);
    sprit.lineStyle(1, 0x000000);
    firstpoint = this.points[0];
    this.points.forEach(function(point) {
      return sprit.lineTo(point.x, point.y);
    });
    sprit.lineTo(firstpoint.x, firstpoint.y);
    sprit.endFill();
    this._pixisprite = sprit;
    return stage.addChild(sprit);
  };

  Poly.prototype.render = function() {
    if (!this.hassprite()) {
      return this.initsprite();
    }
  };

  Poly.prototype.boundingbox = function() {
    var b, l, max, min, r, t, xs, ys;
    xs = this.points.map(function(pt) {
      return pt.x;
    });
    ys = this.points.map(function(pt) {
      return pt.y;
    });
    min = function(a, b) {
      return Math.min(a, b);
    };
    max = function(a, b) {
      return Math.max(a, b);
    };
    l = Math.round(xs.reduce(min));
    r = Math.round(xs.reduce(max));
    t = Math.round(ys.reduce(min));
    b = Math.round(ys.reduce(max));
    return makebox(V(l, t), V(r - l, b - t), V(0, 0));
  };

  Poly.prototype.gethitbox = function() {
    return this.boundingbox();
  };

  Block = (function(_super) {
    __extends(Block, _super);

    function Block(x, y, w, h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      this.pos = V(this.x, this.y);
    }

    return Block;

  })(Renderable);

  Block.prototype.intersection = function(rectb) {
    var b, h, l, r, recta, t, w;
    recta = this;
    l = Math.max(recta.left(), rectb.left());
    t = Math.max(recta.top(), rectb.top());
    r = Math.min(recta.right(), rectb.right());
    b = Math.min(recta.bottom(), rectb.bottom());
    w = r - l;
    h = b - t;
    return new Block(l, t, w, h);
  };

  Block.prototype.strictoverlaps = function(rectb) {
    var recta;
    recta = this;
    if (recta.left() >= rectb.right() || recta.top() >= rectb.bottom() || recta.right() <= rectb.left() || recta.bottom() <= rectb.top()) {
      return false;
    } else {
      return true;
    }
  };

  Block.prototype.overlaps = function(rectb) {
    var recta;
    recta = this;
    if (recta.left() > rectb.right() || recta.top() > rectb.bottom() || recta.right() < rectb.left() || recta.bottom() < rectb.top()) {
      return false;
    } else {
      return true;
    }
  };

  Block.prototype.tostone = function() {
    this.src = "groundstone.png";
    return this.removesprite();
  };

  Block.prototype.fixnegative = function() {
    if (this.w < 0) {
      this.x += this.w;
      this.w *= -1;
    }
    if (this.h < 0) {
      this.y += this.h;
      this.h *= -1;
    }
    this.pos = V(this.x, this.y);
    return this.removesprite();
  };

  absurdboundbox = {
    x: -1000,
    y: -1000,
    w: 100000,
    h: 100000
  };

  bglayerQuads = new QuadTree(0, absurdboundbox);

  hitboxfilter_OLD = function(hitbox, rectarray) {
    return rectarray.filter(function(box) {
      return hitbox.overlaps(box);
    });
  };

  hitboxfilter = function(hitbox, rectarray) {
    return hitboxfilter_OLD(hitbox, rectarray);
  };

  makebox = function(position, dimensions, anchor) {
    var truepos;
    truepos = position.vsub(dimensions.vmul(anchor));
    return new Block(truepos.x, truepos.y, dimensions.x, dimensions.y);
  };

  bottomcenter = V(1 / 2, 1);

  BugLady.prototype.anchor = bottomcenter;

  BugLady.prototype.size = V(16, 32 + 16);

  GenericSprite.prototype.fallbox = function() {
    var box;
    box = this.gethitbox();
    box.y += this.vel.y;
    box.x += this.vel.x;
    return box;
  };

  leftof = function(box) {
    return box.x;
  };

  rightof = function(box) {
    return box.x + box.w;
  };

  bottomof = function(box) {
    return box.y + box.h;
  };

  topof = function(box) {
    return box.y;
  };

  Block.prototype.left = function() {
    return leftof(this);
  };

  Block.prototype.right = function() {
    return rightof(this);
  };

  Block.prototype.bottom = function() {
    return bottomof(this);
  };

  Block.prototype.top = function() {
    return topof(this);
  };

  Block.prototype.containspoint = function(p) {
    return this.x <= p.x && this.y <= p.y && this.x + this.w >= p.x && this.y + this.h >= p.y;
  };

  blocksatpoint = function(blocks, p) {
    return blocks.filter(function(box) {
      return box.containspoint(p);
    });
  };

  boxtouchingwall = function(collidebox) {
    var block, blockcandidates, notontop, _i, _len;
    blockcandidates = hitboxfilter(collidebox, WORLD.bglayer);
    for (_i = 0, _len = blockcandidates.length; _i < _len; _i++) {
      block = blockcandidates[_i];
      notontop = collidebox.bottom() > block.top();
      if (notontop && collidebox.left() < block.left()) {
        return true;
      }
      if (notontop && collidebox.right() > block.right()) {
        return true;
      }
    }
    return false;
  };

  GenericSprite.prototype.touchingwall = function() {
    var collidebox;
    collidebox = this.gethitbox();
    return boxtouchingwall(collidebox);
  };

  GenericSprite.prototype.avoidwalls = function() {
    var actualbox, block, blockcandidates, collidebox, jumpthroughable, notontop, _i, _len, _results;
    actualbox = this.gethitbox();
    collidebox = this.fallbox();
    blockcandidates = hitboxfilter(collidebox, WORLD.bglayer);
    _results = [];
    for (_i = 0, _len = blockcandidates.length; _i < _len; _i++) {
      block = blockcandidates[_i];
      jumpthroughable = block instanceof OnewayBlock;
      if (jumpthroughable) {
        continue;
      }
      notontop = actualbox.bottom() > block.top();
      if (boxtouchingwall(collidebox)) {
        _results.push(this.vel.x = 0);
      } else {
        _results.push(void 0);
      }
      /*
      ofs=1
      if notontop and collidebox.left() <= block.left()
        @pos.x-=ofs
      if notontop and rightof(collidebox) >= rightof(block)
        @pos.x+=ofs
      */

    }
    return _results;
  };

  GenericSprite.prototype.touchingground = function() {
    var allpolygons, block, blockcandidates, box, collidebox, touch, _i, _len,
      _this = this;
    touch = false;
    collidebox = this.gethitbox();
    blockcandidates = hitboxfilter(collidebox, WORLD.bglayer);
    for (_i = 0, _len = blockcandidates.length; _i < _len; _i++) {
      block = blockcandidates[_i];
      if (collidebox.bottom() <= block.bottom()) {
        touch = true;
      }
    }
    allpolygons = WORLD.spritelayer.filter(function(sprit) {
      return sprit instanceof Poly;
    });
    box = this.gethitbox();
    box.y += 1;
    allpolygons.forEach(function(candidate) {
      var p;
      p = new V2d(_this.pos.x, _this.pos.y + 1);
      if (geometry.pointInsidePoly(p, candidate.points)) {
        return touch = true;
      }
    });
    return touch;
  };

  PowerSuit = (function(_super) {
    __extends(PowerSuit, _super);

    function PowerSuit(pos) {
      this.pos = pos;
      PowerSuit.__super__.constructor.call(this, this.pos, 'suit.png');
    }

    return PowerSuit;

  })(GenericSprite);

  PowerSuit.prototype.anchor = V(1 / 2, 1);

  PowerSuit.prototype.collide = function(otherent) {
    if (otherent instanceof BugLady) {
      this.KILLME = true;
      otherent.poweruptimeout = 45;
      return settings.altcostume = false;
    }
  };

  ControlObj = (function() {
    function ControlObj() {
      this.bindings = {};
      this.holdbindings = {};
      this.heldkeys = [];
      this.bindingnames = {};
    }

    return ControlObj;

  })();

  control = new ControlObj;

  this.control = control;

  normalizekey = function(key) {
    return key.toUpperCase().charCodeAt(0);
  };

  ControlObj.prototype.keytapbindraw = function(key, func) {
    return this.bindings[key] = func;
  };

  ControlObj.prototype.keytapbind = function(key, func) {
    return this.bindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keytapbind = function(key, func) {
    return this.bindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keytapbindname = function(key, name, func) {
    this.bindingnames[normalizekey(key)] = name;
    return this.keytapbind(key, func);
  };

  ControlObj.prototype.keyBindRawNamed = function(key, name, func) {
    this.bindingnames[key] = name;
    return this.keytapbindraw(key, func);
  };

  ControlObj.prototype.keyholdbind = function(key, func) {
    return this.holdbindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keyholdbindname = function(key, name, func) {
    this.bindingnames[normalizekey(key)] = name;
    return this.holdbindings[normalizekey(key)] = func;
  };

  ControlObj.prototype.keyHoldBindRawNamed = function(key, name, func) {
    this.bindingnames[key] = name;
    return this.holdbindings[key] = func;
  };

  control.keytapbindname('9', 'zoom out', function() {
    return camera.zoomout();
  });

  control.keytapbindname('0', 'zoom in', function() {
    return camera.zoomin();
  });

  launchFullScreen = function(elm) {
    if (typeof elm.requestFullScreen === "function") {
      elm.requestFullScreen();
    }
    if (typeof elm.mozRequestFullScreen === "function") {
      elm.mozRequestFullScreen();
    }
    return typeof elm.webkitRequestFullScreen === "function" ? elm.webkitRequestFullScreen() : void 0;
  };

  cancelFullScreen = function() {
    if (typeof document.cancelFullScreen === "function") {
      document.cancelFullScreen();
    }
    if (typeof document.mozCancelFullScreen === "function") {
      document.mozCancelFullScreen();
    }
    return typeof document.webkitCancelFullScreen === "function" ? document.webkitCancelFullScreen() : void 0;
  };

  toggleFullScreen = function(elm) {
    var isfullscreen;
    isfullscreen = document.fullScreen || document.mozFullScreen || document.webkitFullScreen;
    if (isfullscreen) {
      return cancelFullScreen();
    } else {
      return launchFullScreen(elm);
    }
  };

  control.keytapbindname('y', 'toggle fullscreen', function() {
    return toggleFullScreen(renderer.view);
  });

  pausefunc = function() {
    playsound("pause.wav");
    settings.paused = !settings.paused;
    if (settings.paused) {
      parentstage.addChild(pausescreen);
    }
    if (!settings.paused) {
      return parentstage.removeChild(pausescreen);
    }
  };

  control.keytapbindname('p', 'pause', pausefunc);

  control.keyBindRawNamed(keyCharToCode['Pause/Break'], 'pause', pausefunc);

  control.keytapbindname('t', 'underclock/slowmo', function() {
    return settings.slowmo = !settings.slowmo;
  });

  control.keytapbindname('g', 'toggle grid', function() {
    return settings.grid = !settings.grid;
  });

  control.keytapbindname('l', 'WHAM!', function() {
    ladybug.jumping = true;
    ladybug.kicking = false;
    return ladybug.punching = false;
  });

  control.keyholdbind('l', function() {
    return ladybug.attacktimeout = 10;
  });

  punch = function() {
    ladybug.punching = true;
    ladybug.kicking = false;
    ladybug.attacktimeout = 10;
    return playsound("hit.wav");
  };

  kick = function() {
    ladybug.kicking = true;
    ladybug.jumping = true;
    ladybug.punching = false;
    ladybug.attacktimeout = 10;
    return playsound("hit.wav");
  };

  control.keytapbindname('j', 'POW!', punch);

  control.keytapbindname('k', 'BAM!', kick);

  control.keytapbindname('m', 'mute', function() {
    return settings.muted = !settings.muted;
  });

  up = function() {};

  jump = function() {
    if (ladybug.touchingground()) {
      playsound("jump.wav");
    }
    return ladybug.jumping = true;
  };

  down = function() {};

  bugspeed = function() {
    var amt;
    return amt = ladybug.touchingground() ? 6 : 1;
  };

  left = function() {
    ladybug.facingleft = true;
    return ladybug.vel.x -= bugspeed();
  };

  right = function() {
    achieve("start");
    ladybug.facingleft = false;
    return ladybug.vel.x += bugspeed();
  };

  availableactions = [up, down, left, right];

  control.keyholdbindname('w', 'up', up);

  control.keyholdbindname('s', 'down', down);

  control.keyholdbindname('a', 'left', left);

  control.keyholdbindname('d', 'right', right);

  control.keyholdbindname('x', 'boggle', function() {});

  ControlObj.prototype.keyHoldBindCharNamed = function(key, name, func) {
    return this.keyHoldBindRawNamed(keyCharToCode[key], name, func);
  };

  control.keyHoldBindCharNamed('Up', 'up', up);

  control.keyHoldBindCharNamed('Down', 'down', down);

  control.keyHoldBindCharNamed('Left', 'left', left);

  control.keyHoldBindCharNamed('Right', 'right', right);

  control.keyHoldBindCharNamed('Space', 'jump', jump);

  save = function() {
    var tmpladybug;
    console.log(ladybug);
    tmpladybug = $.extend({}, ladybug);
    tmpladybug._pixisprite = void 0;
    console.log("saving");
    localStorage["bug"] = JSON.stringify(tmpladybug);
    console.log(localStorage["bug"]);
    return localStorage["settings"] = JSON.stringify(settings);
  };

  load = function() {
    console.log("loading");
    $.extend(ladybug, JSON.parse(localStorage["bug"]));
    ladybug.pos = $.extend(V(), ladybug.pos);
    ladybug.vel = V(ladybug.vel.x, ladybug.vel.y);
    return $.extend(settings, JSON.parse(localStorage["settings"]));
  };

  control.keytapbindname('6', 'save', save);

  control.keytapbindname('7', 'load', load);

  nextlevel = function() {
    WORLD.clear();
    COLLTEST_INIT();
    WORLDINIT();
    return ladybug.respawn();
  };

  restartlevel = function() {
    WORLD.clear();
    loadlevelfile("levels/1.json");
    WORLDINIT();
    return ladybug.respawn();
  };

  control.keytapbindname('r', 'restart level', restartlevel);

  control.keytapbindname('n', 'change level', nextlevel);

  this.CONTROL = control;

  eventelement = $(document);

  keypushcache = [];

  cheatcodecheck = function() {
    var code, input;
    code = ["Up", "Up", "Down", "Down", "Left", "Right", "Left", "Right", "B", "A", "Enter"];
    input = _.last(keypushcache, code.length);
    if (_.isEqual(input, code)) {
      alert("conglaturation");
      keypushcache = [];
    }
    code = ["Right", "Up", "Right", "A", "Down", "Down", "Enter"];
    input = _.last(keypushcache, code.length);
    if (_.isEqual(input, code)) {
      alert("you'r a radical kid!! you have prooved the justice of our culture. god bless a merica. bean mode unlock!");
      settings.beanmode = !settings.beanmode;
      return keypushcache = [];
    }
  };

  eventelement.bind('keydown', function(e) {
    var key, _base;
    key = e.which;
    if (typeof (_base = control.bindings)[key] === "function") {
      _base[key]();
    }
    if (!(__indexOf.call(control.heldkeys, key) >= 0)) {
      control.heldkeys.push(key);
      keypushcache.push(keyCodeToChar[key]);
      cheatcodecheck();
    }
    return false;
  });

  eventelement.bind('keyup', function(e) {
    var key;
    key = e.which;
    control.heldkeys = _.without(control.heldkeys, key);
    return false;
  });

  tmpcanvasjq = $("<canvas>");

  tmpcanvas = tmpcanvasjq[0];

  tickno = 0;

  Block.prototype.gethitbox = function() {
    return this;
  };

  Block.prototype.initsprite = function() {
    var sprit, src;
    src = this.src || "groundtile.png";
    tex = PIXI.Texture.fromImage(sourcebaseurl + src);
    sprit = new PIXI.TilingSprite(tex, this.w, this.h);
    this._pixisprite = sprit;
    return stage.addChild(sprit);
  };

  Block.prototype.render = function() {
    var sprit;
    if (!this.hassprite()) {
      this.initsprite();
    }
    sprit = this._pixisprite;
    sprit.tilePosition.x = -this.x;
    sprit.tilePosition.y = -this.y;
    sprit.position.x = this.x;
    return sprit.position.y = this.y;
  };

  Water = (function(_super) {
    __extends(Water, _super);

    function Water(x, y, w, h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      Water.__super__.constructor.call(this, this.x, this.y, this.w, this.h);
      this.src = "snow.png";
    }

    return Water;

  })(Block);

  Water.prototype.render = function() {
    Water.__super__.render.call(this);
    return this._pixisprite.alpha = 0.5;
  };

  OnewayBlock = (function(_super) {
    __extends(OnewayBlock, _super);

    function OnewayBlock(x, y, w, h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      OnewayBlock.__super__.constructor.call(this, this.x, this.y, this.w, this.h);
      this.src = "groundstone.png";
    }

    return OnewayBlock;

  })(Block);

  ladybug = new BugLady;

  Cloud = (function(_super) {
    __extends(Cloud, _super);

    function Cloud() {
      Cloud.__super__.constructor.call(this);
      this.src = 'cloud.png';
      if (settings.decemberween) {
        this.src = 'snow.png';
      }
    }

    return Cloud;

  })(Renderable);

  Cloud.prototype.spriteinit = function() {
    var sprit;
    tex = PIXI.Texture.fromImage(sourcebaseurl + this.src);
    sprit = new PIXI.TilingSprite(tex, screensize.x, screensize.y);
    this._pixisprite = sprit;
    parentstage.addChildAt(sprit, 0);
    return sprit;
  };

  Grid = (function(_super) {
    __extends(Grid, _super);

    function Grid() {
      Grid.__super__.constructor.call(this);
      this.src = 'square.png';
    }

    return Grid;

  })(Renderable);

  adjustedscreensize = function() {
    return {
      x: screensize.x * 10,
      y: screensize.y * 10
    };
  };

  Grid.prototype.PIXINIT = Cloud.prototype.PIXINIT = function() {
    var sprit, x, y, _ref3;
    if (!this._pixisprite) {
      tex = PIXI.Texture.fromImage(sourcebaseurl + this.src);
      _ref3 = adjustedscreensize(), x = _ref3.x, y = _ref3.y;
      sprit = new PIXI.TilingSprite(tex, x, y);
      this._pixisprite = sprit;
      return parentstage.addChildAt(sprit, 0);
    }
  };

  Grid.prototype.PIXREMOVE = function() {
    if (!settings.grid && this._pixisprite) {
      parentstage.removeChild(this._pixisprite);
      return this._pixisprite = void 0;
    }
  };

  Cloud.prototype.render = function() {
    var flip, offset, pos, sprit;
    pos = cameraoffset();
    flip = false;
    this.PIXINIT();
    sprit = this._pixisprite;
    offset = V(tickno * -0.2, Math.sin(tickno / 200) * 64);
    sprit.tilePosition = VTOPP(offset);
    if (settings.grid && this._pixisprite) {
      parentstage.removeChild(this._pixisprite);
      return this._pixisprite = void 0;
    }
  };

  Grid.prototype.render = function() {
    var flip, offset, pos, sprit;
    pos = cameraoffset();
    flip = false;
    this.PIXINIT();
    sprit = this._pixisprite;
    offset = pos.nmul(-1);
    sprit.tilePosition = new PIXI.Point(offset.x, offset.y);
    return this.PIXREMOVE();
  };

  World = (function() {
    function World() {
      this.entities = [];
      this.bglayer = [];
      this.fglayer = [];
      this.spritelayer = [];
    }

    return World;

  })();

  WORLD = new World;

  randpos = function() {
    return V(640 * 1.5, 64 * 2).vadd(mafs.randvec().vmul(V(640, 100)));
  };

  Shrub = (function(_super) {
    __extends(Shrub, _super);

    function Shrub(pos) {
      this.pos = pos;
      Shrub.__super__.constructor.call(this, this.pos, 'shrub.png');
      this.anchor = V(1 / 2, 1);
    }

    return Shrub;

  })(GenericSprite);

  placeshrub = function(pos) {
    return WORLD.fglayer.push(new Shrub(pos));
  };

  PlaceholderSprite = (function(_super) {
    __extends(PlaceholderSprite, _super);

    function PlaceholderSprite(pos) {
      this.pos = pos;
      PlaceholderSprite.__super__.constructor.call(this, this.pos);
      this.label = 'a thing';
    }

    return PlaceholderSprite;

  })(GenericSprite);

  PlaceholderSprite.prototype.render = function() {
    var box, sprit, txt;
    if (this._pixisprite != null) {
      sprit = this._pixisprite;
      sprit.position = VTOPP(this.pos);
      sprit.anchor = VTOPP(V(0, 0));
      return;
    }
    txt = new PIXI.Text(this.label, {
      font: "12px Arial",
      fill: "black"
    });
    txt.anchor = PP(this.anchor);
    console.log(this.anchor);
    sprit = new PIXI.Graphics();
    sprit.beginFill(0xFF00FF);
    box = this.gethitbox();
    sprit.position = VTOPP(this.pos);
    sprit.drawRect(0, 0, box.w, box.h);
    sprit.alpha = 0.9;
    sprit.addChild(txt);
    stage.addChild(sprit);
    return this._pixisprite = sprit;
  };

  BugMeter = (function(_super) {
    __extends(BugMeter, _super);

    function BugMeter() {
      BugMeter.__super__.constructor.call(this);
      this.src = 'bughealth.png';
      this.value = 3;
      this.abspos = V(0, 0);
      this.spritesize = V(32, 32);
    }

    return BugMeter;

  })(GenericSprite);

  BugMeter.prototype.spriteinit = function() {
    var sprit;
    tex = PIXI.Texture.fromImage(sourcebaseurl + this.src);
    sprit = new PIXI.TilingSprite(tex, this.spritesize.x * this.value, this.spritesize.y);
    this._pixisprite = sprit;
    HUDLAYER.addChild(sprit);
    return sprit;
  };

  BugMeter.prototype.render = function() {
    var flip, pos, sprit;
    pos = this.abspos;
    flip = false;
    if (!this._pixisprite) {
      this.spriteinit();
    }
    sprit = this._pixisprite;
    sprit.width = this.spritesize.x * this.value;
    return sprit.position = VTOPP(pos);
  };

  BugMeter.prototype.tick = function() {
    return this.update(ladybug.health);
  };

  BugMeter.prototype.update = function(value) {
    stageremovesprite(HUDLAYER, this);
    return this.value = value;
  };

  EnergyMeter = (function(_super) {
    __extends(EnergyMeter, _super);

    function EnergyMeter() {
      EnergyMeter.__super__.constructor.call(this);
      this.src = 'energy1.png';
      this.abspos = V(0, 16);
    }

    return EnergyMeter;

  })(BugMeter);

  EnergyMeter.prototype.tick = function() {
    return this.update(ladybug.energy);
  };

  MoneyMeter = (function(_super) {
    __extends(MoneyMeter, _super);

    function MoneyMeter() {
      MoneyMeter.__super__.constructor.call(this);
      this.src = 'crown.png';
      this.spritesize = V(16, 16);
      this.abspos = V(8, 64 - 16);
    }

    MoneyMeter.prototype.tick = function() {
      return this.update(ladybug.score);
    };

    return MoneyMeter;

  })(BugMeter);

  Block.prototype.toJSON = function() {
    return [this.x, this.y, this.w, this.h];
  };

  loadblocks = function(blockdata) {
    return blockdata.forEach(function(blockdatum) {
      var h, w, x, y;
      x = blockdatum[0], y = blockdatum[1], w = blockdatum[2], h = blockdatum[3];
      return WORLD.bglayer.push(new Block(x, y, w, h));
    });
  };

  loadspawners = function(entdata) {
    return entdata.forEach(function(entdatum) {
      var spawner;
      WORLD.spritelayer.push(spawner = new Spawner(entdatum.pos));
      return spawner.entdata = entdatum;
    });
  };

  scatterents = function(classproto, num) {
    var _i, _results;
    return WORLD.spritelayer = WORLD.spritelayer.concat((function() {
      _results = [];
      for (var _i = 0; 0 <= num ? _i < num : _i > num; 0 <= num ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(function() {
      return new classproto(randpos());
    }));
  };

  Goal = (function(_super) {
    __extends(Goal, _super);

    function Goal(pos) {
      this.pos = pos;
      Goal.__super__.constructor.call(this, this.pos);
      this.label = "GOAL";
    }

    return Goal;

  })(PlaceholderSprite);

  Goal.prototype.collide = function(otherent) {
    if (otherent instanceof Hero) {
      return nextlevel();
    }
  };

  Platform = (function(_super) {
    __extends(Platform, _super);

    function Platform(pos) {
      this.pos = pos;
      Platform.__super__.constructor.call(this, this.pos);
      this.label = "platform";
    }

    return Platform;

  })(PlaceholderSprite);

  Platform.prototype.collide = function(otherent) {
    if (otherent instanceof Hero) {
      return otherent.vel.y = 0;
    }
  };

  HurtWire = (function(_super) {
    __extends(HurtWire, _super);

    function HurtWire() {
      _ref3 = HurtWire.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    return HurtWire;

  })(GenericSprite);

  HurtWire.prototype.size = V(8, 32);

  HurtWire.prototype.anchor = V(1 / 2, 0);

  HurtWire.prototype.getsprite = function() {
    var framelist, framewait;
    framewait = 1;
    framelist = ["wire.png"];
    if (this.state === "sparking") {
      framelist = [1, 2, 3, 4].map(function(n) {
        return "wirespark" + n + ".png";
      });
    }
    return selectframe(framelist, framewait);
  };

  HurtWire.prototype.tick = function() {
    this.age = this.age || 0;
    this.age = (this.age + 1) % 100;
    if (this.age < 30) {
      return this.state = "sparking";
    } else {
      return this.state = "inert";
    }
  };

  HurtWire.prototype.collide = function(otherent) {
    if (this.state === "sparking" && otherent instanceof Hero) {
      return otherent.takedamage();
    }
  };

  HurtWire.prototype.render = function() {
    this.src = this.getsprite();
    return HurtWire.__super__.render.call(this);
  };

  spawnables = {
    burd: Burd,
    target: Target,
    jelly: Jelly,
    powersuit: PowerSuit,
    gold: Gold,
    energy: Energy,
    lila: Lila,
    claire: Claire,
    platform: Platform
  };

  Spawner = (function(_super) {
    __extends(Spawner, _super);

    function Spawner(pos) {
      this.pos = pos;
      Spawner.__super__.constructor.call(this, this.pos);
      this.label = "Entity spawner";
      this.entdata = {
        "class": Jelly,
        pos: this.pos
      };
    }

    return Spawner;

  })(PlaceholderSprite);

  Spawner.prototype.tick = function() {
    this.entdata.pos = this.pos;
    console.log(this.entdata.pos);
    return this.label = this.entdata["class"];
  };

  Spawner.prototype.spawn = function() {
    return loadents([this.entdata]);
  };

  Spawner.prototype.toJSON = function() {
    return this.entdata;
  };

  entdata = [
    {
      "class": "lila",
      pos: {
        x: 64 * 4,
        y: 64 * 4
      }
    }, {
      "class": "claire",
      pos: {
        x: 64 * 2,
        y: 64 * 4
      }
    }
  ];

  jame = {};

  jame.spawn = function(classname) {
    var ent;
    if (!spawnables[classname]) {
      return;
    }
    ent = typeof spawnables[classname] === "function" ? new spawnables[classname]() : void 0;
    WORLD.spritelayer.push(ent);
    return ent;
  };

  loadent = function(entdatum) {
    var ent;
    ent = jame.spawn(entdatum["class"]);
    return ent.load(entdatum);
  };

  loadents = function(entdata) {
    return entdata.forEach(function(entdatum) {
      return loadent(entdatum);
    });
  };

  WORLD_ONE_INIT = function() {
    var hat, royaljel;
    scatterents(HurtWire, 4);
    scatterents(Target, 10);
    scatterents(Jelly, 10);
    scatterents(Energy, 10);
    scatterents(Gold, 10);
    scatterents(Thug, 3);
    WORLD.spritelayer.push(new PowerSuit(V(128, 32)));
    loadents(entdata);
    placeshrub(V(64 * 8, 64 * 5 - 4));
    placeshrub(V(64 * 7 - 48, 64 * 5 - 4));
    placeshrub(V(64 * 9, 64 * 5 - 4));
    WORLD.spritelayer.push(new Goal(V(64 * 24, 64 * 4)));
    WORLD.spritelayer.push(royaljel = new Jelly(randpos()));
    WORLD.spritelayer.push(hat = new Hat());
    hat.src = 'crown.png';
    return hat.parent = royaljel;
  };

  WORLDINIT = function() {
    var bugmeter, energymeter;
    WORLD.entities.push(new Cloud());
    WORLD.entities.push(new Grid());
    bugmeter = new BugMeter;
    WORLD.entities.push(bugmeter);
    energymeter = new EnergyMeter;
    WORLD.entities.push(energymeter);
    WORLD.entities.push(new MoneyMeter);
    this.bugmeter = bugmeter;
    if (settings.hat) {
      WORLD.entities.push(new Hat());
    }
    WORLD.bglayer.forEach(function(block) {
      var fence;
      fence = new Fence;
      fence.pos = relativetobox(block, V(0, 0));
      WORLD.spritelayer.push(fence);
      fence = new Fence;
      fence.pos = relativetobox(block, V(1, 0));
      return WORLD.spritelayer.push(fence);
    });
    return WORLD.spritelayer.push(ladybug);
  };

  randtri = function() {
    return new Poly([randpos(), randpos(), randpos()]);
  };

  WORLD.getallents = function() {
    return [].concat(WORLD.entities, WORLD.spritelayer, WORLD.bglayer, WORLD.fglayer);
  };

  WORLD.clear = function() {
    var ALLENTS;
    ALLENTS = WORLD.getallents();
    ALLENTS.forEach(function(ent) {
      return removesprite(ent);
    });
    WORLD.entities = [];
    WORLD.spritelayer = [];
    WORLD.bglayer = [];
    return WORLD.fglayer = [];
  };

  roboblockdata = [];

  roboblockdata.push([-64, 64 * 4, 64 * 12, 100]);

  roboblockdata.push([64 * 12, 64 * 5, 64 * 12, 100]);

  ROBOWORLD_INIT = function() {
    scatterents(Burd, 8);
    loadblocks(roboblockdata);
    WORLD.spritelayer = WORLD.spritelayer.concat([0, 1, 2, 3].map(function() {
      return new Robo(randpos());
    }));
    return WORLD.spritelayer.push(randtri());
  };

  COLLTEST_INIT = function() {
    scatterents(Jelly, 8);
    loadblocks(roboblockdata);
    return WORLD.spritelayer.push(randtri());
  };

  /*
  levelfilename = "levels/1.json"
  $.ajax levelfilename, success: (data,status,xhr) ->
    jsondata=JSON.parse data
    loadlevel jsondata
    WORLD_ONE_INIT()
  */


  loadlevelfile = function(levelfilename) {
    return $.ajax(levelfilename, {
      success: function(data, status, xhr) {
        var jsondata;
        jsondata = JSON.parse(data);
        loadlevel(jsondata);
        return WORLD_ONE_INIT();
      }
    });
  };

  loadlevelfile("levels/1.json");

  WORLDINIT();

  camera = {};

  jame.camera = camera;

  camera.offset = V();

  camera.pos = V();

  camera.trackingent = ladybug;

  camera.zoomout = function() {
    scale -= 0.1;
    return scale = mafs.clamp(scale, 0.1, 1);
  };

  camera.zoomin = function() {
    scale += 0.1;
    return scale = mafs.clamp(scale, 0.1, 1);
  };

  cameraoffset = function() {
    var tmppos;
    tmppos = camera.trackingent.pos.nadd(0);
    tmppos.y -= 64;
    tmppos = tmppos.vsub(camera.offset.ndiv(scale));
    tmppos = tmppos.vsub(screensize.ndiv(2 * scale));
    return camera.pos.vadd(tmppos).ndiv(2);
  };

  camera.tick = function() {
    return camera.pos = cameraoffset();
  };

  render = function() {
    var highlighted, renderables;
    camera.tick();
    renderables = [].concat(WORLD.bglayer, WORLD.spritelayer, [ladybug], WORLD.fglayer, WORLD.entities);
    renderables.forEach(function(ent) {
      return typeof ent.render === "function" ? ent.render() : void 0;
    });
    highlighted = renderables.filter(function(ent) {
      return ent.HIGHLIGHT != null;
    });
    if (settings.grid) {
      highlighted = renderables;
    }
    return drawhitboxes(highlighted);
  };

  drawhitboxes = function(ents) {
    var graf;
    stage.removeChild(hitboxlayer);
    hitboxlayer = new PIXI.DisplayObjectContainer;
    stage.addChild(hitboxlayer);
    graf = new PIXI.Graphics();
    graf.lineStyle(1, 0x00ff00, 1);
    graf.beginFill(0xff0000, 1 / 8);
    ents.forEach(function(ent) {
      var box, velbox;
      graf.lineStyle(1, 0x00ff00, 1);
      graf.drawCircle(ent.pos.x, ent.pos.y, 4);
      box = typeof ent.gethitbox === "function" ? ent.gethitbox() : void 0;
      if (!box) {
        return;
      }
      graf.drawRect(box.x, box.y, box.w, box.h);
      velbox = typeof ent.fallbox === "function" ? ent.fallbox() : void 0;
      if (!velbox) {
        return;
      }
      graf.lineStyle(1, 0x0000ff, 1);
      return graf.drawRect(velbox.x, velbox.y, velbox.w, velbox.h);
    });
    return hitboxlayer.addChild(graf);
  };

  timecall = function(func) {
    var starttime;
    starttime = Date.now();
    func();
    return Date.now() - starttime;
  };

  tickwaitms = 20;

  skipframes = 0;

  ticktimes = [];

  WORLD.gethitbox = function(sprite) {
    return sprite.gethitbox();
  };

  checkcolls = function(ent, otherents) {
    var bawks;
    bawks = WORLD.gethitbox(ent);
    return otherents.forEach(function(target) {
      var targethitbox;
      if (target === ent) {
        return;
      }
      targethitbox = WORLD.gethitbox(target);
      if (bawks.overlaps(targethitbox)) {
        return typeof target.collide === "function" ? target.collide(ent) : void 0;
      }
    });
  };

  WORLD.euthanasia = function() {
    var doomedsprites;
    doomedsprites = WORLD.spritelayer.filter(function(sprite) {
      return sprite.KILLME != null;
    });
    doomedsprites.forEach(function(sprite) {
      return typeof sprite.cleanup === "function" ? sprite.cleanup() : void 0;
    });
    return WORLD.spritelayer = _.difference(WORLD.spritelayer, doomedsprites);
  };

  quadwrap = function(origobj) {
    var obj;
    obj = origobj.gethitbox();
    return {
      x: obj.x,
      y: obj.y,
      w: obj.w,
      h: obj.h,
      LINK: origobj
    };
  };

  quadunwrap = function(obj) {
    return obj.LINK;
  };

  rejigCols = function() {
    bglayerQuads.clear();
    return WORLD.bglayer.forEach(function(block) {
      return bglayerQuads.insert(quadwrap(block));
    });
  };

  WORLD.tick = function() {
    var ACTIVEENTS, key, _base, _i, _len, _ref4;
    rejigCols();
    _ref4 = control.heldkeys;
    for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
      key = _ref4[_i];
      if (typeof (_base = control.holdbindings)[key] === "function") {
        _base[key]();
      }
    }
    checkcolls(ladybug, WORLD.spritelayer);
    WORLD.spritelayer.forEach(function(sprite) {
      return checkcolls(sprite, _.without(WORLD.spritelayer, sprite));
    });
    WORLD.euthanasia();
    ACTIVEENTS = [].concat(WORLD.spritelayer, [ladybug], WORLD.entities);
    ACTIVEENTS.forEach(function(ent) {
      return typeof ent.updatehitbox === "function" ? ent.updatehitbox() : void 0;
    });
    ACTIVEENTS.forEach(function(ent) {
      return typeof ent.tick === "function" ? ent.tick() : void 0;
    });
    render();
    return tickno++;
  };

  fpscounter = $(xmltag());

  tt = 0;

  updateinfobox = function() {
    text = control.heldkeys.map(function(key) {
      return "<span>" + keyCodeToChar[key] + "</span>";
    });
    return $(infobox).html(text.join(" "));
  };

  mainloop = function() {
    var fps, fpsgoal, idealfps, ticktime;
    updatesettingstable();
    updateinfobox();
    if (!settings.paused) {
      ticktime = timecall(WORLD.tick);
      tt = ticktime;
      fps = Math.round(1000 / Math.max(tickwaitms, ticktime));
      idealfps = Math.round(1000 / tickwaitms);
      fpscounter.html("~" + fps + "/" + idealfps + " fps ; per tick: " + tt + "ms");
    }
    fpsgoal = settings.slowmo ? 4 : settings.fps;
    tickwaitms = 1000 / fpsgoal;
    setTimeout(mainloop, Math.max(tickwaitms - ticktime, 1));
    return requestAnimFrame(animate);
  };

  xmlwrap = function(tagname, body) {
    return xmltag(tagname, void 0, body);
  };

  maketablerow = function(values) {
    var tds;
    tds = values.map(function(v) {
      return xmlwrap("td", v);
    });
    return xmlwrap("tr", tds);
  };

  jame.maketable = function(arrofarr) {
    var domelm, k, v;
    domelm = $('<table>');
    for (k in arrofarr) {
      v = arrofarr[k];
      domelm.append(maketablerow(v));
    }
    return domelm;
  };

  selectall = function(classname) {
    return jame.WORLD.spritelayer.filter(function(obj) {
      return obj.constructor.name === classname;
    });
  };

  jame.listents = function() {
    var ents;
    ents = _.pairs(_.countBy(jame.WORLD.spritelayer, function(obj) {
      return obj.constructor.name;
    }));
    return body.append(jame.maketable(ents));
  };

  infobox = $("<div>");

  infobox.css({
    float: "right",
    border: "1px solid black"
  });

  body.append(infobox);

  bindingsDOM = $("<table>");

  _ref4 = control.bindingnames;
  for (k in _ref4) {
    v = _ref4[k];
    bindingsDOM.append(maketablerow([keyCodeToChar[k], v || "??"]));
  }

  _CHARbindingnames = {};

  _ref5 = control.bindingnames;
  for (k in _ref5) {
    v = _ref5[k];
    _CHARbindingnames[keyCodeToChar[k]] = v;
  }

  settingsDOM = $("<table>");

  updatesettingstable = function() {
    var _results;
    settingsDOM.html("");
    _results = [];
    for (k in settings) {
      v = settings[k];
      _results.push(settingsDOM.append(maketablerow([k, v])));
    }
    return _results;
  };

  INIT = function() {
    body.append(fpscounter);
    body.append("<b>bindings:</b>");
    body.append(keyboardlayout.visualize(_CHARbindingnames));
    body.append(bindingsDOM);
    body.append("<b>settings:</b>");
    body.append(settingsDOM);
    mainloop();
    return requestAnimFrame(animate);
  };

  INIT();

  adjustmouseevent = function(e) {
    var adjusted, coffs;
    coffs = $(renderer.view).offset();
    adjusted = V(e.pageX - coffs.left, e.pageY - coffs.top);
    adjusted = adjusted.ndiv(scale);
    adjusted = adjusted.vadd(camera.pos);
    adjusted = adjusted.op(Math.round);
    return adjusted;
  };

  Tool = (function() {
    function Tool() {}

    return Tool;

  })();

  NOOPTOOL = {
    name: 'noop',
    mousedown: (function() {}),
    mouseup: (function() {}),
    mousemove: (function() {})
  };

  BLOCKCREATIONTOOL = _.extend({}, NOOPTOOL, {
    name: 'create block',
    creatingblock: false,
    mousedown: function(e) {
      var adjusted;
      if (e.button !== 0) {
        return;
      }
      adjusted = adjustmouseevent(e);
      adjusted = snapmouseadjust(adjusted);
      BLOCKCREATIONTOOL.creatingblock = new Block(adjusted.x, adjusted.y, 32, 32);
      return WORLD.bglayer.push(BLOCKCREATIONTOOL.creatingblock);
    },
    mouseup: function(e) {
      if (e.button !== 0) {
        return;
      }
      BLOCKCREATIONTOOL.creatingblock.fixnegative();
      return BLOCKCREATIONTOOL.creatingblock = false;
    },
    mousemove: function(e) {
      var creatingblock, currclickpos, mpos, offset;
      mpos = snapmouseadjust(adjustmouseevent(e));
      creatingblock = BLOCKCREATIONTOOL.creatingblock;
      if (creatingblock) {
        creatingblock.w = mpos.x - creatingblock.x;
        creatingblock.h = mpos.y - creatingblock.y;
        creatingblock.removesprite();
        creatingblock.tostone();
      }
      if (ORIGCLICKPOS) {
        currclickpos = V(e.pageX, e.pageY);
        offset = currclickpos.vsub(ORIGCLICKPOS);
        return camera.offset = offset;
      }
    }
  });

  snapmouseadjust_always = function(mpos) {
    var gridsize;
    gridsize = 32;
    mpos = mpos.ndiv(gridsize).op(Math.round).nmul(gridsize);
    return mpos;
  };

  snapmouseadjust_down = function(mpos) {
    var gridsize;
    gridsize = 32;
    mpos = mpos.ndiv(gridsize).op(Math.floor).nmul(gridsize);
    return mpos;
  };

  snapmouseadjust = function(mpos) {
    var snaptogrid;
    snaptogrid = isholdingkey('z');
    if (snaptogrid) {
      return snapmouseadjust_always(mpos);
    }
    return mpos;
  };

  MoveTool = (function(_super) {
    __extends(MoveTool, _super);

    function MoveTool() {
      _ref6 = MoveTool.__super__.constructor.apply(this, arguments);
      return _ref6;
    }

    return MoveTool;

  })(Tool);

  MoveTool.prototype.name = 'move entities';

  MoveTool.prototype.constructor = function() {
    return this.selected = [];
  };

  MoveTool.prototype.mouseup = function(e) {
    this.selected = [];
    return setcursor('auto');
  };

  MoveTool.prototype.mousemove = function(e) {
    var entsundercursor, isSelecting, p;
    this.selected = this.selected || [];
    isSelecting = this.selected.length > 0;
    p = adjustmouseevent(e);
    entsundercursor = getentsunderpoint(p);
    if (isSelecting) {
      setcursor('-moz-grabbing');
    } else {
      setcursor('auto');
    }
    if (entsundercursor.length > 0) {
      setcursor('-moz-grab');
    }
    p = snapmouseadjust(p);
    return this.selected.forEach(function(ent) {
      ent.pos = p;
      return ent.vel = V();
    });
  };

  MoveBlockTool = (function(_super) {
    __extends(MoveBlockTool, _super);

    MoveBlockTool.prototype.name = 'move blocks';

    function MoveBlockTool() {
      this.selected = [];
    }

    MoveBlockTool.prototype.mouseup = function(e) {
      this.selected = [];
      return setcursor('auto');
    };

    MoveBlockTool.prototype.mousemove = function(e) {
      var isSelecting, p;
      this.selected = this.selected || [];
      isSelecting = this.selected.length > 0;
      p = adjustmouseevent(e);
      p = snapmouseadjust(p);
      return this.selected.forEach(function(ent) {
        ent.pos = p;
        ent.x = p.x;
        ent.y = p.y;
        return ent.removesprite();
      });
    };

    return MoveBlockTool;

  })(Tool);

  MoveBlockTool.prototype.mousedown = function(e) {
    var blocksundercursor, p;
    p = adjustmouseevent(e);
    blocksundercursor = blocksatpoint(WORLD.bglayer, p);
    return this.selected = blocksundercursor;
  };

  getentsunderpoint = function(p) {
    return WORLD.spritelayer.filter(function(ent) {
      var box;
      box = typeof ent.gethitbox === "function" ? ent.gethitbox() : void 0;
      return box && box.containspoint(p);
    });
  };

  MoveTool.prototype.mousedown = function(e) {
    var entsundercursor, p;
    p = adjustmouseevent(e);
    entsundercursor = getentsunderpoint(p);
    return this.selected = entsundercursor;
  };

  setcursor = function(cursorname) {
    return $(renderer.view).css('cursor', cursorname);
  };

  MOVETOOL = new MoveTool();

  MOVETOOL.selected = [];

  MOVEBLOCKTOOL = new MoveBlockTool();

  tool = MOVETOOL;

  $(renderer.view).mousedown(function(e) {
    return typeof tool.mousedown === "function" ? tool.mousedown(e) : void 0;
  });

  $(renderer.view).mouseup(function(e) {
    return typeof tool.mouseup === "function" ? tool.mouseup(e) : void 0;
  });

  $(renderer.view).mousemove(function(e) {
    return typeof tool.mousemove === "function" ? tool.mousemove(e) : void 0;
  });

  randposrel = function(p) {
    if (p == null) {
      p = V();
    }
    return p.vadd(mafs.randvec().vmul(V(32, 32)));
  };

  TRIANGLETOOL = _.extend({}, NOOPTOOL, {
    name: "add triangle",
    mousedown: function(e) {
      var p, triangle;
      p = adjustmouseevent(e);
      triangle = new Poly([randposrel(p), randposrel(p), randposrel(p)]);
      return WORLD.spritelayer.push(triangle);
    },
    mouseup: function(e) {},
    mousemove: function(e) {}
  });

  SPAWNTOOL = {
    name: 'Spawn entity'
  };

  SPAWNTOOL.classname = 'burd';

  SPAWNTOOL.mousedown = function(e) {
    var ent, p;
    p = adjustmouseevent(e);
    ent = jame.spawn(SPAWNTOOL.classname);
    return ent.pos = p;
  };

  SPAWNTOOL.mouseup = function(e) {};

  SPAWNTOOL.mousemove = function(e) {};

  SPAWNERTOOL = _.extend({}, NOOPTOOL, {
    name: 'Spawn entity',
    classname: 'burd',
    mousedown: function(e) {
      var ent, p;
      p = adjustmouseevent(e);
      WORLD.spritelayer.push(ent = new Spawner(p));
      ent.pos = p;
      ent.entdata["class"] = SPAWNTOOL.classname;
      return ent.spawn();
    }
  });

  TELEPORTTOOL = _.extend({}, NOOPTOOL, {
    name: "teleport",
    mousedown: function(e) {
      var p;
      p = adjustmouseevent(e);
      ladybug.pos = p;
      return ladybug.vel = V(0, 0);
    }
  });

  boxesbounding = function(boxlist) {
    var b, bs, l, ls, r, rs, t, ts;
    ls = boxlist.map(function(b) {
      return b.left();
    });
    rs = boxlist.map(function(b) {
      return b.right();
    });
    ts = boxlist.map(function(b) {
      return b.top();
    });
    bs = boxlist.map(function(b) {
      return b.bottom();
    });
    l = ls.reduce(function(n, m) {
      return Math.min(n, m);
    });
    r = rs.reduce(function(n, m) {
      return Math.max(n, m);
    });
    t = ts.reduce(function(n, m) {
      return Math.min(n, m);
    });
    b = bs.reduce(function(n, m) {
      return Math.max(n, m);
    });
    return new Block(l, t, r - l, b - t);
  };

  blockcarve = function(aa, bb) {
    var a, b, blok, blokx, x1, x2, x3, x4, y1, y2, y3, y4, _i, _len, _results;
    b = boxesbounding([aa, bb]);
    a = aa.intersection(bb);
    x1 = b.left();
    x2 = a.left();
    x3 = a.right();
    x4 = b.right();
    y1 = b.top();
    y2 = a.top();
    y3 = a.bottom();
    y4 = b.bottom();
    blokx = [[x1, y1, x2 - x1, y2 - y1], [x2, y1, x3 - x2, y2 - y1], [x3, y1, x4 - x3, y2 - y1], [x1, y2, x2 - x1, y3 - y2], [x2, y2, x3 - x2, y3 - y2], [x3, y2, x4 - x3, y3 - y2], [x1, y3, x2 - x1, y4 - y3], [x2, y3, x3 - x2, y4 - y3], [x3, y3, x4 - x3, y4 - y3]];
    blokx = blokx.map(function(blok) {
      var newthing;
      newthing = new Block(blok[0], blok[1], blok[2], blok[3]);
      newthing.fixnegative();
      return newthing;
    });
    blokx = blokx.filter(function(blok) {
      return blok.strictoverlaps(aa) || blok.strictoverlaps(bb);
    });
    _results = [];
    for (_i = 0, _len = blokx.length; _i < _len; _i++) {
      blok = blokx[_i];
      _results.push(WORLD.bglayer.push(blok));
    }
    return _results;
  };

  UNIONTOOL = _.extend({}, NOOPTOOL, {
    name: "unfuck block overlaps",
    mousedown: function(e) {
      var a, b, blocks, p;
      p = adjustmouseevent(e);
      blocks = blocksatpoint(WORLD.bglayer, p);
      if (blocks.length === 2) {
        a = blocks[0];
        b = blocks[1];
        blockcarve(a, b);
        WORLD.bglayer = _.without(WORLD.bglayer, a);
        WORLD.bglayer = _.without(WORLD.bglayer, b);
        stage.removeChild(a._pixisprite);
        return stage.removeChild(b._pixisprite);
      }
    }
  });

  carveoutblock = function(b) {
    var block, bloke, tocarve, todelete, _i, _j, _len, _len1, _results;
    block = new Block(b.x, b.y, b.w, b.h);
    tocarve = block.allstrictoverlaps();
    for (_i = 0, _len = tocarve.length; _i < _len; _i++) {
      bloke = tocarve[_i];
      blockcarve(bloke, block);
    }
    todelete = block.allstrictoverlaps();
    _results = [];
    for (_j = 0, _len1 = todelete.length; _j < _len1; _j++) {
      bloke = todelete[_j];
      WORLD.bglayer = _.without(WORLD.bglayer, bloke);
      if (bloke._pixisprite != null) {
        _results.push(stage.removeChild(bloke._pixisprite));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  CARVER = _.extend({}, NOOPTOOL, {
    name: "block carver",
    mousedown: function(e) {
      var adjusted;
      if (e.button !== 0) {
        return;
      }
      adjusted = adjustmouseevent(e);
      adjusted = snapmouseadjust(adjusted);
      CARVER.creatingblock = new Block(adjusted.x, adjusted.y, 32, 32);
      return WORLD.bglayer.push(CARVER.creatingblock);
    },
    mouseup: function(e) {
      if (e.button !== 0) {
        return;
      }
      CARVER.creatingblock.fixnegative();
      carveoutblock(CARVER.creatingblock);
      return CARVER.creatingblock = false;
    },
    mousemove: function(e) {
      var creatingblock, currclickpos, mpos, offset;
      mpos = snapmouseadjust(adjustmouseevent(e));
      creatingblock = CARVER.creatingblock;
      if (creatingblock) {
        creatingblock.w = mpos.x - creatingblock.x;
        creatingblock.h = mpos.y - creatingblock.y;
        creatingblock.src = "lila.png";
        creatingblock.removesprite();
      }
      if (ORIGCLICKPOS) {
        currclickpos = V(e.pageX, e.pageY);
        offset = currclickpos.vsub(ORIGCLICKPOS);
        return camera.offset = offset;
      }
    }
  });

  WATERTOOL = _.extend({}, NOOPTOOL, {
    name: "turn block into water",
    mousedown: function(e) {
      var adjusted, bl, blocksundercursor, _i, _len, _results;
      if (e.button !== 0) {
        return;
      }
      adjusted = adjustmouseevent(e);
      adjusted = snapmouseadjust(adjusted);
      blocksundercursor = blocksatpoint(WORLD.bglayer, adjusted);
      _results = [];
      for (_i = 0, _len = blocksundercursor.length; _i < _len; _i++) {
        bl = blocksundercursor[_i];
        WORLD.spritelayer.unshift(new Water(bl.x, bl.y, bl.w, bl.h));
        _results.push(bglayer_remove_block(bl));
      }
      return _results;
    }
  });

  BASETOOL = _.extend({}, NOOPTOOL, {
    held: {},
    mousedown: function(e) {
      this.held[e.button] = true;
      if (e.button === 0) {
        return this.leftclick(adjustmouseevent(e));
      }
    },
    mouseup: function(e) {
      return this.held[e.button] = false;
    },
    mousemove: function(e) {
      if (this.held[0]) {
        return this.lefthold(adjustmouseevent(e));
      }
    },
    leftclick: function(pos) {},
    lefthold: function(pos) {}
  });

  BLOCKPAINT = _.extend({}, BASETOOL, {
    name: "paint blocks",
    action: function(p) {
      var blocksundercursor, newblock, snapped;
      snapped = snapmouseadjust_down(p);
      blocksundercursor = blocksatpoint(WORLD.bglayer, p);
      if (blocksundercursor.length === 0) {
        newblock = new Block(snapped.x, snapped.y, 32, 32);
        return WORLD.bglayer.push(newblock);
      }
    },
    leftclick: function(p) {
      return this.action(p);
    },
    lefthold: function(p) {
      return this.action(p);
    }
  });

  alltools = [BLOCKCREATIONTOOL, MOVEBLOCKTOOL, MOVETOOL, TRIANGLETOOL, SPAWNERTOOL, TELEPORTTOOL, UNIONTOOL, CARVER, WATERTOOL, BLOCKPAINT];

  alltools.push(_.extend({}, NOOPTOOL, {
    name: "turn block into oneway",
    mousedown: function(e) {
      var adjusted, bl, blocksundercursor, _i, _len, _results;
      if (e.button !== 0) {
        return;
      }
      adjusted = adjustmouseevent(e);
      adjusted = snapmouseadjust(adjusted);
      blocksundercursor = blocksatpoint(WORLD.bglayer, adjusted);
      _results = [];
      for (_i = 0, _len = blocksundercursor.length; _i < _len; _i++) {
        bl = blocksundercursor[_i];
        WORLD.bglayer.unshift(new OnewayBlock(bl.x, bl.y, bl.w, bl.h));
        _results.push(bglayer_remove_block(bl));
      }
      return _results;
    }
  }));

  toolbar = $(xmltag('div', {
    "class": 'toolbar'
  }));

  toolbar.append($(xmltag('em', void 0, 'tools:')));

  toolbar.insertAfter($(renderer.view));

  alltools.forEach(function(t) {
    var but;
    but = $(xmltag('button', void 0, t.name));
    but.click(function() {
      return tool = t;
    });
    return toolbar.append(but);
  });

  allactions = {};

  this.allactions = allactions;

  bindaction = function(key, actionname) {
    return control.keytapbindname(key, actionname, allactions[actionname]);
  };

  this.bindaction = bindaction;

  readablebindings = function() {
    var ks, vs;
    ks = _.keys(control.bindingnames);
    vs = _.values(control.bindingnames);
    ks = ks.map(function(k) {
      return keyCodeToChar[Number(k)];
    });
    return _.zip(ks, vs);
  };

  allactions['spawn block under hero'] = function() {
    var creatingblock, p;
    p = ladybug.pos.vadd(V(-32, 0));
    creatingblock = new Block(p.x, p.y, 64, 64);
    return WORLD.bglayer.push(creatingblock);
  };

  getotherhero = function() {
    var heroes, i;
    heroes = jame.WORLD.spritelayer.filter(function(ent) {
      return ent instanceof Hero;
    });
    i = heroes.indexOf(ladybug);
    i = (i + 1) % heroes.length;
    return heroes[i];
  };

  allactions['swap character'] = function() {
    ladybug = getotherhero();
    return camera.trackingent = ladybug;
  };

  bindaction("u", "swap character");

  unzip = function(data) {
    return _.zip.apply(_, data);
  };

  allactions['export keybindings'] = function() {
    var data;
    data = JSON.stringify(readablebindings());
    return window.open().document.write(data);
  };

  allactions['import keybindings'] = function() {
    var data, func, newbinds, newholdbinds, rawdata;
    rawdata = prompt('paste data here');
    newbinds = [];
    newholdbinds = [];
    if (rawdata != null) {
      data = JSON.parse(rawdata);
      for (k in data) {
        v = data[k];
        k = keyCharToCode[v[0]];
        v = v[1];
        console.log(k, v);
        func = control.bindings[k];
        if (func != null) {
          newbinds.push({
            k: k,
            name: v,
            f: func
          });
        }
        func = control.holdbindings[k];
        if (func != null) {
          newholdbinds.push({
            k: k,
            name: v,
            f: func
          });
        }
      }
      console.log(newbinds);
      console.log(newholdbinds);
      control.bindings = {};
      control.holdbindings = {};
      control.bindingnames = {};
      newbinds.forEach(function(binding) {
        return control.bindings[binding.k] = binding.f;
      });
      return newholdbinds.forEach(function(binding) {
        return control.holdbindings[binding.k] = binding.f;
      });
    }
  };

  allactions['export level'] = function() {
    var data, ents, spawners;
    ents = WORLD.getallents();
    spawners = ents.filter(function(ent) {
      return ent instanceof Spawner;
    });
    data = {
      ents: spawners,
      blockdata: WORLD.bglayer
    };
    return window.open().document.write(JSON.stringify(data));
  };

  loadlevel = function(data) {
    loadblocks(data.blockdata);
    return loadents(data.ents);
  };

  allactions['import level'] = function() {
    var data, rawdata;
    rawdata = prompt('paste data here');
    if (rawdata != null) {
      data = JSON.parse(rawdata);
      WORLD.clear();
      loadlevel(data);
      WORLDINIT();
      return ladybug.respawn();
    }
  };

  allactions['load .json test level'] = function() {
    var levelfilename;
    levelfilename = "levels/2.json";
    return $.ajax(levelfilename, {
      success: function(data, status, xhr) {
        var jsondata;
        jsondata = JSON.parse(data);
        WORLD.clear();
        loadlevel(jsondata);
        WORLDINIT();
        return ladybug.respawn();
      }
    });
  };

  allactions['become queen of the slimes'] = function() {
    var hat;
    WORLD.spritelayer.push(hat = new Hat());
    hat.src = 'crown.png';
    return hat.parent = royaljel;
  };

  highlightoverlaps = function() {
    var alloverlaps, blox, flatlaps;
    blox = WORLD.bglayer;
    alloverlaps = blox.map(function(b) {
      return b.alloverlaps();
    });
    alloverlaps = alloverlaps.filter(function(i) {
      return i.length > 1;
    });
    flatlaps = _.flatten(alloverlaps);
    blox.forEach(function(b) {
      return b.HIGHLIGHT = void 0;
    });
    return flatlaps.forEach(function(b) {
      return b.HIGHLIGHT = true;
    });
  };

  allactions['highlight overlapping blocks'] = highlightoverlaps;

  objnames = function(objs) {
    return objs.map(function(obj) {
      return obj.constructor.name;
    });
  };

  allactions['generate entity list'] = function() {
    var entlist;
    entlist = $("<div>");
    body.append(entlist);
    return entlist.html(objnames(WORLD.spritelayer).join());
  };

  toolbar.append($(xmltag('em', void 0, 'actions: ')));

  for (k in allactions) {
    v = allactions[k];
    but = $(xmltag('button', void 0, k));
    but.click(v);
    toolbar.append(but);
  }

  ORIGCLICKPOS = false;

  mousemiddledownhandler = function(e) {
    if (e.button !== 1) {
      return;
    }
    e.preventDefault();
    return ORIGCLICKPOS = V(e.pageX, e.pageY);
  };

  mousemiddleuphandler = function(e) {
    if (e.button !== 1) {
      return;
    }
    e.preventDefault();
    ORIGCLICKPOS = false;
    return camera.offset = V();
  };

  $(renderer.view).mousedown(mousemiddledownhandler);

  $(renderer.view).mouseup(mousemiddleuphandler);

  bglayer_remove_block = function(ent) {
    WORLD.bglayer = _.without(WORLD.bglayer, ent);
    return removesprite(ent);
  };

  mouserightdownhandler = function(e) {
    var adjusted, blox, ent;
    if (e.button !== 2) {
      return;
    }
    e.preventDefault();
    adjusted = adjustmouseevent(e);
    blox = blocksatpoint(WORLD.bglayer, adjusted);
    if (blox.length > 0) {
      ent = blox[0];
      return bglayer_remove_block(ent);
    }
  };

  $(renderer.view).mousedown(mouserightdownhandler);

  $(renderer.view).contextmenu(function() {
    return false;
  });

  $(renderer.view).bind('wheel', function(e) {
    var delta;
    e.preventDefault();
    delta = e.originalEvent.deltaY;
    up = delta > 0;
    if (up) {
      camera.zoomout();
    }
    if (!up) {
      return camera.zoomin();
    }
  });

  lastmodified = function(date) {
    return body.prepend("<p>last modified " + (jQuery.timeago(new Date(date))) + ", " + date + "</p>");
  };

  $.ajax(THISFILE, {
    type: "HEAD",
    success: function(data, satus, xhr) {
      return lastmodified(xhr.getResponseHeader("Last-Modified"));
    }
  });

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  spawnselection = $(xmltag('select'));

  for (classname in spawnables) {
    spawnselection.append($(xmltag('option', {
      value: classname
    }, classname)));
  }

  toolbar.append($(xmltag('em', void 0, "entity class:")));

  toolbar.append(spawnselection);

  spawnselection.change(function(e) {
    return SPAWNTOOL.classname = $(this).val();
  });

  jame.WORLD = WORLD;

  jame.control = control;

  root.jame = jame;

  root.stage = stage;

  Block.prototype.allstrictoverlaps = function() {
    var blox,
      _this = this;
    blox = WORLD.bglayer;
    return blox.filter(function(otherblock) {
      return _this.strictoverlaps(otherblock);
    });
  };

  Block.prototype.alloverlaps = function() {
    var blox,
      _this = this;
    blox = WORLD.bglayer;
    return blox.filter(function(otherblock) {
      return _this.overlaps(otherblock);
    });
  };

  Block.prototype.equals = function(b) {
    return this.x = b.x && (this.y = b.y && (this.w = b.w && (this.h = b.h)));
  };

  jame.cleanobj = function(obj) {
    var arr, key, val;
    arr = (function() {
      var _results;
      _results = [];
      for (key in obj) {
        if (!__hasProp.call(obj, key)) continue;
        val = obj[key];
        _results.push([key, val]);
      }
      return _results;
    })();
    return _.object(arr);
  };

}).call(this);
